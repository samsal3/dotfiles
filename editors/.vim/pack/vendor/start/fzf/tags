!_TAG_EXTRA_DESCRIPTION	anonymous	/Include tags for non-named objects like lambda/
!_TAG_EXTRA_DESCRIPTION	fileScope	/Include tags of file scope/
!_TAG_EXTRA_DESCRIPTION	pseudo	/Include pseudo tags/
!_TAG_EXTRA_DESCRIPTION	subparser	/Include tags generated by subparsers/
!_TAG_FIELD_DESCRIPTION	epoch	/the last modified time of the input file (only for F\/file kind tag)/
!_TAG_FIELD_DESCRIPTION	file	/File-restricted scoping/
!_TAG_FIELD_DESCRIPTION	input	/input file/
!_TAG_FIELD_DESCRIPTION	name	/tag name/
!_TAG_FIELD_DESCRIPTION	pattern	/pattern/
!_TAG_FIELD_DESCRIPTION	typeref	/Type and name of a variable or typedef/
!_TAG_FIELD_DESCRIPTION!Go	package	/the real package specified by the package name/
!_TAG_FIELD_DESCRIPTION!Go	packageName	/the name for referring the package/
!_TAG_FIELD_DESCRIPTION!Ruby	mixin	/how the class or module is mixed in (mixin:HOW:MODULE)/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_KIND_DESCRIPTION!DTD	E,entity	/entities/
!_TAG_KIND_DESCRIPTION!DTD	a,attribute	/attributes/
!_TAG_KIND_DESCRIPTION!DTD	e,element	/elements/
!_TAG_KIND_DESCRIPTION!DTD	n,notation	/notations/
!_TAG_KIND_DESCRIPTION!DTD	p,parameterEntity	/parameter entities/
!_TAG_KIND_DESCRIPTION!Go	M,anonMember	/struct anonymous members/
!_TAG_KIND_DESCRIPTION!Go	P,packageName	/name for specifying imported package/
!_TAG_KIND_DESCRIPTION!Go	Y,unknown	/unknown/
!_TAG_KIND_DESCRIPTION!Go	a,talias	/type aliases/
!_TAG_KIND_DESCRIPTION!Go	c,const	/constants/
!_TAG_KIND_DESCRIPTION!Go	f,func	/functions/
!_TAG_KIND_DESCRIPTION!Go	i,interface	/interfaces/
!_TAG_KIND_DESCRIPTION!Go	m,member	/struct members/
!_TAG_KIND_DESCRIPTION!Go	n,methodSpec	/interface method specification/
!_TAG_KIND_DESCRIPTION!Go	p,package	/packages/
!_TAG_KIND_DESCRIPTION!Go	s,struct	/structs/
!_TAG_KIND_DESCRIPTION!Go	t,type	/types/
!_TAG_KIND_DESCRIPTION!Go	v,var	/variables/
!_TAG_KIND_DESCRIPTION!Make	I,makefile	/makefiles/
!_TAG_KIND_DESCRIPTION!Make	m,macro	/macros/
!_TAG_KIND_DESCRIPTION!Make	t,target	/targets/
!_TAG_KIND_DESCRIPTION!Man	S,subsection	/sub sections/
!_TAG_KIND_DESCRIPTION!Man	s,section	/sections/
!_TAG_KIND_DESCRIPTION!Man	t,title	/titles/
!_TAG_KIND_DESCRIPTION!Markdown	S,subsection	/level 2 sections/
!_TAG_KIND_DESCRIPTION!Markdown	T,l4subsection	/level 4 sections/
!_TAG_KIND_DESCRIPTION!Markdown	c,chapter	/chapters/
!_TAG_KIND_DESCRIPTION!Markdown	h,hashtag	/hashtags/
!_TAG_KIND_DESCRIPTION!Markdown	n,footnote	/footnotes/
!_TAG_KIND_DESCRIPTION!Markdown	s,section	/sections/
!_TAG_KIND_DESCRIPTION!Markdown	t,subsubsection	/level 3 sections/
!_TAG_KIND_DESCRIPTION!Markdown	u,l5subsection	/level 5 sections/
!_TAG_KIND_DESCRIPTION!PowerShell	c,class	/classes/
!_TAG_KIND_DESCRIPTION!PowerShell	e,enumlabel	/enum labels/
!_TAG_KIND_DESCRIPTION!PowerShell	f,function	/functions/
!_TAG_KIND_DESCRIPTION!PowerShell	g,enum	/enum names/
!_TAG_KIND_DESCRIPTION!PowerShell	i,filter	/filter/
!_TAG_KIND_DESCRIPTION!PowerShell	v,variable	/variables/
!_TAG_KIND_DESCRIPTION!Ruby	A,accessor	/accessors/
!_TAG_KIND_DESCRIPTION!Ruby	C,constant	/constants/
!_TAG_KIND_DESCRIPTION!Ruby	L,library	/libraries/
!_TAG_KIND_DESCRIPTION!Ruby	S,singletonMethod	/singleton methods/
!_TAG_KIND_DESCRIPTION!Ruby	a,alias	/aliases/
!_TAG_KIND_DESCRIPTION!Ruby	c,class	/classes/
!_TAG_KIND_DESCRIPTION!Ruby	f,method	/methods/
!_TAG_KIND_DESCRIPTION!Ruby	m,module	/modules/
!_TAG_KIND_DESCRIPTION!Sh	a,alias	/aliases/
!_TAG_KIND_DESCRIPTION!Sh	f,function	/functions/
!_TAG_KIND_DESCRIPTION!Sh	h,heredoc	/label for here document/
!_TAG_KIND_DESCRIPTION!Sh	s,script	/script files/
!_TAG_KIND_DESCRIPTION!Vim	C,constant	/constant definitions/
!_TAG_KIND_DESCRIPTION!Vim	a,augroup	/autocommand groups/
!_TAG_KIND_DESCRIPTION!Vim	c,command	/user-defined commands/
!_TAG_KIND_DESCRIPTION!Vim	f,function	/function definitions/
!_TAG_KIND_DESCRIPTION!Vim	k,class	/vim9script classes/
!_TAG_KIND_DESCRIPTION!Vim	m,map	/maps/
!_TAG_KIND_DESCRIPTION!Vim	n,filename	/vimball filename/
!_TAG_KIND_DESCRIPTION!Vim	v,variable	/variable definitions/
!_TAG_KIND_DESCRIPTION!Yaml	a,anchor	/anchors/
!_TAG_KIND_DESCRIPTION!Zsh	a,alias	/aliases/
!_TAG_KIND_DESCRIPTION!Zsh	f,function	/functions/
!_TAG_KIND_DESCRIPTION!Zsh	h,heredoc	/label for here document/
!_TAG_KIND_DESCRIPTION!Zsh	s,script	/script files/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_OUTPUT_VERSION	1.1	/current.age/
!_TAG_PARSER_VERSION!DTD	0.0	/current.age/
!_TAG_PARSER_VERSION!Go	0.0	/current.age/
!_TAG_PARSER_VERSION!Make	1.1	/current.age/
!_TAG_PARSER_VERSION!Man	0.0	/current.age/
!_TAG_PARSER_VERSION!Markdown	1.1	/current.age/
!_TAG_PARSER_VERSION!PowerShell	1.1	/current.age/
!_TAG_PARSER_VERSION!Ruby	0.0	/current.age/
!_TAG_PARSER_VERSION!Sh	0.0	/current.age/
!_TAG_PARSER_VERSION!Vim	1.1	/current.age/
!_TAG_PARSER_VERSION!Yaml	0.0	/current.age/
!_TAG_PARSER_VERSION!Zsh	0.0	/current.age/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/Users/samsal/developer/dotfiles/editors/.vim/pack/vendor/start/fzf/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	6.2.0	//
!_TAG_ROLE_DESCRIPTION!DTD!element	attOwner	/attributes owner/
!_TAG_ROLE_DESCRIPTION!DTD!parameterEntity	condition	/conditions/
!_TAG_ROLE_DESCRIPTION!DTD!parameterEntity	elementName	/element names/
!_TAG_ROLE_DESCRIPTION!DTD!parameterEntity	partOfAttDef	/part of attribute definition/
!_TAG_ROLE_DESCRIPTION!Go!package	imported	/imported package/
!_TAG_ROLE_DESCRIPTION!Go!unknown	receiverType	/receiver type/
!_TAG_ROLE_DESCRIPTION!Make!makefile	included	/included/
!_TAG_ROLE_DESCRIPTION!Make!makefile	optional	/optionally included/
!_TAG_ROLE_DESCRIPTION!Ruby!library	loaded	/loaded by "load" method/
!_TAG_ROLE_DESCRIPTION!Ruby!library	required	/loaded by "require" method/
!_TAG_ROLE_DESCRIPTION!Ruby!library	requiredRel	/loaded by "require_relative" method/
!_TAG_ROLE_DESCRIPTION!Sh!heredoc	endmarker	/end marker/
!_TAG_ROLE_DESCRIPTION!Sh!script	loaded	/loaded/
!_TAG_ROLE_DESCRIPTION!Yaml!anchor	alias	/alias/
!_TAG_ROLE_DESCRIPTION!Zsh!function	autoloaded	/function name passed to autoload built-in command/
!_TAG_ROLE_DESCRIPTION!Zsh!heredoc	endmarker	/end marker/
!_TAG_ROLE_DESCRIPTION!Zsh!script	autoloaded	/autoloaded/
!_TAG_ROLE_DESCRIPTION!Zsh!script	loaded	/loaded/
"\\033[2J" is an ANSI escape sequence for clearing the screen.	ADVANCED.md	/^# "\\033[2J" is an ANSI escape sequence for clearing the screen.$/;"	c
* Press alt-enter to switch to fzf-only filtering	ADVANCED.md	/^#    * Press alt-enter to switch to fzf-only filtering$/;"	c
- Easier to write multiple options	CHANGELOG.md	/^  # - Easier to write multiple options$/;"	c
- This style is still supported, but it's deprecated	CHANGELOG.md	/^  # - This style is still supported, but it's deprecated$/;"	c
0.21.1	CHANGELOG.md	/^0.21.1$/;"	s	chapter:CHANGELOG
0.22.0	CHANGELOG.md	/^0.22.0$/;"	s	chapter:CHANGELOG
0.23.0	CHANGELOG.md	/^0.23.0$/;"	s	chapter:CHANGELOG
0.23.1	CHANGELOG.md	/^0.23.1$/;"	s	chapter:CHANGELOG
0.24.0	CHANGELOG.md	/^0.24.0$/;"	s	chapter:CHANGELOG
0.24.1	CHANGELOG.md	/^0.24.1$/;"	s	chapter:CHANGELOG
0.24.2	CHANGELOG.md	/^0.24.2$/;"	s	chapter:CHANGELOG
0.24.3	CHANGELOG.md	/^0.24.3$/;"	s	chapter:CHANGELOG
0.24.4	CHANGELOG.md	/^0.24.4$/;"	s	chapter:CHANGELOG
0.25.0	CHANGELOG.md	/^0.25.0$/;"	s	chapter:CHANGELOG
0.25.1	CHANGELOG.md	/^0.25.1$/;"	s	chapter:CHANGELOG
0.26.0	CHANGELOG.md	/^0.26.0$/;"	s	chapter:CHANGELOG
0.27.0	CHANGELOG.md	/^0.27.0$/;"	s	chapter:CHANGELOG
0.27.1	CHANGELOG.md	/^0.27.1$/;"	s	chapter:CHANGELOG
0.27.2	CHANGELOG.md	/^0.27.2$/;"	s	chapter:CHANGELOG
0.27.3	CHANGELOG.md	/^0.27.3$/;"	s	chapter:CHANGELOG
0.28.0	CHANGELOG.md	/^0.28.0$/;"	s	chapter:CHANGELOG
0.29.0	CHANGELOG.md	/^0.29.0$/;"	s	chapter:CHANGELOG
0.30.0	CHANGELOG.md	/^0.30.0$/;"	s	chapter:CHANGELOG
0.31.0	CHANGELOG.md	/^0.31.0$/;"	s	chapter:CHANGELOG
0.32.0	CHANGELOG.md	/^0.32.0$/;"	s	chapter:CHANGELOG
0.32.1	CHANGELOG.md	/^0.32.1$/;"	s	chapter:CHANGELOG
0.33.0	CHANGELOG.md	/^0.33.0$/;"	s	chapter:CHANGELOG
0.34.0	CHANGELOG.md	/^0.34.0$/;"	s	chapter:CHANGELOG
0.35.0	CHANGELOG.md	/^0.35.0$/;"	s	chapter:CHANGELOG
0.35.1	CHANGELOG.md	/^0.35.1$/;"	s	chapter:CHANGELOG
0.36.0	CHANGELOG.md	/^0.36.0$/;"	s	chapter:CHANGELOG
0.37.0	CHANGELOG.md	/^0.37.0$/;"	s	chapter:CHANGELOG
0.38.0	CHANGELOG.md	/^0.38.0$/;"	s	chapter:CHANGELOG
0.39.0	CHANGELOG.md	/^0.39.0$/;"	s	chapter:CHANGELOG
0.40.0	CHANGELOG.md	/^0.40.0$/;"	s	chapter:CHANGELOG
0.41.0	CHANGELOG.md	/^0.41.0$/;"	s	chapter:CHANGELOG
0.41.1	CHANGELOG.md	/^0.41.1$/;"	s	chapter:CHANGELOG
0.42.0	CHANGELOG.md	/^0.42.0$/;"	s	chapter:CHANGELOG
0.43.0	CHANGELOG.md	/^0.43.0$/;"	s	chapter:CHANGELOG
0.44.0	CHANGELOG.md	/^0.44.0$/;"	s	chapter:CHANGELOG
0.44.1	CHANGELOG.md	/^0.44.1$/;"	s	chapter:CHANGELOG
0.45.0	CHANGELOG.md	/^0.45.0$/;"	s	chapter:CHANGELOG
0.46.0	CHANGELOG.md	/^0.46.0$/;"	s	chapter:CHANGELOG
0.46.1	CHANGELOG.md	/^0.46.1$/;"	s	chapter:CHANGELOG
0.47.0	CHANGELOG.md	/^0.47.0$/;"	s	chapter:CHANGELOG
0.48.0	CHANGELOG.md	/^0.48.0$/;"	s	chapter:CHANGELOG
0.48.1	CHANGELOG.md	/^0.48.1$/;"	s	chapter:CHANGELOG
0.49.0	CHANGELOG.md	/^0.49.0$/;"	s	chapter:CHANGELOG
0.50.0	CHANGELOG.md	/^0.50.0$/;"	s	chapter:CHANGELOG
0.51.0	CHANGELOG.md	/^0.51.0$/;"	s	chapter:CHANGELOG
0.52.0	CHANGELOG.md	/^0.52.0$/;"	s	chapter:CHANGELOG
0.52.1	CHANGELOG.md	/^0.52.1$/;"	s	chapter:CHANGELOG
0.53.0	CHANGELOG.md	/^0.53.0$/;"	s	chapter:CHANGELOG
0.54.0	CHANGELOG.md	/^0.54.0$/;"	s	chapter:CHANGELOG
0.54.1	CHANGELOG.md	/^0.54.1$/;"	s	chapter:CHANGELOG
0.54.2	CHANGELOG.md	/^0.54.2$/;"	s	chapter:CHANGELOG
0.54.3	CHANGELOG.md	/^0.54.3$/;"	s	chapter:CHANGELOG
0.55.0	CHANGELOG.md	/^0.55.0$/;"	s	chapter:CHANGELOG
0.56.0	CHANGELOG.md	/^0.56.0$/;"	s	chapter:CHANGELOG
0.56.1	CHANGELOG.md	/^0.56.1$/;"	s	chapter:CHANGELOG
0.56.2	CHANGELOG.md	/^0.56.2$/;"	s	chapter:CHANGELOG
0.56.3	CHANGELOG.md	/^0.56.3$/;"	s	chapter:CHANGELOG
0.57.0	CHANGELOG.md	/^0.57.0$/;"	s	chapter:CHANGELOG
0.58.0	CHANGELOG.md	/^0.58.0$/;"	s	chapter:CHANGELOG
0.59.0	CHANGELOG.md	/^0.59.0$/;"	s	chapter:CHANGELOG
0.60.0	CHANGELOG.md	/^0.60.0$/;"	s	chapter:CHANGELOG
0.60.1	CHANGELOG.md	/^0.60.1$/;"	s	chapter:CHANGELOG
0.60.2	CHANGELOG.md	/^0.60.2$/;"	s	chapter:CHANGELOG
0.60.3	CHANGELOG.md	/^0.60.3$/;"	s	chapter:CHANGELOG
0.61.0	CHANGELOG.md	/^0.61.0$/;"	s	chapter:CHANGELOG
0.61.1	CHANGELOG.md	/^0.61.1$/;"	s	chapter:CHANGELOG
0.61.2	CHANGELOG.md	/^0.61.2$/;"	s	chapter:CHANGELOG
0.61.3	CHANGELOG.md	/^0.61.3$/;"	s	chapter:CHANGELOG
0.62.0	CHANGELOG.md	/^0.62.0$/;"	s	chapter:CHANGELOG
0.63.0	CHANGELOG.md	/^0.63.0$/;"	s	chapter:CHANGELOG
0.64.0	CHANGELOG.md	/^0.64.0$/;"	s	chapter:CHANGELOG
0.65.0	CHANGELOG.md	/^0.65.0$/;"	s	chapter:CHANGELOG
0.65.1	CHANGELOG.md	/^0.65.1$/;"	s	chapter:CHANGELOG
0.65.2	CHANGELOG.md	/^0.65.2$/;"	s	chapter:CHANGELOG
0.66.0	CHANGELOG.md	/^0.66.0$/;"	s	chapter:CHANGELOG
1. Search for text in files using Ripgrep	ADVANCED.md	/^# 1. Search for text in files using Ripgrep$/;"	c
1. Update the list of processes by pressing CTRL-R	README.md	/^#### 1. Update the list of processes by pressing CTRL-R$/;"	t	subsection:Advanced topics""Reloading the candidate list
2. Interactively restart Ripgrep with reload action	ADVANCED.md	/^# 2. Interactively restart Ripgrep with reload action$/;"	c
2. Switch between sources by pressing CTRL-D or CTRL-F	README.md	/^#### 2. Switch between sources by pressing CTRL-D or CTRL-F$/;"	t	subsection:Advanced topics""Reloading the candidate list
3. Interactive ripgrep integration	README.md	/^#### 3. Interactive ripgrep integration$/;"	t	subsection:Advanced topics""Reloading the candidate list
3. Open the file in Vim	ADVANCED.md	/^# 3. Open the file in Vim$/;"	c
<Plug>(fzf-insert)	plugin/fzf.vim	/^nnoremap <silent> <Plug>(fzf-insert) i$/;"	m
<Plug>(fzf-normal)	plugin/fzf.vim	/^nnoremap <silent> <Plug>(fzf-normal) <Nop>$/;"	m
ACTION ARGUMENT	man/man1/fzf.1	/^.SS ACTION ARGUMENT$/;"	S	section:fzf""KEY/EVENT BINDINGS
ACTION COMPOSITION	man/man1/fzf.1	/^.SS ACTION COMPOSITION$/;"	S	section:fzf""KEY/EVENT BINDINGS
ADVANCED	man/man1/fzf.1	/^.SS ADVANCED$/;"	S	section:fzf""OPTIONS
AUTHOR	man/man1/fzf.1	/^.SH AUTHOR$/;"	s	title:fzf
AVAILABLE ACTIONS:	man/man1/fzf.1	/^.SS AVAILABLE ACTIONS:$/;"	S	section:fzf""KEY/EVENT BINDINGS
AVAILABLE EVENTS:	man/man1/fzf.1	/^.SS AVAILABLE EVENTS:$/;"	S	section:fzf""KEY/EVENT BINDINGS
AVAILABLE KEYS:    (SYNONYMS)	man/man1/fzf.1	/^.SS AVAILABLE KEYS:    (SYNONYMS)$/;"	S	section:fzf""KEY/EVENT BINDINGS
AcceptNth	src/options.go	/^	AcceptNth         func(Delimiter) func([]Token, int32) string$/;"	m	struct:fzf.Options	typeref:typename:func(Delimiter) func([]Token, int32) string
Add	src/cache.go	/^func (cc *ChunkCache) Add(chunk *Chunk, key string, list []Result) {$/;"	f	struct:fzf.ChunkCache
Add	src/util/concurrent_set.go	/^func (s *ConcurrentSet[T]) Add(item T) {$/;"	f	unknown:util.T
Advanced fzf examples	ADVANCED.md	/^Advanced fzf examples$/;"	c
Advanced topics	README.md	/^Advanced topics$/;"	s
Algo	src/algo/algo.go	/^type Algo func(caseSensitive bool, normalize bool, forward bool, input *util.Chars, pattern []ru/;"	t	package:algo	typeref:typename:func(caseSensitive bool, normalize bool, forward bool, input *util.Chars, pattern []rune, withPos bool, slab *util.Slab) (Result, *[]int)
Alt	src/tui/tui.go	/^	Alt    bool$/;"	m	struct:tui.MouseEvent	typeref:typename:bool
Alt	src/tui/tui.go	/^	Alt$/;"	c	package:tui
AltBackspace	src/tui/tui.go	/^	AltBackspace$/;"	c	package:tui
AltBg	src/tui/tui.go	/^	AltBg            ColorAttr$/;"	m	struct:tui.ColorTheme	typeref:typename:ColorAttr
AltDelete	src/tui/tui.go	/^	AltDelete$/;"	c	package:tui
AltDown	src/tui/tui.go	/^	AltDown$/;"	c	package:tui
AltEnd	src/tui/tui.go	/^	AltEnd$/;"	c	package:tui
AltHome	src/tui/tui.go	/^	AltHome$/;"	c	package:tui
AltKey	src/tui/tui.go	/^func AltKey(r rune) Event {$/;"	f	package:tui	typeref:typename:Event
AltLeft	src/tui/tui.go	/^	AltLeft$/;"	c	package:tui
AltPageDown	src/tui/tui.go	/^	AltPageDown$/;"	c	package:tui
AltPageUp	src/tui/tui.go	/^	AltPageUp$/;"	c	package:tui
AltRight	src/tui/tui.go	/^	AltRight$/;"	c	package:tui
AltShiftDelete	src/tui/tui.go	/^	AltShiftDelete$/;"	c	package:tui
AltShiftDown	src/tui/tui.go	/^	AltShiftDown$/;"	c	package:tui
AltShiftEnd	src/tui/tui.go	/^	AltShiftEnd$/;"	c	package:tui
AltShiftHome	src/tui/tui.go	/^	AltShiftHome$/;"	c	package:tui
AltShiftLeft	src/tui/tui.go	/^	AltShiftLeft$/;"	c	package:tui
AltShiftPageDown	src/tui/tui.go	/^	AltShiftPageDown$/;"	c	package:tui
AltShiftPageUp	src/tui/tui.go	/^	AltShiftPageUp$/;"	c	package:tui
AltShiftRight	src/tui/tui.go	/^	AltShiftRight$/;"	c	package:tui
AltShiftUp	src/tui/tui.go	/^	AltShiftUp$/;"	c	package:tui
AltUp	src/tui/tui.go	/^	AltUp$/;"	c	package:tui
Ambidouble	src/options.go	/^	Ambidouble        bool$/;"	m	struct:fzf.Options	typeref:typename:bool
Anchored\\-match	man/man1/fzf.1	/^.SS Anchored\\-match$/;"	S	section:fzf""EXTENDED SEARCH MODE
Ansi	src/options.go	/^	Ansi              bool$/;"	m	struct:fzf.Options	typeref:typename:bool
AsEvent	src/tui/tui.go	/^func (t EventType) AsEvent() Event {$/;"	f	type:tui.EventType	typeref:typename:Event
AsString	src/item.go	/^func (item *Item) AsString(stripAnsi bool) string {$/;"	f	struct:fzf.Item	typeref:typename:string
AsString	src/pattern.go	/^func (p *Pattern) AsString() string {$/;"	f	struct:fzf.Pattern	typeref:typename:string
AsUint16	src/util/util.go	/^func AsUint16(val int) uint16 {$/;"	f	package:util	typeref:typename:uint16
AtExit	src/util/atexit.go	/^func AtExit(fn func()) {$/;"	f	package:util
AtomicBool	src/util/atomicbool.go	/^type AtomicBool struct {$/;"	s	package:util
Attr	src/tui/dummy.go	/^type Attr int32$/;"	t	package:tui	typeref:typename:int32
Attr	src/tui/tcell.go	/^type Attr int32$/;"	t	package:tui	typeref:typename:int32
Attr	src/tui/tui.go	/^	Attr  Attr$/;"	m	struct:tui.ColorAttr	typeref:typename:Attr
Attr	src/tui/tui.go	/^func (p ColorPair) Attr() Attr {$/;"	f	struct:tui.ColorPair	typeref:typename:Attr
AttrClear	src/tui/dummy.go	/^	AttrClear     = Attr(1 << 9)$/;"	c	package:tui
AttrClear	src/tui/tcell.go	/^	AttrClear     = Attr(1 << 8)$/;"	c	package:tui
AttrRegular	src/tui/dummy.go	/^	AttrRegular   = Attr(1 << 8)$/;"	c	package:tui
AttrRegular	src/tui/tcell.go	/^	AttrRegular   = Attr(1 << 7)$/;"	c	package:tui
AttrUndefined	src/tui/dummy.go	/^	AttrUndefined = Attr(0)$/;"	c	package:tui
AttrUndefined	src/tui/tcell.go	/^	AttrUndefined = Attr(0)$/;"	c	package:tui
BASE	test/lib/common.rb	/^BASE = File.expand_path('..\/..', __dir__)$/;"	C
BASH_SCRIPTS	Makefile	/^BASH_SCRIPTS   := $(ROOT_DIR)\/bin\/fzf-preview.sh \\$/;"	m
BINARY	Makefile	/^	BINARY := $(BINARY32)$/;"	m
BINARY	Makefile	/^	BINARY := $(BINARY64)$/;"	m
BINARY	Makefile	/^	BINARY := $(BINARYARM5)$/;"	m
BINARY	Makefile	/^	BINARY := $(BINARYARM6)$/;"	m
BINARY	Makefile	/^	BINARY := $(BINARYARM7)$/;"	m
BINARY	Makefile	/^	BINARY := $(BINARYARM8)$/;"	m
BINARY	Makefile	/^	BINARY := $(BINARYLOONG64)$/;"	m
BINARY	Makefile	/^	BINARY := $(BINARYPPC64LE)$/;"	m
BINARY	Makefile	/^	BINARY := $(BINARYRISCV64)$/;"	m
BINARY	Makefile	/^	BINARY := $(BINARYS390)$/;"	m
BINARY32	Makefile	/^BINARY32       := fzf-$(GOOS)_386$/;"	m
BINARY64	Makefile	/^BINARY64       := fzf-$(GOOS)_amd64$/;"	m
BINARYARM5	Makefile	/^BINARYARM5     := fzf-$(GOOS)_arm5$/;"	m
BINARYARM6	Makefile	/^BINARYARM6     := fzf-$(GOOS)_arm6$/;"	m
BINARYARM7	Makefile	/^BINARYARM7     := fzf-$(GOOS)_arm7$/;"	m
BINARYARM8	Makefile	/^BINARYARM8     := fzf-$(GOOS)_arm8$/;"	m
BINARYLOONG64	Makefile	/^BINARYLOONG64  := fzf-$(GOOS)_loong64$/;"	m
BINARYPPC64LE	Makefile	/^BINARYPPC64LE  := fzf-$(GOOS)_ppc64le$/;"	m
BINARYRISCV64	Makefile	/^BINARYRISCV64  := fzf-$(GOOS)_riscv64$/;"	m
BINARYS390	Makefile	/^BINARYS390     := fzf-$(GOOS)_s390x$/;"	m
BUILD_FLAGS	Makefile	/^BUILD_FLAGS    := -a -ldflags "-s -w -X main.version=$(VERSION) -X main.revision=$(REVISION)" -t/;"	m
Backspace	src/tui/tui.go	/^	Backspace$/;"	c	package:tui
BackwardEOF	src/tui/tui.go	/^	BackwardEOF$/;"	c	package:tui
Bash	src/options.go	/^	Bash              bool$/;"	m	struct:fzf.Options	typeref:typename:bool
Become	src/util/util_unix.go	/^func (x *Executor) Become(stdin *os.File, environ []string, command string) {$/;"	f	struct:util.Executor
Become	src/util/util_windows.go	/^func (x *Executor) Become(stdin *os.File, environ []string, command string) {$/;"	f	struct:util.Executor
Bell	src/tui/dummy.go	/^func (r *FullscreenRenderer) Bell()                              {}$/;"	f	unknown:tui.FullscreenRenderer
Bell	src/tui/light.go	/^func (r *LightRenderer) Bell() {$/;"	f	unknown:tui.LightRenderer
Bell	src/tui/tcell.go	/^func (r *FullscreenRenderer) Bell() {$/;"	f	unknown:tui.FullscreenRenderer
Bell	src/tui/tui.go	/^	Bell()$/;"	n	interface:tui.Renderer
BenchmarkExtractColor	src/ansi_test.go	/^func BenchmarkExtractColor(b *testing.B) {$/;"	f	package:fzf
BenchmarkNextAnsiEscapeSequence	src/ansi_test.go	/^func BenchmarkNextAnsiEscapeSequence(b *testing.B) {$/;"	f	package:fzf
BenchmarkNextAnsiEscapeSequence_Regex	src/ansi_test.go	/^func BenchmarkNextAnsiEscapeSequence_Regex(b *testing.B) {$/;"	f	package:fzf
Bg	src/tui/tui.go	/^	Bg               ColorAttr$/;"	m	struct:tui.ColorTheme	typeref:typename:ColorAttr
Bg	src/tui/tui.go	/^func (p ColorPair) Bg() Color {$/;"	f	struct:tui.ColorPair	typeref:typename:Color
Binary releases	README.md	/^### Binary releases$/;"	S	section:Installation
Black	src/options.go	/^	Black             bool$/;"	m	struct:fzf.Options	typeref:typename:bool
Blink	src/tui/dummy.go	/^	Blink         = Attr(1 << 4)$/;"	c	package:tui
Blink	src/tui/tcell.go	/^	Blink              = Attr(tcell.AttrBlink)$/;"	c	package:tui
Blink2	src/tui/dummy.go	/^	Blink2        = Attr(1 << 5)$/;"	c	package:tui
BlockProfile	src/options.go	/^	BlockProfile      string$/;"	m	struct:fzf.Options	typeref:typename:string
Bold	src/options.go	/^	Bold              bool$/;"	m	struct:fzf.Options	typeref:typename:bool
Bold	src/tui/dummy.go	/^	Bold          = Attr(1)$/;"	c	package:tui
Bold	src/tui/tcell.go	/^	Bold          Attr = Attr(tcell.AttrBold)$/;"	c	package:tui	typeref:type:Attr
BoldForce	src/tui/dummy.go	/^	BoldForce     = Attr(1 << 10)$/;"	c	package:tui
BoldForce	src/tui/tcell.go	/^	BoldForce     = Attr(1 << 10)$/;"	c	package:tui
Border	src/options.go	/^func (o *previewOpts) Border() tui.BorderShape {$/;"	f	struct:fzf.previewOpts	typeref:typename:tui.BorderShape
Border	src/tui/tui.go	/^	Border           ColorAttr$/;"	m	struct:tui.ColorTheme	typeref:typename:ColorAttr
BorderBlock	src/tui/tui.go	/^	BorderBlock$/;"	c	package:tui
BorderBold	src/tui/tui.go	/^	BorderBold$/;"	c	package:tui
BorderBottom	src/tui/tui.go	/^	BorderBottom$/;"	c	package:tui
BorderCharacter	src/tui/tui.go	/^type BorderCharacter int$/;"	t	package:tui	typeref:typename:int
BorderDouble	src/tui/tui.go	/^	BorderDouble$/;"	c	package:tui
BorderHorizontal	src/tui/tui.go	/^	BorderHorizontal$/;"	c	package:tui
BorderLabel	src/options.go	/^	BorderLabel       labelOpts$/;"	m	struct:fzf.Options	typeref:typename:labelOpts
BorderLabel	src/tui/tui.go	/^	BorderLabel      ColorAttr$/;"	m	struct:tui.ColorTheme	typeref:typename:ColorAttr
BorderLeft	src/tui/tui.go	/^	BorderLeft$/;"	c	package:tui
BorderLine	src/tui/tui.go	/^	BorderLine$/;"	c	package:tui
BorderNone	src/tui/tui.go	/^	BorderNone$/;"	c	package:tui
BorderPhantom	src/tui/tui.go	/^	BorderPhantom$/;"	c	package:tui
BorderRight	src/tui/tui.go	/^	BorderRight$/;"	c	package:tui
BorderRounded	src/tui/tui.go	/^	BorderRounded$/;"	c	package:tui
BorderShape	src/options.go	/^	BorderShape       tui.BorderShape$/;"	m	struct:fzf.Options	typeref:typename:tui.BorderShape
BorderShape	src/tui/tui.go	/^type BorderShape int$/;"	t	package:tui	typeref:typename:int
BorderSharp	src/tui/tui.go	/^	BorderSharp$/;"	c	package:tui
BorderStyle	src/tui/tui.go	/^type BorderStyle struct {$/;"	s	package:tui
BorderThinBlock	src/tui/tui.go	/^	BorderThinBlock$/;"	c	package:tui
BorderTop	src/tui/tui.go	/^	BorderTop$/;"	c	package:tui
BorderUndefined	src/tui/tui.go	/^	BorderUndefined BorderShape = iota$/;"	c	package:tui	typeref:type:BorderShape
BorderVertical	src/tui/tui.go	/^	BorderVertical$/;"	c	package:tui
BracketedPasteBegin	src/tui/tui.go	/^	BracketedPasteBegin$/;"	c	package:tui
BracketedPasteEnd	src/tui/tui.go	/^	BracketedPasteEnd$/;"	c	package:tui
Build instructions	BUILD.md	/^Build instructions$/;"	s	chapter:Building fzf
BuildPattern	src/pattern.go	/^func BuildPattern(cache *ChunkCache, patternCache map[string]*Pattern, fuzzy bool, fuzzyAlgo alg/;"	f	package:fzf	typeref:typename:*Pattern
Building fzf	BUILD.md	/^Building fzf$/;"	c
Building fzf	README.md	/^Building fzf$/;"	s
ByOrder	src/result.go	/^type ByOrder []Offset$/;"	t	package:fzf	typeref:typename:[]Offset
ByRelevance	src/result.go	/^type ByRelevance []Result$/;"	t	package:fzf	typeref:typename:[]Result
ByRelevanceTac	src/result.go	/^type ByRelevanceTac []Result$/;"	t	package:fzf	typeref:typename:[]Result
Byte	src/tui/tui.go	/^func (t EventType) Byte() byte {$/;"	f	type:tui.EventType	typeref:typename:byte
Bytes	src/util/chars.go	/^func (chars *Chars) Bytes() []byte {$/;"	f	struct:util.Chars	typeref:typename:[]byte
CFill	src/tui/light.go	/^func (w *LightWindow) CFill(fg Color, bg Color, attr Attr, text string) FillReturn {$/;"	f	struct:tui.LightWindow	typeref:typename:FillReturn
CFill	src/tui/tcell.go	/^func (w *TcellWindow) CFill(fg Color, bg Color, a Attr, str string) FillReturn {$/;"	f	struct:tui.TcellWindow	typeref:typename:FillReturn
CFill	src/tui/tui.go	/^	CFill(fg Color, bg Color, attr Attr, text string) FillReturn$/;"	n	interface:tui.Window	typeref:typename:FillReturn
CHANGE PREVIEW WINDOW ATTRIBUTES	man/man1/fzf.1	/^.SS CHANGE PREVIEW WINDOW ATTRIBUTES$/;"	S	section:fzf""KEY/EVENT BINDINGS
CHANGELOG	CHANGELOG.md	/^CHANGELOG$/;"	c
COMMAND EXECUTION	man/man1/fzf.1	/^.SS COMMAND EXECUTION$/;"	S	section:fzf""KEY/EVENT BINDINGS
CPUProfile	src/options.go	/^	CPUProfile        string$/;"	m	struct:fzf.Options	typeref:typename:string
CPrint	src/tui/light.go	/^func (w *LightWindow) CPrint(pair ColorPair, text string) {$/;"	f	struct:tui.LightWindow
CPrint	src/tui/tcell.go	/^func (w *TcellWindow) CPrint(pair ColorPair, text string) {$/;"	f	struct:tui.TcellWindow
CPrint	src/tui/tui.go	/^	CPrint(color ColorPair, text string)$/;"	n	interface:tui.Window
CR	src/tui/light.go	/^const CR string = DIM + "␍"$/;"	c	package:tui	typeref:typename:string
CacheKey	src/pattern.go	/^func (p *Pattern) CacheKey() string {$/;"	f	struct:fzf.Pattern	typeref:typename:string
Can be now written as	CHANGELOG.md	/^  # Can be now written as$/;"	c
Case	src/options.go	/^	Case              Case$/;"	m	struct:fzf.Options	typeref:typename:Case
Case	src/options.go	/^type Case int$/;"	t	package:fzf	typeref:typename:int
CaseIgnore	src/options.go	/^	CaseIgnore$/;"	c	package:fzf
CaseRespect	src/options.go	/^	CaseRespect$/;"	c	package:fzf
CaseSmart	src/options.go	/^	CaseSmart Case = iota$/;"	c	package:fzf	typeref:type:Case
Change	src/tui/tui.go	/^	Change$/;"	c	package:tui
Char	src/tui/tui.go	/^	Char       rune$/;"	m	struct:tui.Event	typeref:typename:rune
Chars	src/util/chars.go	/^type Chars struct {$/;"	s	package:util
Chunk	src/chunklist.go	/^type Chunk struct {$/;"	s	package:fzf
ChunkCache	src/cache.go	/^type ChunkCache struct {$/;"	s	package:fzf
ChunkList	src/chunklist.go	/^type ChunkList struct {$/;"	s	package:fzf
Clear	src/cache.go	/^func (cc *ChunkCache) Clear() {$/;"	f	struct:fzf.ChunkCache
Clear	src/chunklist.go	/^func (cl *ChunkList) Clear() {$/;"	f	struct:fzf.ChunkList
Clear	src/tui/dummy.go	/^func (r *FullscreenRenderer) Clear()                             {}$/;"	f	unknown:tui.FullscreenRenderer
Clear	src/tui/light.go	/^func (r *LightRenderer) Clear() {$/;"	f	struct:tui.LightRenderer
Clear	src/tui/tcell.go	/^func (r *FullscreenRenderer) Clear() {$/;"	f	unknown:tui.FullscreenRenderer
Clear	src/tui/tui.go	/^	Clear()$/;"	n	interface:tui.Renderer
Clear	src/util/eventbox.go	/^func (events *Events) Clear() {$/;"	f	type:util.Events
ClearOnExit	src/options.go	/^	ClearOnExit       bool$/;"	m	struct:fzf.Options	typeref:typename:bool
ClickFooter	src/tui/tui.go	/^	ClickFooter$/;"	c	package:tui
ClickHeader	src/tui/tui.go	/^	ClickHeader$/;"	c	package:tui
Close	src/tui/dummy.go	/^func (r *FullscreenRenderer) Close()                             {}$/;"	f	unknown:tui.FullscreenRenderer
Close	src/tui/light.go	/^func (r *LightRenderer) Close() {$/;"	f	struct:tui.LightRenderer
Close	src/tui/tcell.go	/^func (r *FullscreenRenderer) Close() {$/;"	f	unknown:tui.FullscreenRenderer
Close	src/tui/tui.go	/^	Close()$/;"	n	interface:tui.Renderer
ColBorder	src/tui/tui.go	/^	ColBorder               ColorPair$/;"	v	package:tui	typeref:struct:ColorPair
ColBorderLabel	src/tui/tui.go	/^	ColBorderLabel          ColorPair$/;"	v	package:tui	typeref:struct:ColorPair
ColCurrent	src/tui/tui.go	/^	ColCurrent              ColorPair$/;"	v	package:tui	typeref:struct:ColorPair
ColCurrentCursor	src/tui/tui.go	/^	ColCurrentCursor        ColorPair$/;"	v	package:tui	typeref:struct:ColorPair
ColCurrentCursorEmpty	src/tui/tui.go	/^	ColCurrentCursorEmpty   ColorPair$/;"	v	package:tui	typeref:struct:ColorPair
ColCurrentMarker	src/tui/tui.go	/^	ColCurrentMarker        ColorPair$/;"	v	package:tui	typeref:struct:ColorPair
ColCurrentMatch	src/tui/tui.go	/^	ColCurrentMatch         ColorPair$/;"	v	package:tui	typeref:struct:ColorPair
ColCurrentSelectedEmpty	src/tui/tui.go	/^	ColCurrentSelectedEmpty ColorPair$/;"	v	package:tui	typeref:struct:ColorPair
ColCursor	src/tui/tui.go	/^	ColCursor               ColorPair$/;"	v	package:tui	typeref:struct:ColorPair
ColCursorEmpty	src/tui/tui.go	/^	ColCursorEmpty          ColorPair$/;"	v	package:tui	typeref:struct:ColorPair
ColCursorEmptyChar	src/tui/tui.go	/^	ColCursorEmptyChar      ColorPair$/;"	v	package:tui	typeref:struct:ColorPair
ColDisabled	src/tui/tui.go	/^	ColDisabled             ColorPair$/;"	v	package:tui	typeref:struct:ColorPair
ColFooter	src/tui/tui.go	/^	ColFooter               ColorPair$/;"	v	package:tui	typeref:struct:ColorPair
ColFooterBorder	src/tui/tui.go	/^	ColFooterBorder         ColorPair$/;"	v	package:tui	typeref:struct:ColorPair
ColFooterLabel	src/tui/tui.go	/^	ColFooterLabel          ColorPair$/;"	v	package:tui	typeref:struct:ColorPair
ColGapLine	src/tui/tui.go	/^	ColGapLine              ColorPair$/;"	v	package:tui	typeref:struct:ColorPair
ColGhost	src/tui/tui.go	/^	ColGhost                ColorPair$/;"	v	package:tui	typeref:struct:ColorPair
ColHeader	src/tui/tui.go	/^	ColHeader               ColorPair$/;"	v	package:tui	typeref:struct:ColorPair
ColHeaderBorder	src/tui/tui.go	/^	ColHeaderBorder         ColorPair$/;"	v	package:tui	typeref:struct:ColorPair
ColHeaderLabel	src/tui/tui.go	/^	ColHeaderLabel          ColorPair$/;"	v	package:tui	typeref:struct:ColorPair
ColInfo	src/tui/tui.go	/^	ColInfo                 ColorPair$/;"	v	package:tui	typeref:struct:ColorPair
ColInput	src/tui/tui.go	/^	ColInput                ColorPair$/;"	v	package:tui	typeref:struct:ColorPair
ColInputBorder	src/tui/tui.go	/^	ColInputBorder          ColorPair$/;"	v	package:tui	typeref:struct:ColorPair
ColInputLabel	src/tui/tui.go	/^	ColInputLabel           ColorPair$/;"	v	package:tui	typeref:struct:ColorPair
ColListBorder	src/tui/tui.go	/^	ColListBorder           ColorPair$/;"	v	package:tui	typeref:struct:ColorPair
ColListLabel	src/tui/tui.go	/^	ColListLabel            ColorPair$/;"	v	package:tui	typeref:struct:ColorPair
ColMarker	src/tui/tui.go	/^	ColMarker               ColorPair$/;"	v	package:tui	typeref:struct:ColorPair
ColMatch	src/tui/tui.go	/^	ColMatch                ColorPair$/;"	v	package:tui	typeref:struct:ColorPair
ColNormal	src/tui/tui.go	/^	ColNormal               ColorPair$/;"	v	package:tui	typeref:struct:ColorPair
ColPreview	src/tui/tui.go	/^	ColPreview              ColorPair$/;"	v	package:tui	typeref:struct:ColorPair
ColPreviewBorder	src/tui/tui.go	/^	ColPreviewBorder        ColorPair$/;"	v	package:tui	typeref:struct:ColorPair
ColPreviewLabel	src/tui/tui.go	/^	ColPreviewLabel         ColorPair$/;"	v	package:tui	typeref:struct:ColorPair
ColPreviewScrollbar	src/tui/tui.go	/^	ColPreviewScrollbar     ColorPair$/;"	v	package:tui	typeref:struct:ColorPair
ColPreviewSpinner	src/tui/tui.go	/^	ColPreviewSpinner       ColorPair$/;"	v	package:tui	typeref:struct:ColorPair
ColPrompt	src/tui/tui.go	/^	ColPrompt               ColorPair$/;"	v	package:tui	typeref:struct:ColorPair
ColScrollbar	src/tui/tui.go	/^	ColScrollbar            ColorPair$/;"	v	package:tui	typeref:struct:ColorPair
ColSelected	src/tui/tui.go	/^	ColSelected             ColorPair$/;"	v	package:tui	typeref:struct:ColorPair
ColSelectedMatch	src/tui/tui.go	/^	ColSelectedMatch        ColorPair$/;"	v	package:tui	typeref:struct:ColorPair
ColSeparator	src/tui/tui.go	/^	ColSeparator            ColorPair$/;"	v	package:tui	typeref:struct:ColorPair
ColSpinner	src/tui/tui.go	/^	ColSpinner              ColorPair$/;"	v	package:tui	typeref:struct:ColorPair
Color	src/tui/tui.go	/^	Color Color$/;"	m	struct:tui.ColorAttr	typeref:typename:Color
Color	src/tui/tui.go	/^type Color int32$/;"	t	package:tui	typeref:typename:int32
ColorAttr	src/tui/tui.go	/^type ColorAttr struct {$/;"	s	package:tui
ColorPair	src/tui/tui.go	/^type ColorPair struct {$/;"	s	package:tui
ColorTheme	src/tui/tui.go	/^type ColorTheme struct {$/;"	s	package:tui
Colored	src/tui/tui.go	/^	Colored          bool$/;"	m	struct:tui.ColorTheme	typeref:typename:bool
Colors	src/item.go	/^func (item *Item) Colors() []ansiOffset {$/;"	f	struct:fzf.Item	typeref:typename:[]ansiOffset
Columns	src/tui/tui.go	/^	Columns  int$/;"	m	struct:tui.TermSize	typeref:typename:int
Comparable	src/tui/tui.go	/^func (e Event) Comparable() Event {$/;"	f	unknown:tui.Event	typeref:typename:Event
CompareVersions	src/util/util.go	/^func CompareVersions(v1, v2 string) int {$/;"	f	package:util	typeref:typename:int
CompletionTest	test/test_shell_integration.rb	/^module CompletionTest$/;"	m	module:TestShell
ConcurrentSet	src/util/concurrent_set.go	/^type ConcurrentSet[T comparable] struct {$/;"	t	package:util	typeref:typename:[T comparable] struct { lock sync.RWMutex; items map[T]struct{};}
Confidentiality	SECURITY.md	/^## Confidentiality$/;"	s	chapter:Security Reporting
Configuration	README-VIM.md	/^### Configuration$/;"	S	section:FZF Vim integration""`:FZF[!]`
Constrain	src/util/util.go	/^func Constrain(val int, min int, max int) int {$/;"	f	package:util	typeref:typename:int
Constrain32	src/util/util.go	/^func Constrain32(val int32, min int32, max int32) int32 {$/;"	f	package:util	typeref:typename:int32
CopyRunes	src/util/chars.go	/^func (chars *Chars) CopyRunes(dest []rune, from int) {$/;"	f	struct:util.Chars
CountItems	src/chunklist.go	/^func CountItems(cs []*Chunk) int {$/;"	f	package:fzf	typeref:typename:int
Criteria	src/options.go	/^	Criteria          []criterion$/;"	m	struct:fzf.Options	typeref:typename:[]criterion
Ctrl	src/tui/tui.go	/^	Ctrl   bool$/;"	m	struct:tui.MouseEvent	typeref:typename:bool
CtrlA	src/tui/tui.go	/^	CtrlA$/;"	c	package:tui
CtrlAlt	src/tui/tui.go	/^	CtrlAlt$/;"	c	package:tui
CtrlAltBackspace	src/tui/tui.go	/^	CtrlAltBackspace$/;"	c	package:tui
CtrlAltDelete	src/tui/tui.go	/^	CtrlAltDelete$/;"	c	package:tui
CtrlAltDown	src/tui/tui.go	/^	CtrlAltDown$/;"	c	package:tui
CtrlAltEnd	src/tui/tui.go	/^	CtrlAltEnd$/;"	c	package:tui
CtrlAltHome	src/tui/tui.go	/^	CtrlAltHome$/;"	c	package:tui
CtrlAltKey	src/tui/tui.go	/^func CtrlAltKey(r rune) Event {$/;"	f	package:tui	typeref:typename:Event
CtrlAltLeft	src/tui/tui.go	/^	CtrlAltLeft$/;"	c	package:tui
CtrlAltPageDown	src/tui/tui.go	/^	CtrlAltPageDown$/;"	c	package:tui
CtrlAltPageUp	src/tui/tui.go	/^	CtrlAltPageUp$/;"	c	package:tui
CtrlAltRight	src/tui/tui.go	/^	CtrlAltRight$/;"	c	package:tui
CtrlAltShiftDelete	src/tui/tui.go	/^	CtrlAltShiftDelete$/;"	c	package:tui
CtrlAltShiftDown	src/tui/tui.go	/^	CtrlAltShiftDown$/;"	c	package:tui
CtrlAltShiftEnd	src/tui/tui.go	/^	CtrlAltShiftEnd$/;"	c	package:tui
CtrlAltShiftHome	src/tui/tui.go	/^	CtrlAltShiftHome$/;"	c	package:tui
CtrlAltShiftLeft	src/tui/tui.go	/^	CtrlAltShiftLeft$/;"	c	package:tui
CtrlAltShiftPageDown	src/tui/tui.go	/^	CtrlAltShiftPageDown$/;"	c	package:tui
CtrlAltShiftPageUp	src/tui/tui.go	/^	CtrlAltShiftPageUp$/;"	c	package:tui
CtrlAltShiftRight	src/tui/tui.go	/^	CtrlAltShiftRight$/;"	c	package:tui
CtrlAltShiftUp	src/tui/tui.go	/^	CtrlAltShiftUp$/;"	c	package:tui
CtrlAltUp	src/tui/tui.go	/^	CtrlAltUp$/;"	c	package:tui
CtrlB	src/tui/tui.go	/^	CtrlB$/;"	c	package:tui
CtrlBackSlash	src/tui/tui.go	/^	CtrlBackSlash$/;"	c	package:tui
CtrlBackspace	src/tui/tui.go	/^	CtrlBackspace$/;"	c	package:tui
CtrlC	src/tui/tui.go	/^	CtrlC$/;"	c	package:tui
CtrlCaret	src/tui/tui.go	/^	CtrlCaret$/;"	c	package:tui
CtrlD	src/tui/tui.go	/^	CtrlD$/;"	c	package:tui
CtrlDelete	src/tui/tui.go	/^	CtrlDelete$/;"	c	package:tui
CtrlDown	src/tui/tui.go	/^	CtrlDown$/;"	c	package:tui
CtrlE	src/tui/tui.go	/^	CtrlE$/;"	c	package:tui
CtrlEnd	src/tui/tui.go	/^	CtrlEnd$/;"	c	package:tui
CtrlF	src/tui/tui.go	/^	CtrlF$/;"	c	package:tui
CtrlG	src/tui/tui.go	/^	CtrlG$/;"	c	package:tui
CtrlH	src/tui/tui.go	/^	CtrlH$/;"	c	package:tui
CtrlHome	src/tui/tui.go	/^	CtrlHome$/;"	c	package:tui
CtrlJ	src/tui/tui.go	/^	CtrlJ$/;"	c	package:tui
CtrlK	src/tui/tui.go	/^	CtrlK$/;"	c	package:tui
CtrlL	src/tui/tui.go	/^	CtrlL$/;"	c	package:tui
CtrlLeft	src/tui/tui.go	/^	CtrlLeft$/;"	c	package:tui
CtrlN	src/tui/tui.go	/^	CtrlN$/;"	c	package:tui
CtrlO	src/tui/tui.go	/^	CtrlO$/;"	c	package:tui
CtrlP	src/tui/tui.go	/^	CtrlP$/;"	c	package:tui
CtrlPageDown	src/tui/tui.go	/^	CtrlPageDown$/;"	c	package:tui
CtrlPageUp	src/tui/tui.go	/^	CtrlPageUp$/;"	c	package:tui
CtrlQ	src/tui/tui.go	/^	CtrlQ$/;"	c	package:tui
CtrlR	src/tui/tui.go	/^	CtrlR$/;"	c	package:tui
CtrlRight	src/tui/tui.go	/^	CtrlRight$/;"	c	package:tui
CtrlRightBracket	src/tui/tui.go	/^	CtrlRightBracket$/;"	c	package:tui
CtrlS	src/tui/tui.go	/^	CtrlS$/;"	c	package:tui
CtrlShiftDelete	src/tui/tui.go	/^	CtrlShiftDelete$/;"	c	package:tui
CtrlShiftDown	src/tui/tui.go	/^	CtrlShiftDown$/;"	c	package:tui
CtrlShiftEnd	src/tui/tui.go	/^	CtrlShiftEnd$/;"	c	package:tui
CtrlShiftHome	src/tui/tui.go	/^	CtrlShiftHome$/;"	c	package:tui
CtrlShiftLeft	src/tui/tui.go	/^	CtrlShiftLeft$/;"	c	package:tui
CtrlShiftPageDown	src/tui/tui.go	/^	CtrlShiftPageDown$/;"	c	package:tui
CtrlShiftPageUp	src/tui/tui.go	/^	CtrlShiftPageUp$/;"	c	package:tui
CtrlShiftRight	src/tui/tui.go	/^	CtrlShiftRight$/;"	c	package:tui
CtrlShiftUp	src/tui/tui.go	/^	CtrlShiftUp$/;"	c	package:tui
CtrlSlash	src/tui/tui.go	/^	CtrlSlash$/;"	c	package:tui
CtrlSpace	src/tui/tui.go	/^	CtrlSpace$/;"	c	package:tui
CtrlT	src/tui/tui.go	/^	CtrlT$/;"	c	package:tui
CtrlU	src/tui/tui.go	/^	CtrlU$/;"	c	package:tui
CtrlUp	src/tui/tui.go	/^	CtrlUp$/;"	c	package:tui
CtrlV	src/tui/tui.go	/^	CtrlV$/;"	c	package:tui
CtrlW	src/tui/tui.go	/^	CtrlW$/;"	c	package:tui
CtrlX	src/tui/tui.go	/^	CtrlX$/;"	c	package:tui
CtrlY	src/tui/tui.go	/^	CtrlY$/;"	c	package:tui
CtrlZ	src/tui/tui.go	/^	CtrlZ$/;"	c	package:tui
Current	src/terminal.go	/^	Current    *StatusItem  `json:"current"`$/;"	m	struct:fzf.Status	typeref:typename:*StatusItem
Current	src/tui/tui.go	/^	Current          ColorAttr$/;"	m	struct:tui.ColorTheme	typeref:typename:ColorAttr
CurrentMatch	src/tui/tui.go	/^	CurrentMatch     ColorAttr$/;"	m	struct:tui.ColorTheme	typeref:typename:ColorAttr
Cursor	src/tui/tui.go	/^	Cursor           ColorAttr$/;"	m	struct:tui.ColorTheme	typeref:typename:ColorAttr
CursorLine	src/options.go	/^	CursorLine        bool$/;"	m	struct:fzf.Options	typeref:typename:bool
Custom fuzzy completion	README.md	/^### Custom fuzzy completion$/;"	S	section:Fuzzy completion for bash and zsh
Customizing completion source for paths and directories	README.md	/^### Customizing completion source for paths and directories$/;"	S	section:Fuzzy completion for bash and zsh
Customizing for different types of input	README.md	/^### Customizing for different types of input$/;"	S	section:Advanced topics
Customizing fzf options for completion	README.md	/^### Customizing fzf options for completion$/;"	S	section:Fuzzy completion for bash and zsh
Customizing the look	README.md	/^### Customizing the look$/;"	S	section:Usage
Cycle	src/options.go	/^	Cycle             bool$/;"	m	struct:fzf.Options	typeref:typename:bool
DEBUG	src/algo/algo.go	/^var DEBUG bool$/;"	v	package:algo	typeref:typename:bool
DEFAULT_TIMEOUT	test/lib/common.rb	/^DEFAULT_TIMEOUT = 10$/;"	C
DESCRIPTION	man/man1/fzf-tmux.1	/^.SH DESCRIPTION$/;"	s	title:fzf\\-tmux
DESCRIPTION	man/man1/fzf.1	/^.SH DESCRIPTION$/;"	s	title:fzf
DIM	src/tui/light.go	/^const DIM string = "\\x1b[2m"$/;"	c	package:tui	typeref:typename:string
DIRECTORY TRAVERSAL	man/man1/fzf.1	/^.SS DIRECTORY TRAVERSAL$/;"	S	section:fzf""OPTIONS
DISPLAY MODE	man/man1/fzf.1	/^.SS DISPLAY MODE$/;"	S	section:fzf""OPTIONS
Dark256	src/tui/tui.go	/^	Dark256   *ColorTheme$/;"	v	package:tui	typeref:typename:*ColorTheme
DarkBg	src/tui/tui.go	/^	DarkBg           ColorAttr$/;"	m	struct:tui.ColorTheme	typeref:typename:ColorAttr
Default16	src/tui/tui.go	/^	Default16 *ColorTheme$/;"	v	package:tui	typeref:typename:*ColorTheme
DefaultBorderShape	src/tui/dummy.go	/^var DefaultBorderShape = BorderRounded$/;"	v	package:tui
DefaultBorderShape	src/tui/tcell.go	/^var DefaultBorderShape BorderShape = BorderSharp$/;"	v	package:tui	typeref:typename:BorderShape
DefaultTheme	src/tui/dummy.go	/^func (r *FullscreenRenderer) DefaultTheme() *ColorTheme          { return nil }$/;"	f	unknown:tui.FullscreenRenderer	typeref:typename:*ColorTheme
DefaultTheme	src/tui/light_unix.go	/^func (r *LightRenderer) DefaultTheme() *ColorTheme {$/;"	f	unknown:tui.LightRenderer	typeref:typename:*ColorTheme
DefaultTheme	src/tui/light_windows.go	/^func (r *LightRenderer) DefaultTheme() *ColorTheme {$/;"	f	unknown:tui.LightRenderer	typeref:typename:*ColorTheme
DefaultTheme	src/tui/tcell.go	/^func (r *FullscreenRenderer) DefaultTheme() *ColorTheme {$/;"	f	unknown:tui.FullscreenRenderer	typeref:typename:*ColorTheme
DefaultTheme	src/tui/tui.go	/^	DefaultTheme() *ColorTheme$/;"	n	interface:tui.Renderer	typeref:typename:*ColorTheme
DefaultTtyDevice	src/tui/light.go	/^const DefaultTtyDevice string = "\/dev\/tty"$/;"	c	package:tui	typeref:typename:string
Delete	src/tui/tui.go	/^	Delete$/;"	c	package:tui
Delimiter	src/options.go	/^	Delimiter         Delimiter$/;"	m	struct:fzf.Options	typeref:typename:Delimiter
Delimiter	src/tokenizer.go	/^type Delimiter struct {$/;"	s	package:fzf
Demo	README.md	/^### Demo$/;"	S	section:Usage
Dim	src/tui/dummy.go	/^	Dim           = Attr(1 << 1)$/;"	c	package:tui
Dim	src/tui/tcell.go	/^	Dim                = Attr(tcell.AttrDim)$/;"	c	package:tui
Disabled	src/tui/tui.go	/^	Disabled         ColorAttr$/;"	m	struct:tui.ColorTheme	typeref:typename:ColorAttr
Display modes	ADVANCED.md	/^Display modes$/;"	s	chapter:Advanced fzf examples
Display modes	README.md	/^### Display modes$/;"	S	section:Usage
Double	src/tui/tui.go	/^	Double bool$/;"	m	struct:tui.MouseEvent	typeref:typename:bool
DoubleClick	src/tui/tui.go	/^	DoubleClick$/;"	c	package:tui
Down	src/tui/tui.go	/^	Down   bool$/;"	m	struct:tui.MouseEvent	typeref:typename:bool
Down	src/tui/tui.go	/^	Down$/;"	c	package:tui
DrawBorder	src/tui/light.go	/^func (w *LightWindow) DrawBorder() {$/;"	f	struct:tui.LightWindow
DrawBorder	src/tui/tcell.go	/^func (w *TcellWindow) DrawBorder() {$/;"	f	struct:tui.TcellWindow
DrawBorder	src/tui/tui.go	/^	DrawBorder()$/;"	n	interface:tui.Window
DrawHBorder	src/tui/light.go	/^func (w *LightWindow) DrawHBorder() {$/;"	f	struct:tui.LightWindow
DrawHBorder	src/tui/tcell.go	/^func (w *TcellWindow) DrawHBorder() {$/;"	f	struct:tui.TcellWindow
DrawHBorder	src/tui/tui.go	/^	DrawHBorder()$/;"	n	interface:tui.Window
DurWithin	src/util/util.go	/^func DurWithin($/;"	f	package:util	typeref:typename:time.Duration
Dynamic reloading of the list	ADVANCED.md	/^Dynamic reloading of the list$/;"	s	chapter:Advanced fzf examples
ENVIRONMENT VARIABLES	man/man1/fzf.1	/^.SH ENVIRONMENT VARIABLES$/;"	s	title:fzf
ENVIRONMENT VARIABLES EXPORTED TO CHILD PROCESSES	man/man1/fzf.1	/^.SH ENVIRONMENT VARIABLES EXPORTED TO CHILD PROCESSES$/;"	s	title:fzf
EOF	install	/^    cat >> "$src" << EOF$/;"	h
EOF	install	/^  cat << EOF$/;"	h
EOF	install	/^  cat > "$src" << EOF$/;"	h
EOF	install	/^  fish << EOF$/;"	h
EOF	shell/update.sh	/^    cat << EOF$/;"	h
EOF	uninstall	/^  cat << EOF$/;"	h
EXIT STATUS	man/man1/fzf.1	/^.SH EXIT STATUS$/;"	s	title:fzf
EXTENDED SEARCH MODE	man/man1/fzf.1	/^.SH EXTENDED SEARCH MODE$/;"	s	title:fzf
Ellipsis	src/options.go	/^	Ellipsis          *string$/;"	m	struct:fzf.Options	typeref:typename:*string
EmptyMerger	src/merger.go	/^func EmptyMerger(revision revision) *Merger {$/;"	f	package:fzf	typeref:typename:*Merger
EmptyTheme	src/tui/tui.go	/^func EmptyTheme() *ColorTheme {$/;"	f	package:tui	typeref:typename:*ColorTheme
Enabled	src/terminal.go	/^func (s resumableState) Enabled() bool {$/;"	f	type:fzf.resumableState	typeref:typename:bool
Enclose	src/tui/light.go	/^func (w *LightWindow) Enclose(y int, x int) bool {$/;"	f	struct:tui.LightWindow	typeref:typename:bool
Enclose	src/tui/tcell.go	/^func (w *TcellWindow) Enclose(y int, x int) bool {$/;"	f	struct:tui.TcellWindow	typeref:typename:bool
Enclose	src/tui/tui.go	/^	Enclose(y int, x int) bool$/;"	n	interface:tui.Window	typeref:typename:bool
EncloseX	src/tui/light.go	/^func (w *LightWindow) EncloseX(x int) bool {$/;"	f	struct:tui.LightWindow	typeref:typename:bool
EncloseX	src/tui/tcell.go	/^func (w *TcellWindow) EncloseX(x int) bool {$/;"	f	struct:tui.TcellWindow	typeref:typename:bool
EncloseX	src/tui/tui.go	/^	EncloseX(x int) bool$/;"	n	interface:tui.Window	typeref:typename:bool
EncloseY	src/tui/light.go	/^func (w *LightWindow) EncloseY(y int) bool {$/;"	f	struct:tui.LightWindow	typeref:typename:bool
EncloseY	src/tui/tcell.go	/^func (w *TcellWindow) EncloseY(y int) bool {$/;"	f	struct:tui.TcellWindow	typeref:typename:bool
EncloseY	src/tui/tui.go	/^	EncloseY(y int) bool$/;"	n	interface:tui.Window	typeref:typename:bool
End	src/algo/algo.go	/^	End   int$/;"	m	struct:algo.Result	typeref:typename:int
End	src/tui/tui.go	/^	End$/;"	c	package:tui
Enter	src/tui/tui.go	/^	Enter$/;"	c	package:tui
Environment variables	README.md	/^### Environment variables$/;"	S	section:Usage
Environment variables / Aliases	README.md	/^### Environment variables \/ Aliases$/;"	S	section:Fuzzy completion for bash and zsh
EqualMatch	src/algo/algo.go	/^func EqualMatch(caseSensitive bool, normalize bool, forward bool, text *util.Chars, pattern []ru/;"	f	package:algo	typeref:typename:(Result, *[]int)
Erase	src/tui/light.go	/^func (w *LightWindow) Erase() {$/;"	f	struct:tui.LightWindow
Erase	src/tui/tcell.go	/^func (w *TcellWindow) Erase() {$/;"	f	struct:tui.TcellWindow
Erase	src/tui/tui.go	/^	Erase()$/;"	n	interface:tui.Window
EraseMaybe	src/tui/light.go	/^func (w *LightWindow) EraseMaybe() bool {$/;"	f	struct:tui.LightWindow	typeref:typename:bool
EraseMaybe	src/tui/tcell.go	/^func (w *TcellWindow) EraseMaybe() bool {$/;"	f	struct:tui.TcellWindow	typeref:typename:bool
EraseMaybe	src/tui/tui.go	/^	EraseMaybe() bool$/;"	n	interface:tui.Window	typeref:typename:bool
Esc	src/tui/tui.go	/^	Esc$/;"	c	package:tui
Event	src/tui/tui.go	/^type Event struct {$/;"	s	package:tui
EventBox	src/util/eventbox.go	/^type EventBox struct {$/;"	s	package:util
EventType	src/tui/tui.go	/^type EventType int$/;"	t	package:tui	typeref:typename:int
EventType	src/util/eventbox.go	/^type EventType int$/;"	t	package:util	typeref:typename:int
Events	src/util/eventbox.go	/^type Events map[EventType]any$/;"	t	package:util	typeref:typename:map[EventType]any
EvtHeader	src/constants.go	/^	EvtHeader$/;"	c	package:fzf
EvtQuit	src/constants.go	/^	EvtQuit$/;"	c	package:fzf
EvtReadFin	src/constants.go	/^	EvtReadFin$/;"	c	package:fzf
EvtReadFin	src/util/eventbox_test.go	/^	EvtReadFin$/;"	c	package:util
EvtReadNew	src/constants.go	/^	EvtReadNew util.EventType = iota$/;"	c	package:fzf	typeref:typename:util.EventType
EvtReadNew	src/util/eventbox_test.go	/^	EvtReadNew EventType = iota$/;"	c	package:util	typeref:typename:EventType
EvtReady	src/constants.go	/^	EvtReady$/;"	c	package:fzf
EvtSearchFin	src/constants.go	/^	EvtSearchFin$/;"	c	package:fzf
EvtSearchFin	src/util/eventbox_test.go	/^	EvtSearchFin$/;"	c	package:util
EvtSearchNew	src/constants.go	/^	EvtSearchNew$/;"	c	package:fzf
EvtSearchNew	src/util/eventbox_test.go	/^	EvtSearchNew$/;"	c	package:util
EvtSearchProgress	src/constants.go	/^	EvtSearchProgress$/;"	c	package:fzf
EvtSearchProgress	src/util/eventbox_test.go	/^	EvtSearchProgress$/;"	c	package:util
ExactMatchBoundary	src/algo/algo.go	/^func ExactMatchBoundary(caseSensitive bool, normalize bool, forward bool, text *util.Chars, patt/;"	f	package:algo	typeref:typename:(Result, *[]int)
ExactMatchNaive	src/algo/algo.go	/^func ExactMatchNaive(caseSensitive bool, normalize bool, forward bool, text *util.Chars, pattern/;"	f	package:algo	typeref:typename:(Result, *[]int)
Exact\\-boundary\\-match (quoted both ends)	man/man1/fzf.1	/^.SS Exact\\-boundary\\-match (quoted both ends)$/;"	S	section:fzf""EXTENDED SEARCH MODE
Exact\\-match (quoted)	man/man1/fzf.1	/^.SS Exact\\-match (quoted)$/;"	S	section:fzf""EXTENDED SEARCH MODE
Exact\\-match by default	man/man1/fzf.1	/^.SS Exact\\-match by default$/;"	S	section:fzf""EXTENDED SEARCH MODE
Examples	README-VIM.md	/^#### Examples$/;"	t	subsection:FZF Vim integration""`:FZF[!]`""Configuration
Examples	README.md	/^Examples$/;"	s
Examples	man/man1/fzf.1	/^.SS Examples$/;"	S	section:fzf""FIELD INDEX EXPRESSION
ExecCommand	src/util/util_unix.go	/^func (x *Executor) ExecCommand(command string, setpgid bool) *exec.Cmd {$/;"	f	struct:util.Executor	typeref:typename:*exec.Cmd
ExecCommand	src/util/util_windows.go	/^func (x *Executor) ExecCommand(command string, setpgid bool) *exec.Cmd {$/;"	f	struct:util.Executor	typeref:typename:*exec.Cmd
Executing external programs	README.md	/^### Executing external programs$/;"	S	section:Advanced topics
Executor	src/util/util_unix.go	/^type Executor struct {$/;"	s	package:util
Executor	src/util/util_windows.go	/^type Executor struct {$/;"	s	package:util
Exit0	src/options.go	/^	Exit0             bool$/;"	m	struct:fzf.Options	typeref:typename:bool
ExitBecome	src/constants.go	/^	ExitBecome    = 126$/;"	c	package:fzf
ExitError	src/constants.go	/^	ExitError     = 2$/;"	c	package:fzf
ExitInterrupt	src/constants.go	/^	ExitInterrupt = 130$/;"	c	package:fzf
ExitNoMatch	src/constants.go	/^	ExitNoMatch   = 1$/;"	c	package:fzf
ExitOk	src/constants.go	/^	ExitOk        = 0$/;"	c	package:fzf
Expect	src/options.go	/^	Expect            map[tui.Event]string$/;"	m	struct:fzf.Options	typeref:typename:map[tui.Event]string
Explanation of `g:fzf_colors`	README-VIM.md	/^##### Explanation of `g:fzf_colors`$/;"	T	subsubsection:FZF Vim integration""`:FZF[!]`""Configuration""Examples
Extended	src/options.go	/^	Extended          bool$/;"	m	struct:fzf.Options	typeref:typename:bool
F1	src/tui/tui.go	/^	F1$/;"	c	package:tui
F10	src/tui/tui.go	/^	F10$/;"	c	package:tui
F11	src/tui/tui.go	/^	F11$/;"	c	package:tui
F12	src/tui/tui.go	/^	F12$/;"	c	package:tui
F2	src/tui/tui.go	/^	F2$/;"	c	package:tui
F3	src/tui/tui.go	/^	F3$/;"	c	package:tui
F4	src/tui/tui.go	/^	F4$/;"	c	package:tui
F5	src/tui/tui.go	/^	F5$/;"	c	package:tui
F6	src/tui/tui.go	/^	F6$/;"	c	package:tui
F7	src/tui/tui.go	/^	F7$/;"	c	package:tui
F8	src/tui/tui.go	/^	F8$/;"	c	package:tui
F9	src/tui/tui.go	/^	F9$/;"	c	package:tui
FIELD INDEX EXPRESSION	man/man1/fzf.1	/^.SH FIELD INDEX EXPRESSION$/;"	s	title:fzf
FIFONAME	test/lib/common.rb	/^  FIFONAME = Dir::Tmpname.create(%w[fzf-fifo]) {}$/;"	C	class:TestBase
FILE	test/lib/common.rb	/^FILE = File.expand_path(__FILE__)$/;"	C
FOOTER	man/man1/fzf.1	/^.SS FOOTER$/;"	S	section:fzf""OPTIONS
FZF	plugin/fzf.vim	/^command! -nargs=* -complete=dir -bang FZF call s:cmd(<bang>0, <f-args>)$/;"	c
FZF	test/lib/common.rb	/^FZF = %(FZF_DEFAULT_OPTS="--no-scrollbar --gutter ' ' --pointer '>' --marker '>'" FZF_DEFAULT_CO/;"	C
FZF Vim integration	README-VIM.md	/^FZF Vim integration$/;"	c
Fatal	src/tui/tui.go	/^	Fatal$/;"	c	package:tui
Fg	src/tui/tui.go	/^	Fg               ColorAttr$/;"	m	struct:tui.ColorTheme	typeref:typename:ColorAttr
Fg	src/tui/tui.go	/^func (p ColorPair) Fg() Color {$/;"	f	struct:tui.ColorPair	typeref:typename:Color
FileWord	src/options.go	/^	FileWord          bool$/;"	m	struct:fzf.Options	typeref:typename:bool
Files and directories	README.md	/^### Files and directories$/;"	S	section:Fuzzy completion for bash and zsh
Fill	src/tui/light.go	/^func (w *LightWindow) Fill(text string) FillReturn {$/;"	f	struct:tui.LightWindow	typeref:typename:FillReturn
Fill	src/tui/tcell.go	/^func (w *TcellWindow) Fill(str string) FillReturn {$/;"	f	struct:tui.TcellWindow	typeref:typename:FillReturn
Fill	src/tui/tui.go	/^	Fill(text string) FillReturn$/;"	n	interface:tui.Window	typeref:typename:FillReturn
FillContinue	src/tui/tui.go	/^	FillContinue FillReturn = iota$/;"	c	package:tui	typeref:type:FillReturn
FillNextLine	src/tui/tui.go	/^	FillNextLine$/;"	c	package:tui
FillReturn	src/tui/tui.go	/^type FillReturn int$/;"	t	package:tui	typeref:typename:int
FillSuspend	src/tui/tui.go	/^	FillSuspend$/;"	c	package:tui
Filter	src/options.go	/^	Filter            *string$/;"	m	struct:fzf.Options	typeref:typename:*string
FindIndex	src/merger.go	/^func (mg *Merger) FindIndex(itemIndex int32) int {$/;"	f	struct:fzf.Merger	typeref:typename:int
FinishFill	src/tui/light.go	/^func (w *LightWindow) FinishFill() {$/;"	f	struct:tui.LightWindow
FinishFill	src/tui/tcell.go	/^func (w *TcellWindow) FinishFill() {$/;"	f	struct:tui.TcellWindow
FinishFill	src/tui/tui.go	/^	FinishFill()$/;"	n	interface:tui.Window
First	src/merger.go	/^func (mg *Merger) First() Result {$/;"	f	struct:fzf.Merger	typeref:typename:Result
Fish	src/options.go	/^	Fish              bool$/;"	m	struct:fzf.Options	typeref:typename:bool
Fish shell	README.md	/^### Fish shell$/;"	S	section:Tips
Focus	src/tui/tui.go	/^	Focus$/;"	c	package:tui
Footer	src/options.go	/^	Footer            []string$/;"	m	struct:fzf.Options	typeref:typename:[]string
Footer	src/tui/tui.go	/^	Footer           ColorAttr$/;"	m	struct:tui.ColorTheme	typeref:typename:ColorAttr
FooterBg	src/tui/tui.go	/^	FooterBg         ColorAttr$/;"	m	struct:tui.ColorTheme	typeref:typename:ColorAttr
FooterBorder	src/tui/tui.go	/^	FooterBorder     ColorAttr$/;"	m	struct:tui.ColorTheme	typeref:typename:ColorAttr
FooterBorderShape	src/options.go	/^	FooterBorderShape tui.BorderShape$/;"	m	struct:fzf.Options	typeref:typename:tui.BorderShape
FooterLabel	src/options.go	/^	FooterLabel       labelOpts$/;"	m	struct:fzf.Options	typeref:typename:labelOpts
FooterLabel	src/tui/tui.go	/^	FooterLabel      ColorAttr$/;"	m	struct:tui.ColorTheme	typeref:typename:ColorAttr
ForEach	src/util/concurrent_set.go	/^func (s *ConcurrentSet[T]) ForEach(fn func(item T)) {$/;"	f	unknown:util.T
Force	src/terminal.go	/^func (s *resumableState) Force(flag bool) {$/;"	f	type:fzf.resumableState
ForceTtyIn	src/options.go	/^	ForceTtyIn        bool$/;"	m	struct:fzf.Options	typeref:typename:bool
FullBg	src/tui/dummy.go	/^	FullBg        = Attr(1 << 11)$/;"	c	package:tui
FullBg	src/tui/tcell.go	/^	FullBg        = Attr(1 << 11)$/;"	c	package:tui
FullscreenRenderer	src/tui/tui.go	/^type FullscreenRenderer struct {$/;"	s	package:tui
Fuzzy	src/options.go	/^	Fuzzy             bool$/;"	m	struct:fzf.Options	typeref:typename:bool
Fuzzy completion for bash and zsh	README.md	/^Fuzzy completion for bash and zsh$/;"	s
FuzzyAlgo	src/options.go	/^	FuzzyAlgo         algo.Algo$/;"	m	struct:fzf.Options	typeref:typename:algo.Algo
FuzzyMatchV1	src/algo/algo.go	/^func FuzzyMatchV1(caseSensitive bool, normalize bool, forward bool, text *util.Chars, pattern []/;"	f	package:algo	typeref:typename:(Result, *[]int)
FuzzyMatchV2	src/algo/algo.go	/^func FuzzyMatchV2(caseSensitive bool, normalize bool, forward bool, input *util.Chars, pattern [/;"	f	package:algo	typeref:typename:(Result, *[]int)
GLOBAL STYLE	man/man1/fzf.1	/^.SS GLOBAL STYLE$/;"	S	section:fzf""OPTIONS
GO	Makefile	/^GO             ?= go$/;"	m
GOOS	Makefile	/^GOOS           ?= $(shell $(GO) env GOOS)$/;"	m
Gap	src/options.go	/^	Gap               int$/;"	m	struct:fzf.Options	typeref:typename:int
GapLine	src/options.go	/^	GapLine           *string$/;"	m	struct:fzf.Options	typeref:typename:*string
GapLine	src/tui/tui.go	/^	GapLine          ColorAttr$/;"	m	struct:tui.ColorTheme	typeref:typename:ColorAttr
Get	src/merger.go	/^func (mg *Merger) Get(idx int) Result {$/;"	f	struct:fzf.Merger	typeref:typename:Result
Get	src/util/atomicbool.go	/^func (a *AtomicBool) Get() bool {$/;"	f	struct:util.AtomicBool	typeref:typename:bool
Get	src/util/chars.go	/^func (chars *Chars) Get(i int) rune {$/;"	f	struct:util.Chars	typeref:typename:rune
GetChar	src/tui/dummy.go	/^func (r *FullscreenRenderer) GetChar() Event { return Event{} }$/;"	f	unknown:tui.FullscreenRenderer	typeref:typename:Event
GetChar	src/tui/light.go	/^func (r *LightRenderer) GetChar() Event {$/;"	f	struct:tui.LightRenderer	typeref:typename:Event
GetChar	src/tui/tcell.go	/^func (r *FullscreenRenderer) GetChar() Event {$/;"	f	unknown:tui.FullscreenRenderer	typeref:typename:Event
GetChar	src/tui/tui.go	/^	GetChar() Event$/;"	n	interface:tui.Renderer	typeref:typename:Event
Ghost	src/options.go	/^	Ghost             string$/;"	m	struct:fzf.Options	typeref:typename:string
Ghost	src/tui/tui.go	/^	Ghost            ColorAttr$/;"	m	struct:tui.ColorTheme	typeref:typename:ColorAttr
Global options supported by `fzf#wrap`	README-VIM.md	/^### Global options supported by `fzf#wrap`$/;"	S	section:FZF Vim integration""`fzf#wrap`
Gutter	src/options.go	/^	Gutter            *string$/;"	m	struct:fzf.Options	typeref:typename:*string
Gutter	src/tui/tui.go	/^	Gutter           ColorAttr$/;"	m	struct:tui.ColorTheme	typeref:typename:ColorAttr
HEADER	man/man1/fzf.1	/^.SS HEADER$/;"	S	section:fzf""OPTIONS
HELP	man/man1/fzf.1	/^.SS HELP$/;"	S	section:fzf""OPTIONS
HISTORY	man/man1/fzf.1	/^.SS HISTORY$/;"	S	section:fzf""OPTIONS
HasBg	src/tui/tui.go	/^func (p ColorPair) HasBg() bool {$/;"	f	struct:tui.ColorPair	typeref:typename:bool
HasBottom	src/tui/tui.go	/^func (s BorderShape) HasBottom() bool {$/;"	f	type:tui.BorderShape	typeref:typename:bool
HasFullscreenRenderer	src/tui/dummy.go	/^func HasFullscreenRenderer() bool {$/;"	f	package:tui	typeref:typename:bool
HasFullscreenRenderer	src/tui/tcell.go	/^func HasFullscreenRenderer() bool {$/;"	f	package:tui	typeref:typename:bool
HasLeft	src/tui/tui.go	/^func (s BorderShape) HasLeft() bool {$/;"	f	type:tui.BorderShape	typeref:typename:bool
HasRight	src/tui/tui.go	/^func (s BorderShape) HasRight() bool {$/;"	f	type:tui.BorderShape	typeref:typename:bool
HasTop	src/tui/tui.go	/^func (s BorderShape) HasTop() bool {$/;"	f	type:tui.BorderShape	typeref:typename:bool
Header	src/options.go	/^	Header            []string$/;"	m	struct:fzf.Options	typeref:typename:[]string
Header	src/tui/tui.go	/^	Header           ColorAttr$/;"	m	struct:tui.ColorTheme	typeref:typename:ColorAttr
HeaderBg	src/tui/tui.go	/^	HeaderBg         ColorAttr$/;"	m	struct:tui.ColorTheme	typeref:typename:ColorAttr
HeaderBorder	src/tui/tui.go	/^	HeaderBorder     ColorAttr$/;"	m	struct:tui.ColorTheme	typeref:typename:ColorAttr
HeaderBorderShape	src/options.go	/^	HeaderBorderShape tui.BorderShape$/;"	m	struct:fzf.Options	typeref:typename:tui.BorderShape
HeaderFirst	src/options.go	/^	HeaderFirst       bool$/;"	m	struct:fzf.Options	typeref:typename:bool
HeaderLabel	src/options.go	/^	HeaderLabel       labelOpts$/;"	m	struct:fzf.Options	typeref:typename:labelOpts
HeaderLabel	src/tui/tui.go	/^	HeaderLabel      ColorAttr$/;"	m	struct:tui.ColorTheme	typeref:typename:ColorAttr
HeaderLines	src/options.go	/^	HeaderLines       int$/;"	m	struct:fzf.Options	typeref:typename:int
HeaderLinesShape	src/options.go	/^	HeaderLinesShape  tui.BorderShape$/;"	m	struct:fzf.Options	typeref:typename:tui.BorderShape
Height	src/options.go	/^	Height            heightSpec$/;"	m	struct:fzf.Options	typeref:typename:heightSpec
Height	src/tui/light.go	/^func (w *LightWindow) Height() int {$/;"	f	struct:tui.LightWindow	typeref:typename:int
Height	src/tui/tcell.go	/^func (w *TcellWindow) Height() int {$/;"	f	struct:tui.TcellWindow	typeref:typename:int
Height	src/tui/tui.go	/^	Height() int$/;"	n	interface:tui.Window	typeref:typename:int
Help	src/options.go	/^	Help              bool$/;"	m	struct:fzf.Options	typeref:typename:bool
HexToColor	src/tui/tui.go	/^func HexToColor(rrggbb string) Color {$/;"	f	package:tui	typeref:typename:Color
Hide statusline	README-VIM.md	/^### Hide statusline$/;"	S	section:FZF Vim integration""Tips
HideCursor	src/tui/dummy.go	/^func (r *FullscreenRenderer) HideCursor()                        {}$/;"	f	unknown:tui.FullscreenRenderer
HideCursor	src/tui/light.go	/^func (r *LightRenderer) HideCursor() {$/;"	f	struct:tui.LightRenderer
HideCursor	src/tui/tcell.go	/^func (r *FullscreenRenderer) HideCursor() {$/;"	f	unknown:tui.FullscreenRenderer
HideCursor	src/tui/tui.go	/^	HideCursor()$/;"	n	interface:tui.Renderer
Highlights	README.md	/^Highlights$/;"	s
History	src/history.go	/^type History struct {$/;"	s	package:fzf
History	src/options.go	/^	History           *History$/;"	m	struct:fzf.Options	typeref:typename:*History
Home	src/tui/tui.go	/^	Home$/;"	c	package:tui
Host names	README.md	/^### Host names$/;"	S	section:Fuzzy completion for bash and zsh
Hscroll	src/options.go	/^	Hscroll           bool$/;"	m	struct:fzf.Options	typeref:typename:bool
HscrollOff	src/options.go	/^	HscrollOff        int$/;"	m	struct:fzf.Options	typeref:typename:int
I16	src/util/slab.go	/^	I16 []int16$/;"	m	struct:util.Slab	typeref:typename:[]int16
I32	src/util/slab.go	/^	I32 []int32$/;"	m	struct:util.Slab	typeref:typename:[]int32
INPUT SECTION	man/man1/fzf.1	/^.SS INPUT SECTION$/;"	S	section:fzf""OPTIONS
INPUT/OUTPUT	man/man1/fzf.1	/^.SS INPUT\/OUTPUT$/;"	S	section:fzf""OPTIONS
Index	src/item.go	/^func (item *Item) Index() int32 {$/;"	f	struct:fzf.Item	typeref:typename:int32
Index	src/result.go	/^func (result *Result) Index() int32 {$/;"	f	struct:fzf.Result	typeref:typename:int32
Index	src/terminal.go	/^	Index int    `json:"index"`$/;"	m	struct:fzf.StatusItem	typeref:typename:int
Index	src/util/chars.go	/^	Index int32$/;"	m	struct:util.Chars	typeref:typename:int32
Info	src/tui/tui.go	/^	Info             ColorAttr$/;"	m	struct:tui.ColorTheme	typeref:typename:ColorAttr
InfoCommand	src/options.go	/^	InfoCommand       string$/;"	m	struct:fzf.Options	typeref:typename:string
InfoPrefix	src/options.go	/^	InfoPrefix        string$/;"	m	struct:fzf.Options	typeref:typename:string
InfoStyle	src/options.go	/^	InfoStyle         infoStyle$/;"	m	struct:fzf.Options	typeref:typename:infoStyle
Init	src/algo/algo.go	/^func Init(scheme string) bool {$/;"	f	package:algo	typeref:typename:bool
Init	src/tui/dummy.go	/^func (r *FullscreenRenderer) Init() error                        { return nil }$/;"	f	unknown:tui.FullscreenRenderer	typeref:typename:error
Init	src/tui/light.go	/^func (r *LightRenderer) Init() error {$/;"	f	struct:tui.LightRenderer	typeref:typename:error
Init	src/tui/tcell.go	/^func (r *FullscreenRenderer) Init() error {$/;"	f	unknown:tui.FullscreenRenderer	typeref:typename:error
Init	src/tui/tui.go	/^	Init() error$/;"	n	interface:tui.Renderer	typeref:typename:error
InitTheme	src/tui/tui.go	/^func InitTheme(theme *ColorTheme, baseTheme *ColorTheme, forceBlack bool, hasInputWindow bool, h/;"	f	package:tui
Input	src/options.go	/^	Input             chan string$/;"	m	struct:fzf.Options	typeref:typename:chan string
Input	src/terminal.go	/^func (t *Terminal) Input() (bool, []rune) {$/;"	f	struct:fzf.Terminal	typeref:typename:(bool, []rune)
Input	src/tui/tui.go	/^	Input            ColorAttr$/;"	m	struct:tui.ColorTheme	typeref:typename:ColorAttr
InputBg	src/tui/tui.go	/^	InputBg          ColorAttr$/;"	m	struct:tui.ColorTheme	typeref:typename:ColorAttr
InputBorder	src/tui/tui.go	/^	InputBorder      ColorAttr$/;"	m	struct:tui.ColorTheme	typeref:typename:ColorAttr
InputBorderShape	src/options.go	/^	InputBorderShape  tui.BorderShape$/;"	m	struct:fzf.Options	typeref:typename:tui.BorderShape
InputLabel	src/options.go	/^	InputLabel        labelOpts$/;"	m	struct:fzf.Options	typeref:typename:labelOpts
InputLabel	src/tui/tui.go	/^	InputLabel       ColorAttr$/;"	m	struct:tui.ColorTheme	typeref:typename:ColorAttr
Inputless	src/options.go	/^	Inputless         bool$/;"	m	struct:fzf.Options	typeref:typename:bool
Insert	src/tui/tui.go	/^	Insert$/;"	c	package:tui
Installation	README-VIM.md	/^Installation$/;"	s	chapter:FZF Vim integration
Installation	README.md	/^Installation$/;"	s
Int	src/tui/tui.go	/^func (t EventType) Int() int {$/;"	f	type:tui.EventType	typeref:typename:int
Introduction	ADVANCED.md	/^Introduction$/;"	s	chapter:Advanced fzf examples
Invalid	src/tui/tui.go	/^	Invalid$/;"	c	package:tui
IsAwk	src/tokenizer.go	/^func (d Delimiter) IsAwk() bool {$/;"	f	struct:fzf.Delimiter	typeref:typename:bool
IsBytes	src/util/chars.go	/^func (chars *Chars) IsBytes() bool {$/;"	f	struct:util.Chars	typeref:typename:bool
IsColorDefined	src/tui/tui.go	/^func (a ColorAttr) IsColorDefined() bool {$/;"	f	struct:tui.ColorAttr	typeref:typename:bool
IsDefault	src/tui/tui.go	/^func (c Color) IsDefault() bool {$/;"	f	type:tui.Color	typeref:typename:bool
IsEmpty	src/pattern.go	/^func (p *Pattern) IsEmpty() bool {$/;"	f	struct:fzf.Pattern	typeref:typename:bool
IsFull	src/chunklist.go	/^func (c *Chunk) IsFull() bool {$/;"	f	struct:fzf.Chunk	typeref:typename:bool
IsFull	src/tokenizer.go	/^func (r Range) IsFull() bool {$/;"	f	struct:fzf.Range	typeref:typename:bool
IsFullBgMarker	src/result.go	/^func (co colorOffset) IsFullBgMarker(at int32) bool {$/;"	f	struct:fzf.colorOffset	typeref:typename:bool
IsFullBgMarker	src/tui/tui.go	/^func (p ColorPair) IsFullBgMarker() bool {$/;"	f	struct:tui.ColorPair	typeref:typename:bool
IsLightRendererSupported	src/tui/light_unix.go	/^func IsLightRendererSupported() bool {$/;"	f	package:tui	typeref:typename:bool
IsLightRendererSupported	src/tui/light_windows.go	/^func IsLightRendererSupported() bool {$/;"	f	package:tui	typeref:typename:bool
IsLocal	src/server.go	/^func (addr listenAddress) IsLocal() bool {$/;"	f	struct:fzf.listenAddress	typeref:typename:bool
IsTty	src/util/util.go	/^func IsTty(file *os.File) bool {$/;"	f	package:util	typeref:typename:bool
IsWindows	src/util/util_unix.go	/^func IsWindows() bool {$/;"	f	package:util	typeref:typename:bool
IsWindows	src/util/util_windows.go	/^func IsWindows() bool {$/;"	f	package:util	typeref:typename:bool
Italic	src/tui/dummy.go	/^	Italic        = Attr(1 << 2)$/;"	c	package:tui
Italic	src/tui/tcell.go	/^	Italic             = Attr(tcell.AttrItalic)$/;"	c	package:tui
Item	src/item.go	/^type Item struct {$/;"	s	package:fzf
ItemBuilder	src/chunklist.go	/^type ItemBuilder func(*Item, []byte) bool$/;"	t	package:fzf	typeref:typename:func(*Item, []byte) bool
JoinTokens	src/tokenizer.go	/^func JoinTokens(tokens []Token) string {$/;"	f	package:fzf	typeref:typename:string
Jump	src/tui/tui.go	/^	Jump$/;"	c	package:tui
JumpCancel	src/tui/tui.go	/^	JumpCancel$/;"	c	package:tui
JumpLabels	src/options.go	/^	JumpLabels        string$/;"	m	struct:fzf.Options	typeref:typename:string
KEY/EVENT BINDING	man/man1/fzf.1	/^.SS KEY\/EVENT BINDING$/;"	S	section:fzf""OPTIONS
KEY/EVENT BINDINGS	man/man1/fzf.1	/^.SH KEY\/EVENT BINDINGS$/;"	s	title:fzf
KeepRight	src/options.go	/^	KeepRight         bool$/;"	m	struct:fzf.Options	typeref:typename:bool
Key	src/tui/tui.go	/^func Key(r rune) Event {$/;"	f	package:tui	typeref:typename:Event
Key bindings for command-line	README.md	/^Key bindings for command-line$/;"	s
KeyName	src/tui/tui.go	/^func (e Event) KeyName() string {$/;"	f	unknown:tui.Event	typeref:typename:string
Keymap	src/options.go	/^	Keymap            map[tui.Event][]*action$/;"	m	struct:fzf.Options	typeref:typename:map[tui.Event][]*action
KillCommand	src/util/util_unix.go	/^func KillCommand(cmd *exec.Cmd) error {$/;"	f	package:util	typeref:typename:error
KillCommand	src/util/util_windows.go	/^func KillCommand(cmd *exec.Cmd) error {$/;"	f	package:util	typeref:typename:error
LAYOUT	man/man1/fzf.1	/^.SS LAYOUT$/;"	S	section:fzf""OPTIONS
LAYOUT OPTIONS	man/man1/fzf-tmux.1	/^.SH LAYOUT OPTIONS$/;"	s	title:fzf\\-tmux
LF	src/tui/light.go	/^const LF string = DIM + "␊"$/;"	c	package:tui	typeref:typename:string
LICENSE	man/man1/fzf.1	/^.SH LICENSE$/;"	s	title:fzf
LIST SECTION	man/man1/fzf.1	/^.SS LIST SECTION$/;"	S	section:fzf""OPTIONS
Layout	src/options.go	/^	Layout            layoutType$/;"	m	struct:fzf.Options	typeref:typename:layoutType
LeadingWhitespaces	src/util/chars.go	/^func (chars *Chars) LeadingWhitespaces() int {$/;"	f	struct:util.Chars	typeref:typename:int
Left	src/tui/light.go	/^func (w *LightWindow) Left() int {$/;"	f	struct:tui.LightWindow	typeref:typename:int
Left	src/tui/tcell.go	/^func (w *TcellWindow) Left() int {$/;"	f	struct:tui.TcellWindow	typeref:typename:int
Left	src/tui/tui.go	/^	Left   bool$/;"	m	struct:tui.MouseEvent	typeref:typename:bool
Left	src/tui/tui.go	/^	Left$/;"	c	package:tui
Left	src/tui/tui.go	/^	Left() int$/;"	n	interface:tui.Window	typeref:typename:int
LeftClick	src/tui/tui.go	/^	LeftClick$/;"	c	package:tui
Len	src/result.go	/^func (a ByOrder) Len() int {$/;"	f	type:fzf.ByOrder	typeref:typename:int
Len	src/result.go	/^func (a ByRelevance) Len() int {$/;"	f	type:fzf.ByRelevance	typeref:typename:int
Len	src/result.go	/^func (a ByRelevanceTac) Len() int {$/;"	f	type:fzf.ByRelevanceTac	typeref:typename:int
Len	src/terminal.go	/^func (a byTimeOrder) Len() int {$/;"	f	type:fzf.byTimeOrder	typeref:typename:int
Length	src/merger.go	/^func (mg *Merger) Length() int {$/;"	f	struct:fzf.Merger	typeref:typename:int
Length	src/util/chars.go	/^func (chars *Chars) Length() int {$/;"	f	struct:util.Chars	typeref:typename:int
Less	src/result.go	/^func (a ByOrder) Less(i, j int) bool {$/;"	f	type:fzf.ByOrder	typeref:typename:bool
Less	src/result.go	/^func (a ByRelevance) Less(i, j int) bool {$/;"	f	type:fzf.ByRelevance	typeref:typename:bool
Less	src/result.go	/^func (a ByRelevanceTac) Less(i, j int) bool {$/;"	f	type:fzf.ByRelevanceTac	typeref:typename:bool
Less	src/terminal.go	/^func (a byTimeOrder) Less(i, j int) bool {$/;"	f	type:fzf.byTimeOrder	typeref:typename:bool
License	BUILD.md	/^License$/;"	s	chapter:Building fzf
Light256	src/tui/tui.go	/^	Light256  *ColorTheme$/;"	v	package:tui	typeref:typename:*ColorTheme
LightRenderer	src/tui/light.go	/^type LightRenderer struct {$/;"	s	package:tui
LightWindow	src/tui/light.go	/^type LightWindow struct {$/;"	s	package:tui
Lines	src/tui/tui.go	/^	Lines    int$/;"	m	struct:tui.TermSize	typeref:typename:int
Lines	src/util/chars.go	/^func (chars *Chars) Lines(multiLine bool, maxLines int, wrapCols int, wrapSignWidth int, tabstop/;"	f	struct:util.Chars	typeref:typename:([][]rune, bool)
LinkBegin	src/tui/light.go	/^func (w *LightWindow) LinkBegin(uri string, params string) {$/;"	f	struct:tui.LightWindow
LinkBegin	src/tui/tcell.go	/^func (w *TcellWindow) LinkBegin(uri string, params string) {$/;"	f	struct:tui.TcellWindow
LinkBegin	src/tui/tui.go	/^	LinkBegin(uri string, params string)$/;"	n	interface:tui.Window
LinkEnd	src/tui/light.go	/^func (w *LightWindow) LinkEnd() {$/;"	f	struct:tui.LightWindow
LinkEnd	src/tui/tcell.go	/^func (w *TcellWindow) LinkEnd() {$/;"	f	struct:tui.TcellWindow
LinkEnd	src/tui/tui.go	/^	LinkEnd()$/;"	n	interface:tui.Window
Linux packages	README.md	/^### Linux packages$/;"	S	section:Installation
ListBg	src/tui/tui.go	/^	ListBg           ColorAttr$/;"	m	struct:tui.ColorTheme	typeref:typename:ColorAttr
ListBorder	src/tui/tui.go	/^	ListBorder       ColorAttr$/;"	m	struct:tui.ColorTheme	typeref:typename:ColorAttr
ListBorderShape	src/options.go	/^	ListBorderShape   tui.BorderShape$/;"	m	struct:fzf.Options	typeref:typename:tui.BorderShape
ListFg	src/tui/tui.go	/^	ListFg           ColorAttr$/;"	m	struct:tui.ColorTheme	typeref:typename:ColorAttr
ListLabel	src/options.go	/^	ListLabel         labelOpts$/;"	m	struct:fzf.Options	typeref:typename:labelOpts
ListLabel	src/tui/tui.go	/^	ListLabel        ColorAttr$/;"	m	struct:tui.ColorTheme	typeref:typename:ColorAttr
ListenAddr	src/options.go	/^	ListenAddr        *listenAddress$/;"	m	struct:fzf.Options	typeref:typename:*listenAddress
Load	src/tui/tui.go	/^	Load$/;"	c	package:tui
Lookup	src/cache.go	/^func (cc *ChunkCache) Lookup(chunk *Chunk, key string) []Result {$/;"	f	struct:fzf.ChunkCache	typeref:typename:[]Result
Loop	src/matcher.go	/^func (m *Matcher) Loop() {$/;"	f	struct:fzf.Matcher
Loop	src/terminal.go	/^func (t *Terminal) Loop() error {$/;"	f	struct:fzf.Terminal	typeref:typename:error
MAKEFILE	Makefile	/^MAKEFILE       := $(realpath $(lastword $(MAKEFILE_LIST)))$/;"	m
MEMProfile	src/options.go	/^	MEMProfile        string$/;"	m	struct:fzf.Options	typeref:typename:string
MakeBorderStyle	src/tui/tui.go	/^func MakeBorderStyle(shape BorderShape, unicode bool) BorderStyle {$/;"	f	package:tui	typeref:typename:BorderStyle
MakeSlab	src/util/slab.go	/^func MakeSlab(size16 int, size32 int) *Slab {$/;"	f	package:util	typeref:typename:*Slab
Man	src/options.go	/^	Man               bool$/;"	m	struct:fzf.Options	typeref:typename:bool
Margin	src/options.go	/^	Margin            [4]sizeSpec$/;"	m	struct:fzf.Options	typeref:typename:[4]sizeSpec
Marker	src/options.go	/^	Marker            *string$/;"	m	struct:fzf.Options	typeref:typename:*string
Marker	src/tui/tui.go	/^	Marker           ColorAttr$/;"	m	struct:tui.ColorTheme	typeref:typename:ColorAttr
MarkerMulti	src/options.go	/^	MarkerMulti       *[3]string$/;"	m	struct:fzf.Options	typeref:typename:*[3]string
Match	src/pattern.go	/^func (p *Pattern) Match(chunk *Chunk, slab *util.Slab) []Result {$/;"	f	struct:fzf.Pattern	typeref:typename:[]Result
Match	src/tui/tui.go	/^	Match            ColorAttr$/;"	m	struct:tui.ColorTheme	typeref:typename:ColorAttr
MatchCount	src/terminal.go	/^	MatchCount int          `json:"matchCount"`$/;"	m	struct:fzf.Status	typeref:typename:int
MatchItem	src/pattern.go	/^func (p *Pattern) MatchItem(item *Item, withPos bool, slab *util.Slab) (*Result, []Offset, *[]in/;"	f	struct:fzf.Pattern	typeref:typename:(*Result, []Offset, *[]int)
MatchRequest	src/matcher.go	/^type MatchRequest struct {$/;"	s	package:fzf
Matcher	src/matcher.go	/^type Matcher struct {$/;"	s	package:fzf
Matches	src/terminal.go	/^	Matches    []StatusItem `json:"matches"`$/;"	m	struct:fzf.Status	typeref:typename:[]StatusItem
Max	src/util/util.go	/^func Max(first int, second int) int {$/;"	f	package:util	typeref:typename:int
Max16	src/util/util.go	/^func Max16(first int16, second int16) int16 {$/;"	f	package:util	typeref:typename:int16
Max32	src/util/util.go	/^func Max32(first int32, second int32) int32 {$/;"	f	package:util	typeref:typename:int32
MaxFitAndPad	src/terminal.go	/^func (t *Terminal) MaxFitAndPad() (int, int) {$/;"	f	struct:fzf.Terminal	typeref:typename:(int, int)
MaxX	src/tui/dummy.go	/^func (r *FullscreenRenderer) MaxX() int      { return 0 }$/;"	f	unknown:tui.FullscreenRenderer	typeref:typename:int
MaxX	src/tui/light.go	/^func (r *LightRenderer) MaxX() int {$/;"	f	struct:tui.LightRenderer	typeref:typename:int
MaxX	src/tui/tcell.go	/^func (r *FullscreenRenderer) MaxX() int {$/;"	f	unknown:tui.FullscreenRenderer	typeref:typename:int
MaxX	src/tui/tui.go	/^	MaxX() int$/;"	n	interface:tui.Renderer	typeref:typename:int
MaxY	src/tui/dummy.go	/^func (r *FullscreenRenderer) MaxY() int      { return 0 }$/;"	f	unknown:tui.FullscreenRenderer	typeref:typename:int
MaxY	src/tui/light.go	/^func (r *LightRenderer) MaxY() int {$/;"	f	struct:tui.LightRenderer	typeref:typename:int
MaxY	src/tui/tcell.go	/^func (r *FullscreenRenderer) MaxY() int {$/;"	f	unknown:tui.FullscreenRenderer	typeref:typename:int
MaxY	src/tui/tui.go	/^	MaxY() int$/;"	n	interface:tui.Renderer	typeref:typename:int
Merge	src/tui/dummy.go	/^func (a Attr) Merge(b Attr) Attr {$/;"	f	type:tui.Attr	typeref:typename:Attr
Merge	src/tui/tcell.go	/^func (a Attr) Merge(b Attr) Attr {$/;"	f	type:tui.Attr	typeref:typename:Attr
Merge	src/tui/tui.go	/^func (a ColorAttr) Merge(other ColorAttr) ColorAttr {$/;"	f	struct:tui.ColorAttr	typeref:typename:ColorAttr
Merge	src/tui/tui.go	/^func (p ColorPair) Merge(other ColorPair) ColorPair {$/;"	f	struct:tui.ColorPair	typeref:typename:ColorPair
MergeAttr	src/tui/tui.go	/^func (p ColorPair) MergeAttr(other ColorPair) ColorPair {$/;"	f	struct:tui.ColorPair	typeref:typename:ColorPair
MergeNonDefault	src/tui/tui.go	/^func (p ColorPair) MergeNonDefault(other ColorPair) ColorPair {$/;"	f	struct:tui.ColorPair	typeref:typename:ColorPair
Merger	src/merger.go	/^type Merger struct {$/;"	s	package:fzf
Min	src/util/util.go	/^func Min(first int, second int) int {$/;"	f	package:util	typeref:typename:int
Min32	src/util/util.go	/^func Min32(first int32, second int32) int32 {$/;"	f	package:util	typeref:typename:int32
MinHeight	src/options.go	/^	MinHeight         int$/;"	m	struct:fzf.Options	typeref:typename:int
Mod	src/tui/tui.go	/^func (e MouseEvent) Mod() bool {$/;"	f	struct:tui.MouseEvent	typeref:typename:bool
Mouse	src/options.go	/^	Mouse             bool$/;"	m	struct:fzf.Options	typeref:typename:bool
Mouse	src/tui/tui.go	/^	Mouse$/;"	c	package:tui
MouseEvent	src/tui/tui.go	/^	MouseEvent *MouseEvent$/;"	m	struct:tui.Event	typeref:typename:*MouseEvent
MouseEvent	src/tui/tui.go	/^type MouseEvent struct {$/;"	s	package:tui
Move	src/tui/light.go	/^func (w *LightWindow) Move(y int, x int) {$/;"	f	struct:tui.LightWindow
Move	src/tui/tcell.go	/^func (w *TcellWindow) Move(y int, x int) {$/;"	f	struct:tui.TcellWindow
Move	src/tui/tui.go	/^	Move(y int, x int)$/;"	n	interface:tui.Window
MoveAndClear	src/tui/light.go	/^func (w *LightWindow) MoveAndClear(y int, x int) {$/;"	f	struct:tui.LightWindow
MoveAndClear	src/tui/tcell.go	/^func (w *TcellWindow) MoveAndClear(y int, x int) {$/;"	f	struct:tui.TcellWindow
MoveAndClear	src/tui/tui.go	/^	MoveAndClear(y int, x int)$/;"	n	interface:tui.Window
Multi	src/options.go	/^	Multi             int$/;"	m	struct:fzf.Options	typeref:typename:int
Multi	src/tui/tui.go	/^	Multi$/;"	c	package:tui
MultiLine	src/options.go	/^	MultiLine         bool$/;"	m	struct:fzf.Options	typeref:typename:bool
MutexProfile	src/options.go	/^	MutexProfile      string$/;"	m	struct:fzf.Options	typeref:typename:string
NAME	man/man1/fzf-tmux.1	/^.SH NAME$/;"	s	title:fzf\\-tmux
NAME	man/man1/fzf.1	/^.SH NAME$/;"	s	title:fzf
NOTE	man/man1/fzf.1	/^.SS NOTE$/;"	S	section:fzf""OPTIONS
Name	src/terminal.go	/^func (a actionType) Name() string {$/;"	f	type:fzf.actionType	typeref:typename:string
Name	src/tui/tui.go	/^func (e MouseEvent) Name() string {$/;"	f	struct:tui.MouseEvent	typeref:typename:string
NeedScrollbarRedraw	src/tui/dummy.go	/^func (r *FullscreenRenderer) NeedScrollbarRedraw() bool          { return false }$/;"	f	unknown:tui.FullscreenRenderer	typeref:typename:bool
NeedScrollbarRedraw	src/tui/light.go	/^func (r *LightRenderer) NeedScrollbarRedraw() bool {$/;"	f	struct:tui.LightRenderer	typeref:typename:bool
NeedScrollbarRedraw	src/tui/tcell.go	/^func (r *FullscreenRenderer) NeedScrollbarRedraw() bool {$/;"	f	unknown:tui.FullscreenRenderer	typeref:typename:bool
NeedScrollbarRedraw	src/tui/tui.go	/^	NeedScrollbarRedraw() bool$/;"	n	interface:tui.Renderer	typeref:typename:bool
Negation	man/man1/fzf.1	/^.SS Negation$/;"	S	section:fzf""EXTENDED SEARCH MODE
New API: multiple fzf arguments before "--"	CHANGELOG.md	/^  # New API: multiple fzf arguments before "--"$/;"	c
NewAtomicBool	src/util/atomicbool.go	/^func NewAtomicBool(initialState bool) *AtomicBool {$/;"	f	package:util	typeref:typename:*AtomicBool
NewChunkCache	src/cache.go	/^func NewChunkCache() *ChunkCache {$/;"	f	package:fzf	typeref:typename:*ChunkCache
NewChunkList	src/chunklist.go	/^func NewChunkList(cache *ChunkCache, trans ItemBuilder) *ChunkList {$/;"	f	package:fzf	typeref:typename:*ChunkList
NewColorAttr	src/tui/tui.go	/^func NewColorAttr() ColorAttr {$/;"	f	package:tui	typeref:typename:ColorAttr
NewColorPair	src/tui/tui.go	/^func NewColorPair(fg Color, bg Color, attr Attr) ColorPair {$/;"	f	package:tui	typeref:typename:ColorPair
NewConcurrentSet	src/util/concurrent_set.go	/^func NewConcurrentSet[T comparable]() *ConcurrentSet[T] {$/;"	f	package:util	typeref:typename:() *
NewEventBox	src/util/eventbox.go	/^func NewEventBox() *EventBox {$/;"	f	package:util	typeref:typename:*EventBox
NewExecutor	src/util/util_unix.go	/^func NewExecutor(withShell string) *Executor {$/;"	f	package:util	typeref:typename:*Executor
NewExecutor	src/util/util_windows.go	/^func NewExecutor(withShell string) *Executor {$/;"	f	package:util	typeref:typename:*Executor
NewFullscreenRenderer	src/tui/tui.go	/^func NewFullscreenRenderer(theme *ColorTheme, forceBlack bool, mouse bool) Renderer {$/;"	f	package:tui	typeref:typename:Renderer
NewHistory	src/history.go	/^func NewHistory(path string, maxSize int) (*History, error) {$/;"	f	package:fzf	typeref:typename:(*History, error)
NewLightRenderer	src/tui/light.go	/^func NewLightRenderer(ttyDefault string, ttyin *os.File, theme *ColorTheme, forceBlack bool, mou/;"	f	package:tui	typeref:typename:(Renderer, error)
NewMatcher	src/matcher.go	/^func NewMatcher(cache *ChunkCache, patternBuilder func([]rune) *Pattern,$/;"	f	package:fzf	typeref:typename:*Matcher
NewMerger	src/merger.go	/^func NewMerger(pattern *Pattern, lists [][]Result, sorted bool, tac bool, revision revision, min/;"	f	package:fzf	typeref:typename:*Merger
NewReader	src/reader.go	/^func NewReader(pusher func([]byte) bool, eventBox *util.EventBox, executor *util.Executor, delim/;"	f	package:fzf	typeref:typename:*Reader
NewTerminal	src/terminal.go	/^func NewTerminal(opts *Options, eventBox *util.EventBox, executor *util.Executor) (*Terminal, er/;"	f	package:fzf	typeref:typename:(*Terminal, error)
NewWindow	src/tui/dummy.go	/^func (r *FullscreenRenderer) NewWindow(top int, left int, width int, height int, windowType Wind/;"	f	unknown:tui.FullscreenRenderer	typeref:typename:Window
NewWindow	src/tui/light.go	/^func (r *LightRenderer) NewWindow(top int, left int, width int, height int, windowType WindowTyp/;"	f	struct:tui.LightRenderer	typeref:typename:Window
NewWindow	src/tui/tcell.go	/^func (r *FullscreenRenderer) NewWindow(top int, left int, width int, height int, windowType Wind/;"	f	unknown:tui.FullscreenRenderer	typeref:typename:Window
NewWindow	src/tui/tui.go	/^	NewWindow(top int, left int, width int, height int, windowType WindowType, borderStyle BorderSt/;"	n	interface:tui.Renderer	typeref:typename:Window
NoColorPair	src/tui/tui.go	/^func NoColorPair() ColorPair {$/;"	f	package:tui	typeref:typename:ColorPair
NoColorTheme	src/tui/tui.go	/^func NoColorTheme() *ColorTheme {$/;"	f	package:tui	typeref:typename:*ColorTheme
NoWinpty	src/options.go	/^	NoWinpty          bool$/;"	m	struct:fzf.Options	typeref:typename:bool
Normalize	src/options.go	/^	Normalize         bool$/;"	m	struct:fzf.Options	typeref:typename:bool
NormalizeRunes	src/algo/normalize.go	/^func NormalizeRunes(runes []rune) []rune {$/;"	f	package:algo	typeref:typename:[]rune
Notes	SECURITY.md	/^## Notes$/;"	s	chapter:Security Reporting
Nth	src/options.go	/^	Nth               []Range$/;"	m	struct:fzf.Options	typeref:typename:[]Range
Nth	src/tui/tui.go	/^	Nth              ColorAttr$/;"	m	struct:tui.ColorTheme	typeref:typename:ColorAttr
NumLines	src/util/chars.go	/^func (chars *Chars) NumLines(atMost int) (int, bool) {$/;"	f	struct:util.Chars	typeref:typename:(int, bool)
OPTIONS	man/man1/fzf.1	/^.SH OPTIONS$/;"	s	title:fzf
OR operator	man/man1/fzf.1	/^.SS OR operator$/;"	S	section:fzf""EXTENDED SEARCH MODE
OTHERS	man/man1/fzf.1	/^.SS OTHERS$/;"	S	section:fzf""OPTIONS
Offset	src/result.go	/^type Offset [2]int32$/;"	t	package:fzf	typeref:typename:[2]int32
Once	src/util/util.go	/^func Once(nextResponse bool) func() bool {$/;"	f	package:util	typeref:typename:func() bool
One	src/tui/tui.go	/^	One$/;"	c	package:tui
Options	README.md	/^### Options$/;"	S	section:Usage
Options	src/options.go	/^type Options struct {$/;"	s	package:fzf
Output	src/options.go	/^	Output            chan string$/;"	m	struct:fzf.Options	typeref:typename:chan string
PREVIEW BINDING	man/man1/fzf.1	/^.SS PREVIEW BINDING$/;"	S	section:fzf""KEY/EVENT BINDINGS
PREVIEW WINDOW	man/man1/fzf.1	/^.SS PREVIEW WINDOW$/;"	S	section:fzf""OPTIONS
Padding	src/options.go	/^	Padding           [4]sizeSpec$/;"	m	struct:fzf.Options	typeref:typename:[4]sizeSpec
PageDown	src/tui/tui.go	/^	PageDown$/;"	c	package:tui
PageUp	src/tui/tui.go	/^	PageUp$/;"	c	package:tui
ParseOptions	src/options.go	/^func ParseOptions(useDefaults bool, args []string) (*Options, error) {$/;"	f	package:fzf	typeref:typename:(*Options, error)
ParseRange	src/tokenizer.go	/^func ParseRange(str *string) (Range, bool) {$/;"	f	package:fzf	typeref:typename:(Range, bool)
PassMerger	src/merger.go	/^func PassMerger(chunks *[]*Chunk, tac bool, revision revision) *Merger {$/;"	f	package:fzf	typeref:typename:*Merger
PassThrough	src/tui/dummy.go	/^func (r *FullscreenRenderer) PassThrough(string)                 {}$/;"	f	unknown:tui.FullscreenRenderer
PassThrough	src/tui/light.go	/^func (r *LightRenderer) PassThrough(str string) {$/;"	f	unknown:tui.LightRenderer
PassThrough	src/tui/tcell.go	/^func (r *FullscreenRenderer) PassThrough(str string) {$/;"	f	unknown:tui.FullscreenRenderer
PassThrough	src/tui/tui.go	/^	PassThrough(string)$/;"	n	interface:tui.Renderer
Pattern	src/pattern.go	/^type Pattern struct {$/;"	s	package:fzf
Pause	src/tui/dummy.go	/^func (r *FullscreenRenderer) Pause(bool)                         {}$/;"	f	unknown:tui.FullscreenRenderer
Pause	src/tui/light.go	/^func (r *LightRenderer) Pause(clear bool) {$/;"	f	struct:tui.LightRenderer
Pause	src/tui/tcell.go	/^func (r *FullscreenRenderer) Pause(clear bool) {$/;"	f	unknown:tui.FullscreenRenderer
Pause	src/tui/tui.go	/^	Pause(clear bool)$/;"	n	interface:tui.Renderer
Peek	src/util/eventbox.go	/^func (b *EventBox) Peek(event EventType) bool {$/;"	f	struct:util.EventBox	typeref:typename:bool
Performance	README.md	/^### Performance$/;"	S	section:Advanced topics
Phony	src/options.go	/^	Phony             bool$/;"	m	struct:fzf.Options	typeref:typename:bool
Pointer	src/options.go	/^	Pointer           *string$/;"	m	struct:fzf.Options	typeref:typename:*string
Popup window	man/man1/fzf-tmux.1	/^.SS Popup window$/;"	S	section:fzf\\-tmux""LAYOUT OPTIONS
Position	src/terminal.go	/^	Position   int          `json:"position"`$/;"	m	struct:fzf.Status	typeref:typename:int
PrefixMatch	src/algo/algo.go	/^func PrefixMatch(caseSensitive bool, normalize bool, forward bool, text *util.Chars, pattern []r/;"	f	package:algo	typeref:typename:(Result, *[]int)
Prepend	src/util/chars.go	/^func (chars *Chars) Prepend(prefix string) {$/;"	f	struct:util.Chars
Prerequisites	BUILD.md	/^### Prerequisites$/;"	S	section:Building fzf""Build instructions
Press CTRL-A to select 100K items and see the sum of all the numbers	CHANGELOG.md	/^  # Press CTRL-A to select 100K items and see the sum of all the numbers$/;"	c
Preview	src/options.go	/^	Preview           previewOpts$/;"	m	struct:fzf.Options	typeref:typename:previewOpts
Preview window	README.md	/^### Preview window$/;"	S	section:Advanced topics
PreviewBg	src/tui/tui.go	/^	PreviewBg        ColorAttr$/;"	m	struct:tui.ColorTheme	typeref:typename:ColorAttr
PreviewBorder	src/tui/tui.go	/^	PreviewBorder    ColorAttr$/;"	m	struct:tui.ColorTheme	typeref:typename:ColorAttr
PreviewFg	src/tui/tui.go	/^	PreviewFg        ColorAttr$/;"	m	struct:tui.ColorTheme	typeref:typename:ColorAttr
PreviewLabel	src/options.go	/^	PreviewLabel      labelOpts$/;"	m	struct:fzf.Options	typeref:typename:labelOpts
PreviewLabel	src/tui/tui.go	/^	PreviewLabel     ColorAttr$/;"	m	struct:tui.ColorTheme	typeref:typename:ColorAttr
PreviewScrollDown	src/tui/tui.go	/^	PreviewScrollDown$/;"	c	package:tui
PreviewScrollUp	src/tui/tui.go	/^	PreviewScrollUp$/;"	c	package:tui
PreviewScrollbar	src/tui/tui.go	/^	PreviewScrollbar ColorAttr$/;"	m	struct:tui.ColorTheme	typeref:typename:ColorAttr
Previewing an image	README.md	/^### Previewing an image$/;"	S	section:Advanced topics
Previous: fzf arguments given as a single string argument	CHANGELOG.md	/^  # Previous: fzf arguments given as a single string argument$/;"	c
Print	src/tui/light.go	/^func (w *LightWindow) Print(text string) {$/;"	f	struct:tui.LightWindow
Print	src/tui/tcell.go	/^func (w *TcellWindow) Print(text string) {$/;"	f	struct:tui.TcellWindow
Print	src/tui/tui.go	/^	Print(text string)$/;"	n	interface:tui.Window
PrintQuery	src/options.go	/^	PrintQuery        bool$/;"	m	struct:fzf.Options	typeref:typename:bool
PrintSep	src/options.go	/^	PrintSep          string$/;"	m	struct:fzf.Options	typeref:typename:string
Printer	src/options.go	/^	Printer           func(string)$/;"	m	struct:fzf.Options	typeref:typename:func(string)
Process IDs	README.md	/^### Process IDs$/;"	S	section:Fuzzy completion for bash and zsh
Progress	src/terminal.go	/^	Progress   int          `json:"progress"`$/;"	m	struct:fzf.Status	typeref:typename:int
Prompt	src/options.go	/^	Prompt            string$/;"	m	struct:fzf.Options	typeref:typename:string
Prompt	src/tui/tui.go	/^	Prompt           ColorAttr$/;"	m	struct:tui.ColorTheme	typeref:typename:ColorAttr
Protect	src/protector/protector.go	/^func Protect() {}$/;"	f	package:protector
Protect	src/protector/protector_openbsd.go	/^func Protect() {$/;"	f	package:protector
ProxyScript	src/options.go	/^	ProxyScript       string$/;"	m	struct:fzf.Options	typeref:typename:string
Push	src/chunklist.go	/^func (cl *ChunkList) Push(data []byte) bool {$/;"	f	struct:fzf.ChunkList	typeref:typename:bool
PxHeight	src/tui/tui.go	/^	PxHeight int$/;"	m	struct:tui.TermSize	typeref:typename:int
PxWidth	src/tui/tui.go	/^	PxWidth  int$/;"	m	struct:tui.TermSize	typeref:typename:int
Query	src/options.go	/^	Query             string$/;"	m	struct:fzf.Options	typeref:typename:string
Query	src/terminal.go	/^	Query      string       `json:"query"`$/;"	m	struct:fzf.Status	typeref:typename:string
QuoteEntry	src/util/util_unix.go	/^func (x *Executor) QuoteEntry(entry string) string {$/;"	f	struct:util.Executor	typeref:typename:string
QuoteEntry	src/util/util_windows.go	/^func (x *Executor) QuoteEntry(entry string) string {$/;"	f	struct:util.Executor	typeref:typename:string
RELOAD INPUT	man/man1/fzf.1	/^.SS RELOAD INPUT$/;"	S	section:fzf""KEY/EVENT BINDINGS
REVISION	Makefile	/^REVISION       := $(FZF_REVISION)$/;"	m
REVISION	Makefile	/^REVISION       := $(shell git log -n 1 --pretty=format:%h --abbrev=8 -- $(SOURCES) 2> \/dev\/nul/;"	m
ROOT_DIR	Makefile	/^ROOT_DIR       := $(shell dirname $(MAKEFILE))$/;"	m
Range	src/tokenizer.go	/^type Range struct {$/;"	s	package:fzf
RangesToString	src/tokenizer.go	/^func RangesToString(ranges []Range) string {$/;"	f	package:fzf	typeref:typename:string
Read	src/util/util_unix.go	/^func Read(fd int, b []byte) (int, error) {$/;"	f	package:util	typeref:typename:(int, error)
Read	src/util/util_windows.go	/^func Read(fd int, b []byte) (int, error) {$/;"	f	package:util	typeref:typename:(int, error)
ReadSource	src/reader.go	/^func (r *Reader) ReadSource(inputChan chan string, roots []string, opts walkerOpts, ignores []st/;"	f	struct:fzf.Reader
ReadZero	src/options.go	/^	ReadZero          bool$/;"	m	struct:fzf.Options	typeref:typename:bool
Reader	src/reader.go	/^type Reader struct {$/;"	s	package:fzf
Reading	src/terminal.go	/^	Reading    bool         `json:"reading"`$/;"	m	struct:fzf.Status	typeref:typename:bool
Refresh	src/tui/dummy.go	/^func (r *FullscreenRenderer) Refresh()                           {}$/;"	f	unknown:tui.FullscreenRenderer
Refresh	src/tui/light.go	/^func (r *LightRenderer) Refresh() {$/;"	f	struct:tui.LightRenderer
Refresh	src/tui/light.go	/^func (w *LightWindow) Refresh() {$/;"	f	struct:tui.LightWindow
Refresh	src/tui/tcell.go	/^func (r *FullscreenRenderer) Refresh() {$/;"	f	unknown:tui.FullscreenRenderer
Refresh	src/tui/tcell.go	/^func (w *TcellWindow) Refresh() {$/;"	f	struct:tui.TcellWindow
Refresh	src/tui/tui.go	/^	Refresh()$/;"	n	interface:tui.Renderer
Refresh	src/tui/tui.go	/^	Refresh()$/;"	n	interface:tui.Window
RefreshWindows	src/tui/dummy.go	/^func (r *FullscreenRenderer) RefreshWindows(windows []Window) {}$/;"	f	unknown:tui.FullscreenRenderer
RefreshWindows	src/tui/light.go	/^func (r *LightRenderer) RefreshWindows(windows []Window) {$/;"	f	struct:tui.LightRenderer
RefreshWindows	src/tui/tcell.go	/^func (r *FullscreenRenderer) RefreshWindows(windows []Window) {$/;"	f	unknown:tui.FullscreenRenderer
RefreshWindows	src/tui/tui.go	/^	RefreshWindows(windows []Window)$/;"	n	interface:tui.Renderer
Related projects	README.md	/^Related projects$/;"	s
Reloading the candidate list	README.md	/^### Reloading the candidate list$/;"	S	section:Advanced topics
Remove	src/util/concurrent_set.go	/^func (s *ConcurrentSet[T]) Remove(item T) {$/;"	f	unknown:util.T
Renderer	src/tui/tui.go	/^type Renderer interface {$/;"	i	package:tui
RepeatToFill	src/util/util.go	/^func RepeatToFill(str string, length int, limit int) string {$/;"	f	package:util	typeref:typename:string
Reporting	SECURITY.md	/^## Reporting$/;"	s	chapter:Security Reporting
Reset	src/matcher.go	/^func (m *Matcher) Reset(chunks []*Chunk, patternRunes []rune, cancel bool, final bool, sort bool/;"	f	struct:fzf.Matcher
Resize	src/tui/dummy.go	/^func (r *FullscreenRenderer) Resize(maxHeightFunc func(int) int) {}$/;"	f	unknown:tui.FullscreenRenderer
Resize	src/tui/light.go	/^func (r *LightRenderer) Resize(maxHeightFunc func(int) int) {$/;"	f	struct:tui.LightRenderer
Resize	src/tui/tcell.go	/^func (r *FullscreenRenderer) Resize(maxHeightFunc func(int) int) {}$/;"	f	unknown:tui.FullscreenRenderer
Resize	src/tui/tui.go	/^	Resize$/;"	c	package:tui
Resize	src/tui/tui.go	/^	Resize(maxHeightFunc func(int) int)$/;"	n	interface:tui.Renderer
Respecting `.gitignore`	README.md	/^### Respecting `.gitignore`$/;"	S	section:Tips
Result	src/algo/algo.go	/^type Result struct {$/;"	s	package:algo
Result	src/result.go	/^type Result struct {$/;"	s	package:fzf
Result	src/tui/tui.go	/^	Result$/;"	c	package:tui
Resume	src/tui/dummy.go	/^func (r *FullscreenRenderer) Resume(bool, bool)                  {}$/;"	f	unknown:tui.FullscreenRenderer
Resume	src/tui/light.go	/^func (r *LightRenderer) Resume(clear bool, sigcont bool) {$/;"	f	struct:tui.LightRenderer
Resume	src/tui/tcell.go	/^func (r *FullscreenRenderer) Resume(clear bool, sigcont bool) {$/;"	f	unknown:tui.FullscreenRenderer
Resume	src/tui/tui.go	/^	Resume(clear bool, sigcont bool)$/;"	n	interface:tui.Renderer
Reverse	src/tui/dummy.go	/^	Reverse       = Attr(1 << 6)$/;"	c	package:tui
Reverse	src/tui/tcell.go	/^	Reverse            = Attr(tcell.AttrReverse)$/;"	c	package:tui
Revision	src/merger.go	/^func (mg *Merger) Revision() revision {$/;"	f	struct:fzf.Merger	typeref:typename:revision
Right	src/tui/tui.go	/^	Right$/;"	c	package:tui
RightClick	src/tui/tui.go	/^	RightClick$/;"	c	package:tui
Ripgrep integration	ADVANCED.md	/^Ripgrep integration$/;"	s	chapter:Advanced fzf examples
Run	src/core.go	/^func Run(opts *Options) (int, error) {$/;"	f	package:fzf	typeref:typename:(int, error)
RunAtExitFuncs	src/util/atexit.go	/^func RunAtExitFuncs() {$/;"	f	package:util
RunOnce	src/util/util.go	/^func RunOnce(f func()) func() {$/;"	f	package:util	typeref:typename:func()
Rune	src/tui/tui.go	/^	Rune EventType = iota$/;"	c	package:tui	typeref:type:EventType
RunesToChars	src/util/chars.go	/^func RunesToChars(runes []rune) Chars {$/;"	f	package:util	typeref:typename:Chars
RunesWidth	src/util/util.go	/^func RunesWidth(runes []rune, prefixWidth int, tabstop int, limit int) (int, int) {$/;"	f	package:util	typeref:typename:(int, int)
Running tests	BUILD.md	/^Running tests$/;"	s	chapter:Building fzf
S	src/tui/tui.go	/^	S      int$/;"	m	struct:tui.MouseEvent	typeref:typename:int
SCRIPTING	man/man1/fzf.1	/^.SS SCRIPTING$/;"	S	section:fzf""OPTIONS
SEARCH	man/man1/fzf.1	/^.SS SEARCH$/;"	S	section:fzf""OPTIONS
SEE ALSO	man/man1/fzf.1	/^.SH SEE ALSO$/;"	s	title:fzf
SHELL INTEGRATION	man/man1/fzf.1	/^.SS SHELL INTEGRATION$/;"	S	section:fzf""OPTIONS
SLeftClick	src/tui/tui.go	/^	SLeftClick$/;"	c	package:tui
SOURCES	Makefile	/^SOURCES        := $(wildcard *.go src\/*.go src\/*\/*.go shell\/*sh man\/man1\/*.1) $(MAKEFILE)$/;"	m
SRightClick	src/tui/tui.go	/^	SRightClick$/;"	c	package:tui
SScrollDown	src/tui/tui.go	/^	SScrollDown$/;"	c	package:tui
SScrollUp	src/tui/tui.go	/^	SScrollUp$/;"	c	package:tui
SYNOPSIS	man/man1/fzf-tmux.1	/^.SH SYNOPSIS$/;"	s	title:fzf\\-tmux
SYNOPSIS	man/man1/fzf.1	/^.SH SYNOPSIS$/;"	s	title:fzf
Scheme	src/options.go	/^	Scheme            string$/;"	m	struct:fzf.Options	typeref:typename:string
Score	src/algo/algo.go	/^	Score int$/;"	m	struct:algo.Result	typeref:typename:int
ScrollDown	src/tui/tui.go	/^	ScrollDown$/;"	c	package:tui
ScrollOff	src/options.go	/^	ScrollOff         int$/;"	m	struct:fzf.Options	typeref:typename:int
ScrollUp	src/tui/tui.go	/^	ScrollUp$/;"	c	package:tui
Scrollbar	src/options.go	/^	Scrollbar         *string$/;"	m	struct:fzf.Options	typeref:typename:*string
Scrollbar	src/tui/tui.go	/^	Scrollbar        ColorAttr$/;"	m	struct:tui.ColorTheme	typeref:typename:ColorAttr
Search	src/cache.go	/^func (cc *ChunkCache) Search(chunk *Chunk, key string) []Result {$/;"	f	struct:fzf.ChunkCache	typeref:typename:[]Result
Search syntax	README.md	/^### Search syntax$/;"	S	section:Usage
Security Reporting	SECURITY.md	/^# Security Reporting$/;"	c
Select1	src/options.go	/^	Select1           bool$/;"	m	struct:fzf.Options	typeref:typename:bool
Selected	src/terminal.go	/^	Selected   []StatusItem `json:"selected"`$/;"	m	struct:fzf.Status	typeref:typename:[]StatusItem
SelectedBg	src/tui/tui.go	/^	SelectedBg       ColorAttr$/;"	m	struct:tui.ColorTheme	typeref:typename:ColorAttr
SelectedFg	src/tui/tui.go	/^	SelectedFg       ColorAttr$/;"	m	struct:tui.ColorTheme	typeref:typename:ColorAttr
SelectedMatch	src/tui/tui.go	/^	SelectedMatch    ColorAttr$/;"	m	struct:tui.ColorTheme	typeref:typename:ColorAttr
Separator	src/options.go	/^	Separator         *string$/;"	m	struct:fzf.Options	typeref:typename:*string
Separator	src/tui/tui.go	/^	Separator        ColorAttr$/;"	m	struct:tui.ColorTheme	typeref:typename:ColorAttr
Set	src/terminal.go	/^func (s *resumableState) Set(flag bool) {$/;"	f	type:fzf.resumableState
Set	src/util/atomicbool.go	/^func (a *AtomicBool) Set(newState bool) bool {$/;"	f	struct:util.AtomicBool	typeref:typename:bool
Set	src/util/eventbox.go	/^func (b *EventBox) Set(event EventType, value any) {$/;"	f	struct:util.EventBox
SetNonblock	src/util/util_unix.go	/^func SetNonblock(file *os.File, nonblock bool) {$/;"	f	package:util
SetNonblock	src/util/util_windows.go	/^func SetNonblock(file *os.File, nonblock bool) {$/;"	f	package:util
SetStdin	src/util/util_unix.go	/^func SetStdin(file *os.File) {$/;"	f	package:util
SetStdin	src/util/util_windows.go	/^func SetStdin(file *os.File) {$/;"	f	package:util
SetWrapSign	src/tui/light.go	/^func (w *LightWindow) SetWrapSign(sign string, width int) {$/;"	f	struct:tui.LightWindow
SetWrapSign	src/tui/tcell.go	/^func (w *TcellWindow) SetWrapSign(sign string, width int) {$/;"	f	struct:tui.TcellWindow
SetWrapSign	src/tui/tui.go	/^	SetWrapSign(string, int)$/;"	n	interface:tui.Window
Setting up shell integration	README.md	/^### Setting up shell integration$/;"	S	section:Installation
Shell	test/lib/common.rb	/^class Shell$/;"	c
Shift	src/tui/tui.go	/^	Shift  bool$/;"	m	struct:tui.MouseEvent	typeref:typename:bool
ShiftDelete	src/tui/tui.go	/^	ShiftDelete$/;"	c	package:tui
ShiftDown	src/tui/tui.go	/^	ShiftDown$/;"	c	package:tui
ShiftEnd	src/tui/tui.go	/^	ShiftEnd$/;"	c	package:tui
ShiftHome	src/tui/tui.go	/^	ShiftHome$/;"	c	package:tui
ShiftLeft	src/tui/tui.go	/^	ShiftLeft$/;"	c	package:tui
ShiftPageDown	src/tui/tui.go	/^	ShiftPageDown$/;"	c	package:tui
ShiftPageUp	src/tui/tui.go	/^	ShiftPageUp$/;"	c	package:tui
ShiftRight	src/tui/tui.go	/^	ShiftRight$/;"	c	package:tui
ShiftTab	src/tui/tui.go	/^	ShiftTab$/;"	c	package:tui
ShiftUp	src/tui/tui.go	/^	ShiftUp$/;"	c	package:tui
ShouldEmitResizeEvent	src/tui/dummy.go	/^func (r *FullscreenRenderer) ShouldEmitResizeEvent() bool        { return false }$/;"	f	unknown:tui.FullscreenRenderer	typeref:typename:bool
ShouldEmitResizeEvent	src/tui/light.go	/^func (r *LightRenderer) ShouldEmitResizeEvent() bool {$/;"	f	struct:tui.LightRenderer	typeref:typename:bool
ShouldEmitResizeEvent	src/tui/tcell.go	/^func (r *FullscreenRenderer) ShouldEmitResizeEvent() bool {$/;"	f	unknown:tui.FullscreenRenderer	typeref:typename:bool
ShouldEmitResizeEvent	src/tui/tui.go	/^	ShouldEmitResizeEvent() bool$/;"	n	interface:tui.Renderer	typeref:typename:bool
ShowCursor	src/tui/dummy.go	/^func (r *FullscreenRenderer) ShowCursor()                        {}$/;"	f	unknown:tui.FullscreenRenderer
ShowCursor	src/tui/light.go	/^func (r *LightRenderer) ShowCursor() {$/;"	f	struct:tui.LightRenderer
ShowCursor	src/tui/tcell.go	/^func (r *FullscreenRenderer) ShowCursor() {$/;"	f	unknown:tui.FullscreenRenderer
ShowCursor	src/tui/tui.go	/^	ShowCursor()$/;"	n	interface:tui.Renderer
Size	src/tui/dummy.go	/^func (r *FullscreenRenderer) Size() TermSize                     { return TermSize{} }$/;"	f	unknown:tui.FullscreenRenderer	typeref:typename:TermSize
Size	src/tui/light_unix.go	/^func (r *LightRenderer) Size() TermSize {$/;"	f	unknown:tui.LightRenderer	typeref:typename:TermSize
Size	src/tui/light_windows.go	/^func (r *LightRenderer) Size() TermSize {$/;"	f	unknown:tui.LightRenderer	typeref:typename:TermSize
Size	src/tui/tcell.go	/^func (r *FullscreenRenderer) Size() TermSize {$/;"	f	unknown:tui.FullscreenRenderer	typeref:typename:TermSize
Size	src/tui/tui.go	/^	Size() TermSize$/;"	n	interface:tui.Renderer	typeref:typename:TermSize
Slab	src/util/slab.go	/^type Slab struct {$/;"	s	package:util
SliceRight	src/util/chars.go	/^func (chars *Chars) SliceRight(last int) {$/;"	f	struct:util.Chars
Snapshot	src/chunklist.go	/^func (cl *ChunkList) Snapshot(tail int) ([]*Chunk, int, bool) {$/;"	f	struct:fzf.ChunkList	typeref:typename:([]*Chunk, int, bool)
Sort	src/options.go	/^	Sort              int$/;"	m	struct:fzf.Options	typeref:typename:int
Sort	src/terminal.go	/^	Sort       bool         `json:"sort"`$/;"	m	struct:fzf.Status	typeref:typename:bool
Spinner	src/tui/tui.go	/^	Spinner          ColorAttr$/;"	m	struct:tui.ColorTheme	typeref:typename:ColorAttr
Split pane	man/man1/fzf-tmux.1	/^.SS Split pane$/;"	S	section:fzf\\-tmux""LAYOUT OPTIONS
Sponsors :heart:	README.md	/^Sponsors :heart:$/;"	s
Start	src/algo/algo.go	/^	Start int$/;"	m	struct:algo.Result	typeref:typename:int
Start	src/tui/tui.go	/^	Start$/;"	c	package:tui
Starting fzf in a popup window	README-VIM.md	/^### Starting fzf in a popup window$/;"	S	section:FZF Vim integration""Tips
Status	src/terminal.go	/^type Status struct {$/;"	s	package:fzf
StatusItem	src/terminal.go	/^type StatusItem struct {$/;"	s	package:fzf
Stop	src/matcher.go	/^func (m *Matcher) Stop() {$/;"	f	struct:fzf.Matcher
StrikeThrough	src/tui/dummy.go	/^	StrikeThrough = Attr(1 << 7)$/;"	c	package:tui
StrikeThrough	src/tui/tcell.go	/^	StrikeThrough      = Attr(tcell.AttrStrikeThrough)$/;"	c	package:tui
String	src/actiontype_string.go	/^func (i actionType) String() string {$/;"	f	unknown:fzf.actionType	typeref:typename:string
String	src/options.go	/^func (s sizeSpec) String() string {$/;"	f	struct:fzf.sizeSpec	typeref:typename:string
String	src/pattern.go	/^func (t term) String() string {$/;"	f	struct:fzf.term	typeref:typename:string
String	src/terminal_test.go	/^func (item *Item) String() string {$/;"	f	unknown:fzf.Item	typeref:typename:string
String	src/tokenizer.go	/^func (d Delimiter) String() string {$/;"	f	struct:fzf.Delimiter	typeref:typename:string
String	src/tokenizer.go	/^func (t Token) String() string {$/;"	f	struct:fzf.Token	typeref:typename:string
String	src/tui/eventtype_string.go	/^func (i EventType) String() string {$/;"	f	unknown:tui.EventType	typeref:typename:string
String	src/util/chars.go	/^func (chars *Chars) String() string {$/;"	f	struct:util.Chars	typeref:typename:string
StringWidth	src/util/util.go	/^func StringWidth(s string) int {$/;"	f	package:util	typeref:typename:int
StripLastDelimiter	src/tokenizer.go	/^func StripLastDelimiter(str string, delimiter Delimiter) string {$/;"	f	package:fzf	typeref:typename:string
Style	src/tui/tcell.go	/^func (c Color) Style() tcell.Color {$/;"	f	unknown:tui.Color	typeref:typename:tcell.Color
SuffixMatch	src/algo/algo.go	/^func SuffixMatch(caseSensitive bool, normalize bool, forward bool, text *util.Chars, pattern []r/;"	f	package:algo	typeref:typename:(Result, *[]int)
Summary	README-VIM.md	/^Summary$/;"	s	chapter:FZF Vim integration
Supported commands	README.md	/^### Supported commands$/;"	S	section:Fuzzy completion for bash and zsh
Swap	src/result.go	/^func (a ByOrder) Swap(i, j int) {$/;"	f	type:fzf.ByOrder
Swap	src/result.go	/^func (a ByRelevance) Swap(i, j int) {$/;"	f	type:fzf.ByRelevance
Swap	src/result.go	/^func (a ByRelevanceTac) Swap(i, j int) {$/;"	f	type:fzf.ByRelevanceTac
Swap	src/terminal.go	/^func (a byTimeOrder) Swap(i, j int) {$/;"	f	type:fzf.byTimeOrder
Switch between Ripgrep launcher mode (CTRL-R) and fzf filtering mode (CTRL-F)	ADVANCED.md	/^# Switch between Ripgrep launcher mode (CTRL-R) and fzf filtering mode (CTRL-F)$/;"	c
Switch between Ripgrep mode and fzf filtering mode (CTRL-T)	ADVANCED.md	/^# Switch between Ripgrep mode and fzf filtering mode (CTRL-T)$/;"	c
Sync	src/options.go	/^	Sync              bool$/;"	m	struct:fzf.Options	typeref:typename:bool
TEMPLATE	test/lib/common.rb	/^TEMPLATE = File.read(File.expand_path('common.sh', __dir__))$/;"	C
TEMPNAME	test/lib/common.rb	/^  TEMPNAME = Dir::Tmpname.create(%w[fzf]) {}$/;"	C	class:TestBase
TRANSFORM ACTIONS	man/man1/fzf.1	/^.SS TRANSFORM ACTIONS$/;"	S	section:fzf""KEY/EVENT BINDINGS
TRANSFORM IN THE BACKGROUND	man/man1/fzf.1	/^.SS TRANSFORM IN THE BACKGROUND$/;"	S	section:fzf""KEY/EVENT BINDINGS
Tab	src/tui/tui.go	/^	Tab$/;"	c	package:tui
Table of Contents	README.md	/^Table of Contents$/;"	s
Tabstop	src/options.go	/^	Tabstop           int$/;"	m	struct:fzf.Options	typeref:typename:int
Tac	src/options.go	/^	Tac               bool$/;"	m	struct:fzf.Options	typeref:typename:bool
Tail	src/options.go	/^	Tail              int$/;"	m	struct:fzf.Options	typeref:typename:int
TcellWindow	src/tui/tcell.go	/^type TcellWindow struct {$/;"	s	package:tui
TermSize	src/tui/tui.go	/^type TermSize struct {$/;"	s	package:tui
Terminal	src/terminal.go	/^type Terminal struct {$/;"	s	package:fzf
TestAdditiveExpect	src/options_test.go	/^func TestAdditiveExpect(t *testing.T) {$/;"	f	package:fzf
TestAnsiCodeStringConversion	src/ansi_test.go	/^func TestAnsiCodeStringConversion(t *testing.T) {$/;"	f	package:fzf
TestAsUint16	src/util/util_test.go	/^func TestAsUint16(t *testing.T) {$/;"	f	package:util
TestAtExit	src/util/atexit_test.go	/^func TestAtExit(t *testing.T) {$/;"	f	package:util
TestAtomicBool	src/util/atomicbool_test.go	/^func TestAtomicBool(t *testing.T) {$/;"	f	package:util
TestBase	test/lib/common.rb	/^class TestBase < Minitest::Test$/;"	c
TestBash	test/test_shell_integration.rb	/^class TestBash < TestBase$/;"	c	module:TestShell.CompletionTest	mixin:include:TestShell,include:CompletionTest
TestBind	src/options_test.go	/^func TestBind(t *testing.T) {$/;"	f	package:fzf
TestCacheKey	src/pattern_test.go	/^func TestCacheKey(t *testing.T) {$/;"	f	package:fzf
TestCacheable	src/pattern_test.go	/^func TestCacheable(t *testing.T) {$/;"	f	package:fzf
TestCaseSensitivity	src/pattern_test.go	/^func TestCaseSensitivity(t *testing.T) {$/;"	f	package:fzf
TestCharsLength	src/util/chars_test.go	/^func TestCharsLength(t *testing.T) {$/;"	f	package:util
TestCharsLines	src/util/chars_test.go	/^func TestCharsLines(t *testing.T) {$/;"	f	package:util
TestCharsToString	src/util/chars_test.go	/^func TestCharsToString(t *testing.T) {$/;"	f	package:util
TestChunkCache	src/cache_test.go	/^func TestChunkCache(t *testing.T) {$/;"	f	package:fzf
TestChunkList	src/chunklist_test.go	/^func TestChunkList(t *testing.T) {$/;"	f	package:fzf
TestChunkListTail	src/chunklist_test.go	/^func TestChunkListTail(t *testing.T) {$/;"	f	package:fzf
TestChunkTiebreak	src/result_test.go	/^func TestChunkTiebreak(t *testing.T) {$/;"	f	package:fzf
TestColorOffset	src/result_test.go	/^func TestColorOffset(t *testing.T) {$/;"	f	package:fzf
TestColorSpec	src/options_test.go	/^func TestColorSpec(t *testing.T) {$/;"	f	package:fzf
TestCompareVersions	src/util/util_test.go	/^func TestCompareVersions(t *testing.T) {$/;"	f	package:util
TestConstrain	src/util/util_test.go	/^func TestConstrain(t *testing.T) {$/;"	f	package:util
TestConstrain32	src/util/util_test.go	/^func TestConstrain32(t *testing.T) {$/;"	f	package:util
TestCore	test/test_core.rb	/^class TestCore < TestInteractive$/;"	c
TestDefaultCtrlNP	src/options_test.go	/^func TestDefaultCtrlNP(t *testing.T) {$/;"	f	package:fzf
TestDelimiterRegex	src/options_test.go	/^func TestDelimiterRegex(t *testing.T) {$/;"	f	package:fzf
TestDelimiterRegexRegex	src/options_test.go	/^func TestDelimiterRegexRegex(t *testing.T) {$/;"	f	package:fzf
TestDelimiterRegexRegexCaret	src/options_test.go	/^func TestDelimiterRegexRegexCaret(t *testing.T) {$/;"	f	package:fzf
TestDelimiterRegexString	src/options_test.go	/^func TestDelimiterRegexString(t *testing.T) {$/;"	f	package:fzf
TestDurWithIn	src/util/util_test.go	/^func TestDurWithIn(t *testing.T) {$/;"	f	package:util
TestEmptyMerger	src/merger_test.go	/^func TestEmptyMerger(t *testing.T) {$/;"	f	package:fzf
TestEmptyPattern	src/algo/algo_test.go	/^func TestEmptyPattern(t *testing.T) {$/;"	f	package:algo
TestEqual	src/pattern_test.go	/^func TestEqual(t *testing.T) {$/;"	f	package:fzf
TestEventBox	src/util/eventbox_test.go	/^func TestEventBox(t *testing.T) {$/;"	f	package:util
TestExact	src/pattern_test.go	/^func TestExact(t *testing.T) {$/;"	f	package:fzf
TestExactMatchNaive	src/algo/algo_test.go	/^func TestExactMatchNaive(t *testing.T) {$/;"	f	package:algo
TestExactMatchNaiveBackward	src/algo/algo_test.go	/^func TestExactMatchNaiveBackward(t *testing.T) {$/;"	f	package:algo
TestExec	test/test_exec.rb	/^class TestExec < TestInteractive$/;"	c
TestExtractColor	src/ansi_test.go	/^func TestExtractColor(t *testing.T) {$/;"	f	package:fzf
TestExtractPassthroughs	src/terminal_test.go	/^func TestExtractPassthroughs(t *testing.T) {$/;"	f	package:fzf
TestFilter	test/test_filter.rb	/^class TestFilter < TestBase$/;"	c
TestFish	test/test_shell_integration.rb	/^class TestFish < TestBase$/;"	c	module:TestShell.CompletionTest	mixin:include:TestShell
TestFuzzyMatch	src/algo/algo_test.go	/^func TestFuzzyMatch(t *testing.T) {$/;"	f	package:algo
TestFuzzyMatchBackward	src/algo/algo_test.go	/^func TestFuzzyMatchBackward(t *testing.T) {$/;"	f	package:algo
TestGetCharEventKey	src/tui/tcell_test.go	/^func TestGetCharEventKey(t *testing.T) {$/;"	f	package:tui
TestHexToColor	src/tui/tui_test.go	/^func TestHexToColor(t *testing.T) {$/;"	f	package:tui
TestHistory	src/history_test.go	/^func TestHistory(t *testing.T) {$/;"	f	package:fzf
TestInitProfiling	src/options_pprof_test.go	/^func TestInitProfiling(t *testing.T) {$/;"	f	package:fzf
TestInteractive	test/lib/common.rb	/^class TestInteractive < TestBase$/;"	c
TestIrrelevantNth	src/options_test.go	/^func TestIrrelevantNth(t *testing.T) {$/;"	f	package:fzf
TestLayout	test/test_layout.rb	/^class TestLayout < TestInteractive$/;"	c
TestLightRenderer	src/tui/light_test.go	/^func TestLightRenderer(t *testing.T) {$/;"	f	package:tui
TestLongString	src/algo/algo_test.go	/^func TestLongString(t *testing.T) {$/;"	f	package:algo
TestLongStringWithNormalize	src/algo/algo_test.go	/^func TestLongStringWithNormalize(t *testing.T) {$/;"	f	package:algo
TestMaskActionContents	src/options_test.go	/^func TestMaskActionContents(t *testing.T) {$/;"	f	package:fzf
TestMax	src/util/util_test.go	/^func TestMax(t *testing.T) {$/;"	f	package:util
TestMax16	src/util/util_test.go	/^func TestMax16(t *testing.T) {$/;"	f	package:util
TestMax32	src/util/util_test.go	/^func TestMax32(t *testing.T) {$/;"	f	package:util
TestMergerSorted	src/merger_test.go	/^func TestMergerSorted(t *testing.T) {$/;"	f	package:fzf
TestMergerUnsorted	src/merger_test.go	/^func TestMergerUnsorted(t *testing.T) {$/;"	f	package:fzf
TestMin	src/util/util_test.go	/^func TestMin(t *testing.T) {$/;"	f	package:util
TestMin32	src/util/util_test.go	/^func TestMin32(t *testing.T) {$/;"	f	package:util
TestNextAnsiEscapeSequence	src/ansi_test.go	/^func TestNextAnsiEscapeSequence(t *testing.T) {$/;"	f	package:fzf
TestNextAnsiEscapeSequence_Fuzz_Modified	src/ansi_test.go	/^func TestNextAnsiEscapeSequence_Fuzz_Modified(t *testing.T) {$/;"	f	package:fzf
TestNextAnsiEscapeSequence_Fuzz_Random	src/ansi_test.go	/^func TestNextAnsiEscapeSequence_Fuzz_Random(t *testing.T) {$/;"	f	package:fzf
TestNormalize	src/algo/algo_test.go	/^func TestNormalize(t *testing.T) {$/;"	f	package:algo
TestOffsetSort	src/result_test.go	/^func TestOffsetSort(t *testing.T) {$/;"	f	package:fzf
TestOnce	src/util/util_test.go	/^func TestOnce(t *testing.T) {$/;"	f	package:util
TestOrigTextAndTransformed	src/pattern_test.go	/^func TestOrigTextAndTransformed(t *testing.T) {$/;"	f	package:fzf
TestParseAnsiCode	src/ansi_test.go	/^func TestParseAnsiCode(t *testing.T) {$/;"	f	package:fzf
TestParseKeys	src/options_test.go	/^func TestParseKeys(t *testing.T) {$/;"	f	package:fzf
TestParseKeysWithComma	src/options_test.go	/^func TestParseKeysWithComma(t *testing.T) {$/;"	f	package:fzf
TestParsePlaceholder	src/terminal_test.go	/^func TestParsePlaceholder(t *testing.T) {$/;"	f	package:fzf
TestParseRange	src/tokenizer_test.go	/^func TestParseRange(t *testing.T) {$/;"	f	package:fzf
TestParseSingleActionList	src/options_test.go	/^func TestParseSingleActionList(t *testing.T) {$/;"	f	package:fzf
TestParseSingleActionListError	src/options_test.go	/^func TestParseSingleActionListError(t *testing.T) {$/;"	f	package:fzf
TestParseTermsEmpty	src/pattern_test.go	/^func TestParseTermsEmpty(t *testing.T) {$/;"	f	package:fzf
TestParseTermsExtended	src/pattern_test.go	/^func TestParseTermsExtended(t *testing.T) {$/;"	f	package:fzf
TestParseTermsExtendedExact	src/pattern_test.go	/^func TestParseTermsExtendedExact(t *testing.T) {$/;"	f	package:fzf
TestPowershellCommands	src/terminal_test.go	/^func TestPowershellCommands(t *testing.T) {$/;"	f	package:fzf
TestPrefixMatch	src/algo/algo_test.go	/^func TestPrefixMatch(t *testing.T) {$/;"	f	package:algo
TestPreview	test/test_preview.rb	/^class TestPreview < TestInteractive$/;"	c
TestPreviewOpts	src/options_test.go	/^func TestPreviewOpts(t *testing.T) {$/;"	f	package:fzf
TestQuoteEntry	src/terminal_test.go	/^func TestQuoteEntry(t *testing.T) {$/;"	f	package:fzf
TestRankComparison	src/result_test.go	/^func TestRankComparison(t *testing.T) {$/;"	f	package:fzf
TestReadFromCommand	src/reader_test.go	/^func TestReadFromCommand(t *testing.T) {$/;"	f	package:fzf
TestRepeatToFill	src/util/util_test.go	/^func TestRepeatToFill(t *testing.T) {$/;"	f	package:util
TestReplacePlaceholder	src/terminal_test.go	/^func TestReplacePlaceholder(t *testing.T) {$/;"	f	package:fzf
TestResultRank	src/result_test.go	/^func TestResultRank(t *testing.T) {$/;"	f	package:fzf
TestRunesWidth	src/util/util_test.go	/^func TestRunesWidth(t *testing.T) {$/;"	f	package:util
TestServer	test/test_server.rb	/^class TestServer < TestInteractive$/;"	c
TestShell	test/test_shell_integration.rb	/^module TestShell$/;"	m
TestSplitNth	src/options_test.go	/^func TestSplitNth(t *testing.T) {$/;"	f	package:fzf
TestStringPtr	src/item_test.go	/^func TestStringPtr(t *testing.T) {$/;"	f	package:fzf
TestStringWidth	src/util/util_test.go	/^func TestStringWidth(t *testing.T) {$/;"	f	package:util
TestSuffixMatch	src/algo/algo_test.go	/^func TestSuffixMatch(t *testing.T) {$/;"	f	package:algo
TestToCharsAscii	src/util/chars_test.go	/^func TestToCharsAscii(t *testing.T) {$/;"	f	package:util
TestToggle	src/options_test.go	/^func TestToggle(t *testing.T) {$/;"	f	package:fzf
TestTokenize	src/tokenizer_test.go	/^func TestTokenize(t *testing.T) {$/;"	f	package:fzf
TestTransform	src/tokenizer_test.go	/^func TestTransform(t *testing.T) {$/;"	f	package:fzf
TestTransformIndexOutOfBounds	src/tokenizer_test.go	/^func TestTransformIndexOutOfBounds(t *testing.T) {$/;"	f	package:fzf
TestTrimLength	src/util/chars_test.go	/^func TestTrimLength(t *testing.T) {$/;"	f	package:util
TestTruncate	src/util/util_test.go	/^func TestTruncate(t *testing.T) {$/;"	f	package:util
TestUnixCommands	src/terminal_test.go	/^func TestUnixCommands(t *testing.T) {$/;"	f	package:fzf
TestValidateSign	src/options_test.go	/^func TestValidateSign(t *testing.T) {$/;"	f	package:fzf
TestWindowsCommands	src/terminal_test.go	/^func TestWindowsCommands(t *testing.T) {$/;"	f	package:fzf
TestZsh	test/test_shell_integration.rb	/^class TestZsh < TestBase$/;"	c	module:TestShell.CompletionTest	mixin:include:TestShell,include:CompletionTest
Text	src/terminal.go	/^	Text  string `json:"text"`$/;"	m	struct:fzf.StatusItem	typeref:typename:string
Theme	src/options.go	/^	Theme             *tui.ColorTheme$/;"	m	struct:fzf.Options	typeref:typename:*tui.ColorTheme
Third-party libraries used	BUILD.md	/^Third-party libraries used$/;"	s	chapter:Building fzf
This is useful when you need to write special execute/reload form (i.e. `execute:...`)	CHANGELOG.md	/^  # This is useful when you need to write special execute\/reload form (i.e. `execute:...`)$/;"	c
Tips	README-VIM.md	/^Tips$/;"	s	chapter:FZF Vim integration
Tips	README.md	/^Tips$/;"	s
Tmux	src/options.go	/^	Tmux              *tmuxOptions$/;"	m	struct:fzf.Options	typeref:typename:*tmuxOptions
Tmux	test/lib/common.rb	/^class Tmux$/;"	c
ToChars	src/util/chars.go	/^func ToChars(bytes []byte) Chars {$/;"	f	package:util	typeref:typename:Chars
ToKebabCase	src/util/util.go	/^func ToKebabCase(s string) string {$/;"	f	package:util	typeref:typename:string
ToRunes	src/util/chars.go	/^func (chars *Chars) ToRunes() []rune {$/;"	f	struct:util.Chars	typeref:typename:[]rune
ToString	src/ansi.go	/^func (s *ansiState) ToString() string {$/;"	f	struct:fzf.ansiState	typeref:typename:string
ToString	src/util/chars.go	/^func (chars *Chars) ToString() string {$/;"	f	struct:util.Chars	typeref:typename:string
Toggle	src/options.go	/^func (o *previewOpts) Toggle() {$/;"	f	struct:fzf.previewOpts
ToggleSort	src/options.go	/^	ToggleSort        bool$/;"	m	struct:fzf.Options	typeref:typename:bool
Toggling between data sources	ADVANCED.md	/^### Toggling between data sources$/;"	S	section:Advanced fzf examples""Dynamic reloading of the list
Toggling with a single key binding	ADVANCED.md	/^### Toggling with a single key binding$/;"	S	section:Advanced fzf examples""Dynamic reloading of the list
Token	src/tokenizer.go	/^type Token struct {$/;"	s	package:fzf
Tokenize	src/tokenizer.go	/^func Tokenize(text string, delimiter Delimiter) []Token {$/;"	f	package:fzf	typeref:typename:[]Token
Top	src/tui/dummy.go	/^func (r *FullscreenRenderer) Top() int       { return 0 }$/;"	f	unknown:tui.FullscreenRenderer	typeref:typename:int
Top	src/tui/light.go	/^func (r *LightRenderer) Top() int {$/;"	f	struct:tui.LightRenderer	typeref:typename:int
Top	src/tui/light.go	/^func (w *LightWindow) Top() int {$/;"	f	struct:tui.LightWindow	typeref:typename:int
Top	src/tui/tcell.go	/^func (r *FullscreenRenderer) Top() int {$/;"	f	unknown:tui.FullscreenRenderer	typeref:typename:int
Top	src/tui/tcell.go	/^func (w *TcellWindow) Top() int {$/;"	f	struct:tui.TcellWindow	typeref:typename:int
Top	src/tui/tui.go	/^	Top() int$/;"	n	interface:tui.Renderer	typeref:typename:int
Top	src/tui/tui.go	/^	Top() int$/;"	n	interface:tui.Window	typeref:typename:int
TotalCount	src/terminal.go	/^	TotalCount int          `json:"totalCount"`$/;"	m	struct:fzf.Status	typeref:typename:int
Track	src/options.go	/^	Track             trackOption$/;"	m	struct:fzf.Options	typeref:typename:trackOption
TrailingWhitespaces	src/util/chars.go	/^func (chars *Chars) TrailingWhitespaces() int {$/;"	f	struct:util.Chars	typeref:typename:int
Transform	src/tokenizer.go	/^func Transform(tokens []Token, withNth []Range) []Token {$/;"	f	package:fzf	typeref:typename:[]Token
TrimLength	src/item.go	/^func (item *Item) TrimLength() uint16 {$/;"	f	struct:fzf.Item	typeref:typename:uint16
TrimLength	src/util/chars.go	/^func (chars *Chars) TrimLength() uint16 {$/;"	f	struct:util.Chars	typeref:typename:uint16
TrimSuffix	src/util/chars.go	/^func (chars *Chars) TrimSuffix(runes []rune) {$/;"	f	struct:util.Chars
TrimTrailingWhitespaces	src/util/chars.go	/^func (chars *Chars) TrimTrailingWhitespaces(maxIndex int) {$/;"	f	struct:util.Chars
Truncate	src/util/util.go	/^func Truncate(input string, limit int) ([]rune, int) {$/;"	f	package:util	typeref:typename:([]rune, int)
TtyDefault	src/options.go	/^	TtyDefault        string$/;"	m	struct:fzf.Options	typeref:typename:string
TtyIn	src/tui/ttyname_unix.go	/^func TtyIn(ttyDefault string) (*os.File, error) {$/;"	f	package:tui	typeref:typename:(*os.File, error)
TtyIn	src/tui/ttyname_windows.go	/^func TtyIn(ttyDefault string) (*os.File, error) {$/;"	f	package:tui	typeref:typename:(*os.File, error)
TtyOut	src/tui/ttyname_unix.go	/^func TtyOut(ttyDefault string) (*os.File, error) {$/;"	f	package:tui	typeref:typename:(*os.File, error)
TtyOut	src/tui/ttyname_windows.go	/^func TtyOut(ttyDefault string) (*os.File, error) {$/;"	f	package:tui	typeref:typename:(*os.File, error)
Turning into a different process	README.md	/^### Turning into a different process$/;"	S	section:Advanced topics
Two-phase filtering with Ripgrep and fzf	ADVANCED.md	/^# Two-phase filtering with Ripgrep and fzf$/;"	c
Type	src/tui/tui.go	/^	Type       EventType$/;"	m	struct:tui.Event	typeref:typename:EventType
UNAME_M	Makefile	/^UNAME_M := $(shell uname -m)$/;"	m
UNSETS	test/lib/common.rb	/^UNSETS = %w[$/;"	C
Underline	src/tui/dummy.go	/^	Underline     = Attr(1 << 3)$/;"	c	package:tui
Underline	src/tui/tcell.go	/^	Underline          = Attr(tcell.AttrUnderline)$/;"	c	package:tui
Unicode	src/options.go	/^	Unicode           bool$/;"	m	struct:fzf.Options	typeref:typename:bool
Unsafe	src/options.go	/^	Unsafe            bool$/;"	m	struct:fzf.Options	typeref:typename:bool
Unwatch	src/util/eventbox.go	/^func (b *EventBox) Unwatch(events ...EventType) {$/;"	f	struct:util.EventBox
Up	src/tui/tui.go	/^	Up$/;"	c	package:tui
UpdateCount	src/terminal.go	/^func (t *Terminal) UpdateCount(cnt int, final bool, failedCommand *string) {$/;"	f	struct:fzf.Terminal
UpdateHeader	src/terminal.go	/^func (t *Terminal) UpdateHeader(header []string) {$/;"	f	struct:fzf.Terminal
UpdateList	src/terminal.go	/^func (t *Terminal) UpdateList(merger *Merger) {$/;"	f	struct:fzf.Terminal
UpdateProgress	src/terminal.go	/^func (t *Terminal) UpdateProgress(progress float32) {$/;"	f	struct:fzf.Terminal
Updating the list of processes by pressing CTRL-R	ADVANCED.md	/^### Updating the list of processes by pressing CTRL-R$/;"	S	section:Advanced fzf examples""Dynamic reloading of the list
Upgrading fzf	README.md	/^Upgrading fzf$/;"	s
Usage	README.md	/^Usage$/;"	s
Usage	src/options.go	/^const Usage = `fzf is an interactive filter program for any kind of list.$/;"	c	package:fzf
Using Homebrew	README.md	/^### Using Homebrew$/;"	S	section:Installation
Using Makefile	BUILD.md	/^### Using Makefile$/;"	S	section:Building fzf""Build instructions
Using fzf as the secondary filter	ADVANCED.md	/^### Using fzf as the secondary filter$/;"	S	section:Advanced fzf examples""Ripgrep integration
Using fzf as the selector interface for ripgrep	CHANGELOG.md	/^  # Using fzf as the selector interface for ripgrep$/;"	c
Using git	README.md	/^### Using git$/;"	S	section:Installation
Using the finder	README.md	/^### Using the finder$/;"	S	section:Usage
VERSION	Makefile	/^VERSION        := $(FZF_VERSION)$/;"	m
VERSION	Makefile	/^VERSION        := $(shell git describe --abbrev=0 2> \/dev\/null | sed "s\/^v\/\/")$/;"	m
VERSION_REGEX	Makefile	/^VERSION_REGEX  := $(subst .,\\.,$(VERSION_TRIM))$/;"	m
VERSION_TRIM	Makefile	/^VERSION_TRIM   := $(shell echo $(VERSION) | sed "s\/^v\/\/; s\/-.*\/\/")$/;"	m
Version	src/options.go	/^	Version           bool$/;"	m	struct:fzf.Options	typeref:typename:bool
Vim plugin	README.md	/^Vim plugin$/;"	s
Vim/Neovim plugin	README.md	/^### Vim\/Neovim plugin$/;"	S	section:Installation
Visible	src/options.go	/^func (o *previewOpts) Visible() bool {$/;"	f	struct:fzf.previewOpts	typeref:typename:bool
Visible	src/tui/tui.go	/^func (s BorderShape) Visible() bool {$/;"	f	type:tui.BorderShape	typeref:typename:bool
Wait	src/util/eventbox.go	/^func (b *EventBox) Wait(callback func(*Events)) {$/;"	f	struct:util.EventBox
WaitFor	src/util/eventbox.go	/^func (b *EventBox) WaitFor(event EventType) {$/;"	f	struct:util.EventBox
WalkerOpts	src/options.go	/^	WalkerOpts        walkerOpts$/;"	m	struct:fzf.Options	typeref:typename:walkerOpts
WalkerRoot	src/options.go	/^	WalkerRoot        []string$/;"	m	struct:fzf.Options	typeref:typename:[]string
WalkerSkip	src/options.go	/^	WalkerSkip        []string$/;"	m	struct:fzf.Options	typeref:typename:[]string
Watch	src/util/eventbox.go	/^func (b *EventBox) Watch(events ...EventType) {$/;"	f	struct:util.EventBox
When fzf reads this code it clears the previous preview contents.	ADVANCED.md	/^# When fzf reads this code it clears the previous preview contents.$/;"	c
Width	src/tui/light.go	/^func (w *LightWindow) Width() int {$/;"	f	struct:tui.LightWindow	typeref:typename:int
Width	src/tui/tcell.go	/^func (w *TcellWindow) Width() int {$/;"	f	struct:tui.TcellWindow	typeref:typename:int
Width	src/tui/tui.go	/^	Width() int$/;"	n	interface:tui.Window	typeref:typename:int
Window	src/tui/tui.go	/^type Window interface {$/;"	i	package:tui
WindowBase	src/tui/tui.go	/^	WindowBase WindowType = iota$/;"	c	package:tui	typeref:type:WindowType
WindowFooter	src/tui/tui.go	/^	WindowFooter$/;"	c	package:tui
WindowHeader	src/tui/tui.go	/^	WindowHeader$/;"	c	package:tui
WindowInput	src/tui/tui.go	/^	WindowInput$/;"	c	package:tui
WindowList	src/tui/tui.go	/^	WindowList$/;"	c	package:tui
WindowPreview	src/tui/tui.go	/^	WindowPreview$/;"	c	package:tui
WindowType	src/tui/tui.go	/^type WindowType int$/;"	t	package:tui	typeref:typename:int
Windows packages	README.md	/^### Windows packages$/;"	S	section:Installation
With "follow", preview window will automatically scroll to the bottom.	ADVANCED.md	/^# With "follow", preview window will automatically scroll to the bottom.$/;"	c
WithAttr	src/tui/tui.go	/^func (p ColorPair) WithAttr(attr Attr) ColorPair {$/;"	f	struct:tui.ColorPair	typeref:typename:ColorPair
WithBg	src/tui/tui.go	/^func (p ColorPair) WithBg(bg ColorAttr) ColorPair {$/;"	f	struct:tui.ColorPair	typeref:typename:ColorPair
WithNth	src/options.go	/^	WithNth           func(Delimiter) func([]Token, int32) string$/;"	m	struct:fzf.Options	typeref:typename:func(Delimiter) func([]Token, int32) string
WithShell	src/options.go	/^	WithShell         string$/;"	m	struct:fzf.Options	typeref:typename:string
Wrap	src/options.go	/^	Wrap              bool$/;"	m	struct:fzf.Options	typeref:typename:bool
WrapSign	src/options.go	/^	WrapSign          *string$/;"	m	struct:fzf.Options	typeref:typename:*string
WriteTemporaryFile	src/functions.go	/^func WriteTemporaryFile(data []string, printSep string) string {$/;"	f	package:fzf	typeref:typename:string
X	src/tui/light.go	/^func (w *LightWindow) X() int {$/;"	f	struct:tui.LightWindow	typeref:typename:int
X	src/tui/tcell.go	/^func (w *TcellWindow) X() int {$/;"	f	struct:tui.TcellWindow	typeref:typename:int
X	src/tui/tui.go	/^	X      int$/;"	m	struct:tui.MouseEvent	typeref:typename:int
X	src/tui/tui.go	/^	X() int$/;"	n	interface:tui.Window	typeref:typename:int
Y	src/tui/light.go	/^func (w *LightWindow) Y() int {$/;"	f	struct:tui.LightWindow	typeref:typename:int
Y	src/tui/tcell.go	/^func (w *TcellWindow) Y() int {$/;"	f	struct:tui.TcellWindow	typeref:typename:int
Y	src/tui/tui.go	/^	Y      int$/;"	m	struct:tui.MouseEvent	typeref:typename:int
Y	src/tui/tui.go	/^	Y() int$/;"	n	interface:tui.Window	typeref:typename:int
Zero	src/tui/tui.go	/^	Zero$/;"	c	package:tui
Zsh	src/options.go	/^	Zsh               bool$/;"	m	struct:fzf.Options	typeref:typename:bool
[License](LICENSE)	README-VIM.md	/^[License](LICENSE)$/;"	s	chapter:FZF Vim integration
[License](LICENSE)	README.md	/^[License](LICENSE)$/;"	s
[Tuple, the premier screen sharing app for developers](https://tuple.app/fzf)	README.md	/^### [Tuple, the premier screen sharing app for developers](https:\/\/tuple.app\/fzf)$/;"	S
[Warp, the intelligent terminal for developers](https://www.warp.dev/?utm_source=github&utm_medium=referral&utm_campaign=fzf)	README.md	/^### [Warp, the intelligent terminal for developers](https:\/\/www.warp.dev\/?utm_source=github&u/;"	S
]]	shell/completion.bash	/^  if [[ "$(type -t _fzf_comprun 2>&1)" == function ]]; then$/;"	f
]]	shell/completion.zsh	/^  if [[ "$(type _fzf_comprun 2>&1)" =~ function ]]; then$/;"	f
_	src/actiontype_string.go	/^func _() {$/;"	f	package:fzf
_	src/tui/eventtype_string.go	/^func _() {$/;"	f	package:tui
_EventType_index	src/tui/eventtype_string.go	/^var _EventType_index = [...]uint16{0, 4, 9, 14, 19, 24, 29, 34, 39, 44, 47, 52, 57, 62, 67, 72, /;"	v	package:tui
_EventType_name	src/tui/eventtype_string.go	/^const _EventType_name = "RuneCtrlACtrlBCtrlCCtrlDCtrlECtrlFCtrlGCtrlHTabCtrlJCtrlKCtrlLEnterCtrl/;"	c	package:tui
__fzf_cd__	shell/key-bindings.bash	/^__fzf_cd__() {$/;"	f
__fzf_comprun	shell/completion.bash	/^__fzf_comprun() {$/;"	f
__fzf_comprun	shell/completion.zsh	/^__fzf_comprun() {$/;"	f
__fzf_default_completion	shell/completion.bash	/^__fzf_default_completion() {$/;"	f
__fzf_defaults	shell/common.sh	/^__fzf_defaults() {$/;"	f
__fzf_defaults	shell/completion.bash	/^__fzf_defaults() {$/;"	f
__fzf_defaults	shell/completion.zsh	/^__fzf_defaults() {$/;"	f
__fzf_defaults	shell/key-bindings.bash	/^__fzf_defaults() {$/;"	f
__fzf_defaults	shell/key-bindings.zsh	/^__fzf_defaults() {$/;"	f
__fzf_defc	shell/completion.bash	/^__fzf_defc() {$/;"	f
__fzf_exec_awk	shell/common.sh	/^__fzf_exec_awk() {$/;"	f
__fzf_exec_awk	shell/completion.bash	/^__fzf_exec_awk() {$/;"	f
__fzf_exec_awk	shell/completion.zsh	/^__fzf_exec_awk() {$/;"	f
__fzf_exec_awk	shell/key-bindings.bash	/^__fzf_exec_awk() {$/;"	f
__fzf_exec_awk	shell/key-bindings.zsh	/^__fzf_exec_awk() {$/;"	f
__fzf_extract_command	shell/completion.zsh	/^__fzf_extract_command() {$/;"	f
__fzf_generic_path_completion	shell/completion.bash	/^__fzf_generic_path_completion() {$/;"	f
__fzf_generic_path_completion	shell/completion.zsh	/^__fzf_generic_path_completion() {$/;"	f
__fzf_history__	shell/key-bindings.bash	/^  __fzf_history__() {$/;"	f
__fzf_list_hosts	shell/completion.bash	/^  __fzf_list_hosts() {$/;"	f
__fzf_list_hosts	shell/completion.zsh	/^  __fzf_list_hosts() {$/;"	f
__fzf_orig_completion	shell/completion.bash	/^__fzf_orig_completion() {$/;"	f
__fzf_orig_completion_get_orig_func	shell/completion.bash	/^__fzf_orig_completion_get_orig_func() {$/;"	f
__fzf_orig_completion_instantiate	shell/completion.bash	/^__fzf_orig_completion_instantiate() {$/;"	f
__fzf_select	shell/key-bindings.zsh	/^__fzf_select() {$/;"	f
__fzf_select__	shell/key-bindings.bash	/^__fzf_select__() {$/;"	f
__fzfcmd	shell/key-bindings.bash	/^__fzfcmd() {$/;"	f
__fzfcmd	shell/key-bindings.zsh	/^__fzfcmd() {$/;"	f
_actionType_index	src/actiontype_string.go	/^var _actionType_index = [...]uint16{0, 9, 17, 25, 35, 57, 77, 84, 92, 110, 118, 127, 144, 165, 1/;"	v	package:fzf
_actionType_name	src/actiontype_string.go	/^const _actionType_name = "actIgnoreactStartactClickactInvalidactBracketedPasteBeginactBracketedP/;"	c	package:fzf
_colorToAttribute	src/tui/tcell.go	/^	_colorToAttribute = []tcell.Color{$/;"	v	package:tui
_comprun	test/lib/common.sh	/^_comprun() {$/;"	f
_fzf_alias_completion	shell/completion.bash	/^_fzf_alias_completion() {$/;"	f
_fzf_complete	shell/completion.bash	/^_fzf_complete() {$/;"	f
_fzf_complete	shell/completion.zsh	/^_fzf_complete() {$/;"	f
_fzf_complete_export	shell/completion.zsh	/^_fzf_complete_export() {$/;"	f
_fzf_complete_f	test/lib/common.sh	/^_fzf_complete_f() {$/;"	f
_fzf_complete_f_post	test/lib/common.sh	/^_fzf_complete_f_post() {$/;"	f
_fzf_complete_g	test/lib/common.sh	/^_fzf_complete_g() {$/;"	f
_fzf_complete_g_post	test/lib/common.sh	/^_fzf_complete_g_post() {$/;"	f
_fzf_complete_kill	shell/completion.bash	/^_fzf_complete_kill() {$/;"	f
_fzf_complete_kill	shell/completion.zsh	/^_fzf_complete_kill() {$/;"	f
_fzf_complete_kill_post	shell/completion.zsh	/^_fzf_complete_kill_post() {$/;"	f
_fzf_complete_ssh	shell/completion.bash	/^_fzf_complete_ssh() {$/;"	f
_fzf_complete_ssh	shell/completion.zsh	/^_fzf_complete_ssh() {$/;"	f
_fzf_complete_telnet	shell/completion.zsh	/^_fzf_complete_telnet() {$/;"	f
_fzf_complete_unalias	shell/completion.zsh	/^_fzf_complete_unalias() {$/;"	f
_fzf_complete_unset	shell/completion.zsh	/^_fzf_complete_unset() {$/;"	f
_fzf_dir_completion	shell/completion.bash	/^_fzf_dir_completion() {$/;"	f
_fzf_dir_completion	shell/completion.zsh	/^_fzf_dir_completion() {$/;"	f
_fzf_feed_fifo	shell/completion.zsh	/^_fzf_feed_fifo() {$/;"	f
_fzf_file_completion	shell/completion.bash	/^_fzf_file_completion() {$/;"	f
_fzf_handle_dynamic_completion	shell/completion.bash	/^_fzf_handle_dynamic_completion() {$/;"	f
_fzf_host_completion	shell/completion.bash	/^_fzf_host_completion() {$/;"	f
_fzf_opts_completion	shell/completion.bash	/^_fzf_opts_completion() {$/;"	f
_fzf_path_completion	shell/completion.bash	/^_fzf_path_completion() {$/;"	f
_fzf_path_completion	shell/completion.zsh	/^_fzf_path_completion() {$/;"	f
_fzf_proc_completion	shell/completion.bash	/^_fzf_proc_completion() {$/;"	f
_fzf_proc_completion_post	shell/completion.bash	/^_fzf_proc_completion_post() {$/;"	f
_fzf_setup_completion	shell/completion.bash	/^_fzf_setup_completion() {$/;"	f
_fzf_var_completion	shell/completion.bash	/^_fzf_var_completion() {$/;"	f
_initialResize	src/tui/tcell.go	/^	_initialResize   bool = true$/;"	v	package:tui	typeref:typename:bool
_prevMouseButton	src/tui/tcell.go	/^	_prevMouseButton tcell.ButtonMask$/;"	v	package:tui	typeref:typename:tcell.ButtonMask
_screen	src/tui/tcell.go	/^	_screen          tcell.Screen$/;"	v	package:tui	typeref:typename:tcell.Screen
_splitRegex	src/pattern.go	/^var _splitRegex *regexp.Regexp$/;"	v	package:fzf	typeref:typename:*regexp.Regexp
`--height`	ADVANCED.md	/^### `--height`$/;"	S	section:Advanced fzf examples""Display modes
`--height` mode	README.md	/^#### `--height` mode$/;"	t	subsection:Usage""Display modes
`--tmux`	ADVANCED.md	/^### `--tmux`$/;"	S	section:Advanced fzf examples""Display modes
`--tmux` mode	README.md	/^#### `--tmux` mode$/;"	t	subsection:Usage""Display modes
`:FZF[!]`	README-VIM.md	/^`:FZF[!]`$/;"	s	chapter:FZF Vim integration
`fzf#run`	README-VIM.md	/^`fzf#run`$/;"	s	chapter:FZF Vim integration
`fzf#wrap`	README-VIM.md	/^`fzf#wrap`$/;"	s	chapter:FZF Vim integration
a	src/terminal.go	/^	a string$/;"	m	struct:fzf.action	typeref:typename:string
aboveOrBelow	src/options.go	/^func (a previewOpts) aboveOrBelow() bool {$/;"	f	struct:fzf.previewOpts	typeref:typename:bool
acceptNth	src/item.go	/^func (item *Item) acceptNth(stripAnsi bool, delimiter Delimiter, transformer func([]Token, int32/;"	f	struct:fzf.Item	typeref:typename:string
acceptNth	src/terminal.go	/^	acceptNth          func([]Token, int32) string$/;"	m	struct:fzf.Terminal	typeref:typename:func([]Token, int32) string
actAbort	src/terminal.go	/^	actAbort$/;"	c	package:fzf
actAccept	src/terminal.go	/^	actAccept$/;"	c	package:fzf
actAcceptNonEmpty	src/terminal.go	/^	actAcceptNonEmpty$/;"	c	package:fzf
actAcceptOrPrintQuery	src/terminal.go	/^	actAcceptOrPrintQuery$/;"	c	package:fzf
actAsync	src/terminal.go	/^	actAsync$/;"	c	package:fzf
actBackwardChar	src/terminal.go	/^	actBackwardChar$/;"	c	package:fzf
actBackwardDeleteChar	src/terminal.go	/^	actBackwardDeleteChar$/;"	c	package:fzf
actBackwardDeleteCharEof	src/terminal.go	/^	actBackwardDeleteCharEof$/;"	c	package:fzf
actBackwardKillSubWord	src/terminal.go	/^	actBackwardKillSubWord$/;"	c	package:fzf
actBackwardKillWord	src/terminal.go	/^	actBackwardKillWord$/;"	c	package:fzf
actBackwardSubWord	src/terminal.go	/^	actBackwardSubWord$/;"	c	package:fzf
actBackwardWord	src/terminal.go	/^	actBackwardWord$/;"	c	package:fzf
actBecome	src/terminal.go	/^	actBecome$/;"	c	package:fzf
actBeginningOfLine	src/terminal.go	/^	actBeginningOfLine$/;"	c	package:fzf
actBell	src/terminal.go	/^	actBell$/;"	c	package:fzf
actBgCancel	src/terminal.go	/^	actBgCancel$/;"	c	package:fzf
actBgTransform	src/terminal.go	/^	actBgTransform$/;"	c	package:fzf
actBgTransformBorderLabel	src/terminal.go	/^	actBgTransformBorderLabel$/;"	c	package:fzf
actBgTransformFooter	src/terminal.go	/^	actBgTransformFooter$/;"	c	package:fzf
actBgTransformFooterLabel	src/terminal.go	/^	actBgTransformFooterLabel$/;"	c	package:fzf
actBgTransformGhost	src/terminal.go	/^	actBgTransformGhost$/;"	c	package:fzf
actBgTransformHeader	src/terminal.go	/^	actBgTransformHeader$/;"	c	package:fzf
actBgTransformHeaderLabel	src/terminal.go	/^	actBgTransformHeaderLabel$/;"	c	package:fzf
actBgTransformInputLabel	src/terminal.go	/^	actBgTransformInputLabel$/;"	c	package:fzf
actBgTransformListLabel	src/terminal.go	/^	actBgTransformListLabel$/;"	c	package:fzf
actBgTransformNth	src/terminal.go	/^	actBgTransformNth$/;"	c	package:fzf
actBgTransformPointer	src/terminal.go	/^	actBgTransformPointer$/;"	c	package:fzf
actBgTransformPreviewLabel	src/terminal.go	/^	actBgTransformPreviewLabel$/;"	c	package:fzf
actBgTransformPrompt	src/terminal.go	/^	actBgTransformPrompt$/;"	c	package:fzf
actBgTransformQuery	src/terminal.go	/^	actBgTransformQuery$/;"	c	package:fzf
actBgTransformSearch	src/terminal.go	/^	actBgTransformSearch$/;"	c	package:fzf
actBracketedPasteBegin	src/terminal.go	/^	actBracketedPasteBegin$/;"	c	package:fzf
actBracketedPasteEnd	src/terminal.go	/^	actBracketedPasteEnd$/;"	c	package:fzf
actCancel	src/terminal.go	/^	actCancel$/;"	c	package:fzf
actChangeBorderLabel	src/terminal.go	/^	actChangeBorderLabel$/;"	c	package:fzf
actChangeFooter	src/terminal.go	/^	actChangeFooter$/;"	c	package:fzf
actChangeFooterLabel	src/terminal.go	/^	actChangeFooterLabel$/;"	c	package:fzf
actChangeGhost	src/terminal.go	/^	actChangeGhost$/;"	c	package:fzf
actChangeHeader	src/terminal.go	/^	actChangeHeader$/;"	c	package:fzf
actChangeHeaderLabel	src/terminal.go	/^	actChangeHeaderLabel$/;"	c	package:fzf
actChangeInputLabel	src/terminal.go	/^	actChangeInputLabel$/;"	c	package:fzf
actChangeListLabel	src/terminal.go	/^	actChangeListLabel$/;"	c	package:fzf
actChangeMulti	src/terminal.go	/^	actChangeMulti$/;"	c	package:fzf
actChangeNth	src/terminal.go	/^	actChangeNth$/;"	c	package:fzf
actChangePointer	src/terminal.go	/^	actChangePointer$/;"	c	package:fzf
actChangePreview	src/terminal.go	/^	actChangePreview$/;"	c	package:fzf
actChangePreviewLabel	src/terminal.go	/^	actChangePreviewLabel$/;"	c	package:fzf
actChangePreviewWindow	src/terminal.go	/^	actChangePreviewWindow$/;"	c	package:fzf
actChangePrompt	src/terminal.go	/^	actChangePrompt$/;"	c	package:fzf
actChangeQuery	src/terminal.go	/^	actChangeQuery$/;"	c	package:fzf
actChar	src/terminal.go	/^	actChar$/;"	c	package:fzf
actClearQuery	src/terminal.go	/^	actClearQuery$/;"	c	package:fzf
actClearScreen	src/terminal.go	/^	actClearScreen$/;"	c	package:fzf
actClearSelection	src/terminal.go	/^	actClearSelection$/;"	c	package:fzf
actClick	src/terminal.go	/^	actClick$/;"	c	package:fzf
actClose	src/terminal.go	/^	actClose$/;"	c	package:fzf
actDeleteChar	src/terminal.go	/^	actDeleteChar$/;"	c	package:fzf
actDeleteCharEof	src/terminal.go	/^	actDeleteCharEof$/;"	c	package:fzf
actDeselect	src/terminal.go	/^	actDeselect$/;"	c	package:fzf
actDeselectAll	src/terminal.go	/^	actDeselectAll$/;"	c	package:fzf
actDisableSearch	src/terminal.go	/^	actDisableSearch$/;"	c	package:fzf
actDown	src/terminal.go	/^	actDown$/;"	c	package:fzf
actEnableSearch	src/terminal.go	/^	actEnableSearch$/;"	c	package:fzf
actEndOfLine	src/terminal.go	/^	actEndOfLine$/;"	c	package:fzf
actExclude	src/terminal.go	/^	actExclude$/;"	c	package:fzf
actExcludeMulti	src/terminal.go	/^	actExcludeMulti$/;"	c	package:fzf
actExecute	src/terminal.go	/^	actExecute$/;"	c	package:fzf
actExecuteMulti	src/terminal.go	/^	actExecuteMulti \/\/ Deprecated$/;"	c	package:fzf
actExecuteSilent	src/terminal.go	/^	actExecuteSilent$/;"	c	package:fzf
actFatal	src/terminal.go	/^	actFatal$/;"	c	package:fzf
actFirst	src/terminal.go	/^	actFirst$/;"	c	package:fzf
actForwardChar	src/terminal.go	/^	actForwardChar$/;"	c	package:fzf
actForwardSubWord	src/terminal.go	/^	actForwardSubWord$/;"	c	package:fzf
actForwardWord	src/terminal.go	/^	actForwardWord$/;"	c	package:fzf
actHalfPageDown	src/terminal.go	/^	actHalfPageDown$/;"	c	package:fzf
actHalfPageUp	src/terminal.go	/^	actHalfPageUp$/;"	c	package:fzf
actHideHeader	src/terminal.go	/^	actHideHeader$/;"	c	package:fzf
actHideInput	src/terminal.go	/^	actHideInput$/;"	c	package:fzf
actHidePreview	src/terminal.go	/^	actHidePreview$/;"	c	package:fzf
actIgnore	src/terminal.go	/^	actIgnore actionType = iota$/;"	c	package:fzf	typeref:type:actionType
actInvalid	src/terminal.go	/^	actInvalid$/;"	c	package:fzf
actJump	src/terminal.go	/^	actJump$/;"	c	package:fzf
actJumpAccept	src/terminal.go	/^	actJumpAccept \/\/ XXX Deprecated in favor of jump:accept binding$/;"	c	package:fzf
actKillLine	src/terminal.go	/^	actKillLine$/;"	c	package:fzf
actKillSubWord	src/terminal.go	/^	actKillSubWord$/;"	c	package:fzf
actKillWord	src/terminal.go	/^	actKillWord$/;"	c	package:fzf
actLast	src/terminal.go	/^	actLast$/;"	c	package:fzf
actMouse	src/terminal.go	/^	actMouse$/;"	c	package:fzf
actNextHistory	src/terminal.go	/^	actNextHistory$/;"	c	package:fzf
actNextSelected	src/terminal.go	/^	actNextSelected$/;"	c	package:fzf
actOffsetDown	src/terminal.go	/^	actOffsetDown$/;"	c	package:fzf
actOffsetMiddle	src/terminal.go	/^	actOffsetMiddle$/;"	c	package:fzf
actOffsetUp	src/terminal.go	/^	actOffsetUp$/;"	c	package:fzf
actPageDown	src/terminal.go	/^	actPageDown$/;"	c	package:fzf
actPageUp	src/terminal.go	/^	actPageUp$/;"	c	package:fzf
actPosition	src/terminal.go	/^	actPosition$/;"	c	package:fzf
actPrevHistory	src/terminal.go	/^	actPrevHistory$/;"	c	package:fzf
actPrevSelected	src/terminal.go	/^	actPrevSelected$/;"	c	package:fzf
actPreview	src/terminal.go	/^	actPreview$/;"	c	package:fzf
actPreviewBottom	src/terminal.go	/^	actPreviewBottom$/;"	c	package:fzf
actPreviewDown	src/terminal.go	/^	actPreviewDown$/;"	c	package:fzf
actPreviewHalfPageDown	src/terminal.go	/^	actPreviewHalfPageDown$/;"	c	package:fzf
actPreviewHalfPageUp	src/terminal.go	/^	actPreviewHalfPageUp$/;"	c	package:fzf
actPreviewPageDown	src/terminal.go	/^	actPreviewPageDown$/;"	c	package:fzf
actPreviewPageUp	src/terminal.go	/^	actPreviewPageUp$/;"	c	package:fzf
actPreviewTop	src/terminal.go	/^	actPreviewTop$/;"	c	package:fzf
actPreviewUp	src/terminal.go	/^	actPreviewUp$/;"	c	package:fzf
actPrint	src/terminal.go	/^	actPrint$/;"	c	package:fzf
actPrintQuery	src/terminal.go	/^	actPrintQuery \/\/ XXX Deprecated (not very useful, just use --print-query)$/;"	c	package:fzf
actPut	src/terminal.go	/^	actPut$/;"	c	package:fzf
actRebind	src/terminal.go	/^	actRebind$/;"	c	package:fzf
actRefreshPreview	src/terminal.go	/^	actRefreshPreview$/;"	c	package:fzf
actReload	src/terminal.go	/^	actReload$/;"	c	package:fzf
actReloadSync	src/terminal.go	/^	actReloadSync$/;"	c	package:fzf
actReplaceQuery	src/terminal.go	/^	actReplaceQuery$/;"	c	package:fzf
actSearch	src/terminal.go	/^	actSearch$/;"	c	package:fzf
actSelect	src/terminal.go	/^	actSelect$/;"	c	package:fzf
actSelectAll	src/terminal.go	/^	actSelectAll$/;"	c	package:fzf
actShowHeader	src/terminal.go	/^	actShowHeader$/;"	c	package:fzf
actShowInput	src/terminal.go	/^	actShowInput$/;"	c	package:fzf
actShowPreview	src/terminal.go	/^	actShowPreview$/;"	c	package:fzf
actSigStop	src/terminal.go	/^	actSigStop$/;"	c	package:fzf
actStart	src/terminal.go	/^	actStart$/;"	c	package:fzf
actToggle	src/terminal.go	/^	actToggle$/;"	c	package:fzf
actToggleAll	src/terminal.go	/^	actToggleAll$/;"	c	package:fzf
actToggleBind	src/terminal.go	/^	actToggleBind$/;"	c	package:fzf
actToggleDown	src/terminal.go	/^	actToggleDown$/;"	c	package:fzf
actToggleHeader	src/terminal.go	/^	actToggleHeader$/;"	c	package:fzf
actToggleHscroll	src/terminal.go	/^	actToggleHscroll$/;"	c	package:fzf
actToggleIn	src/terminal.go	/^	actToggleIn$/;"	c	package:fzf
actToggleInput	src/terminal.go	/^	actToggleInput$/;"	c	package:fzf
actToggleMultiLine	src/terminal.go	/^	actToggleMultiLine$/;"	c	package:fzf
actToggleOut	src/terminal.go	/^	actToggleOut$/;"	c	package:fzf
actTogglePreview	src/terminal.go	/^	actTogglePreview$/;"	c	package:fzf
actTogglePreviewWrap	src/terminal.go	/^	actTogglePreviewWrap$/;"	c	package:fzf
actToggleSearch	src/terminal.go	/^	actToggleSearch$/;"	c	package:fzf
actToggleSort	src/terminal.go	/^	actToggleSort$/;"	c	package:fzf
actToggleTrack	src/terminal.go	/^	actToggleTrack$/;"	c	package:fzf
actToggleTrackCurrent	src/terminal.go	/^	actToggleTrackCurrent$/;"	c	package:fzf
actToggleUp	src/terminal.go	/^	actToggleUp$/;"	c	package:fzf
actToggleWrap	src/terminal.go	/^	actToggleWrap$/;"	c	package:fzf
actTrackCurrent	src/terminal.go	/^	actTrackCurrent$/;"	c	package:fzf
actTransform	src/terminal.go	/^	actTransform$/;"	c	package:fzf
actTransformBorderLabel	src/terminal.go	/^	actTransformBorderLabel$/;"	c	package:fzf
actTransformFooter	src/terminal.go	/^	actTransformFooter$/;"	c	package:fzf
actTransformFooterLabel	src/terminal.go	/^	actTransformFooterLabel$/;"	c	package:fzf
actTransformGhost	src/terminal.go	/^	actTransformGhost$/;"	c	package:fzf
actTransformHeader	src/terminal.go	/^	actTransformHeader$/;"	c	package:fzf
actTransformHeaderLabel	src/terminal.go	/^	actTransformHeaderLabel$/;"	c	package:fzf
actTransformInputLabel	src/terminal.go	/^	actTransformInputLabel$/;"	c	package:fzf
actTransformListLabel	src/terminal.go	/^	actTransformListLabel$/;"	c	package:fzf
actTransformNth	src/terminal.go	/^	actTransformNth$/;"	c	package:fzf
actTransformPointer	src/terminal.go	/^	actTransformPointer$/;"	c	package:fzf
actTransformPreviewLabel	src/terminal.go	/^	actTransformPreviewLabel$/;"	c	package:fzf
actTransformPrompt	src/terminal.go	/^	actTransformPrompt$/;"	c	package:fzf
actTransformQuery	src/terminal.go	/^	actTransformQuery$/;"	c	package:fzf
actTransformSearch	src/terminal.go	/^	actTransformSearch$/;"	c	package:fzf
actTrigger	src/terminal.go	/^	actTrigger$/;"	c	package:fzf
actUnbind	src/terminal.go	/^	actUnbind$/;"	c	package:fzf
actUnixLineDiscard	src/terminal.go	/^	actUnixLineDiscard$/;"	c	package:fzf
actUnixWordRubout	src/terminal.go	/^	actUnixWordRubout$/;"	c	package:fzf
actUntrackCurrent	src/terminal.go	/^	actUntrackCurrent$/;"	c	package:fzf
actUp	src/terminal.go	/^	actUp$/;"	c	package:fzf
actYank	src/terminal.go	/^	actYank$/;"	c	package:fzf
action	src/terminal.go	/^type action struct {$/;"	s	package:fzf
actionChannel	src/server.go	/^	actionChannel chan []*action$/;"	m	struct:fzf.httpServer	typeref:typename:chan []*action
actionNameRegexp	src/options.go	/^	actionNameRegexp *regexp.Regexp$/;"	v	package:fzf	typeref:typename:*regexp.Regexp
actionType	src/terminal.go	/^type actionType int$/;"	t	package:fzf	typeref:typename:int
activePreviewOpts	src/terminal.go	/^	activePreviewOpts  *previewOpts$/;"	m	struct:fzf.Terminal	typeref:typename:*previewOpts
addClickFooterWord	src/terminal.go	/^func (t *Terminal) addClickFooterWord(env []string) []string {$/;"	f	struct:fzf.Terminal	typeref:typename:[]string
addClickHeaderWord	src/terminal.go	/^func (t *Terminal) addClickHeaderWord(env []string) []string {$/;"	f	struct:fzf.Terminal	typeref:typename:[]string
adjustMarginAndPadding	src/terminal.go	/^func (t *Terminal) adjustMarginAndPadding() (int, int, [4]int, [4]int) {$/;"	f	struct:fzf.Terminal	typeref:typename:(int, int, [4]int, [4]int)
algo	src/algo/algo.go	/^package algo$/;"	p
algo	src/algo/algo_test.go	/^package algo$/;"	p
algo	src/algo/normalize.go	/^package algo$/;"	p
all	Makefile	/^all: target\/$(BINARY)$/;"	t
allItems	src/terminal.go	/^	allItems   [3][]*Item \/\/ current, select, and all matched items$/;"	m	struct:fzf.replacePlaceholderParams	typeref:typename:[3][]*Item
allItems	src/terminal_test.go	/^	allItems [3][]*Item$/;"	m	struct:fzf.give	typeref:typename:[3][]*Item
alloc16	src/algo/algo.go	/^func alloc16(offset int, slab *util.Slab, size int) (int, []int16) {$/;"	f	package:algo	typeref:typename:(int, []int16)
alloc32	src/algo/algo.go	/^func alloc32(offset int, slab *util.Slab, size int) (int, []int32) {$/;"	f	package:algo	typeref:typename:(int, []int32)
alternative	src/options.go	/^	alternative *previewOpts$/;"	m	struct:fzf.previewOpts	typeref:typename:*previewOpts
ansi	src/terminal.go	/^	ansi               bool$/;"	m	struct:fzf.Terminal	typeref:typename:bool
ansiBenchmarkString	src/ansi_test.go	/^const ansiBenchmarkString = "\\x1b[38;5;81m\\x1b[01;31m\\x1b[Kkernel\/\\x1b[0m\\x1b[38:5:81mbpf\//;"	c	package:fzf
ansiLabelPrinter	src/terminal.go	/^func (t *Terminal) ansiLabelPrinter(str string, color *tui.ColorPair, fill bool) (labelPrinter, /;"	f	struct:fzf.Terminal	typeref:typename:(labelPrinter, int)
ansiOffset	src/ansi.go	/^type ansiOffset struct {$/;"	s	package:fzf
ansiRegexReference	src/ansi_test.go	/^var ansiRegexReference = regexp.MustCompile("(?:\\x1b[\\\\[()][0-9;:]*[a-zA-Z@]|\\x1b][0-9][;:][/;"	v	package:fzf
ansiState	src/ansi.go	/^type ansiState struct {$/;"	s	package:fzf
any_include?	test/lib/common.rb	/^          def any_include?(val)$/;"	f	method:Tmux.until
apiKey	src/server.go	/^	apiKey        []byte$/;"	m	struct:fzf.httpServer	typeref:typename:[]byte
append	src/history.go	/^func (h *History) append(line string) error {$/;"	f	struct:fzf.History	typeref:typename:error
append_line	install	/^append_line() {$/;"	f
applyPreset	src/options.go	/^func applyPreset(opts *Options, preset string) error {$/;"	f	package:fzf	typeref:typename:error
arcticicestudio/nord-vim	ADVANCED.md	/^# arcticicestudio\/nord-vim$/;"	c
areaColumns	src/terminal.go	/^	areaColumns        int$/;"	m	struct:fzf.Terminal	typeref:typename:int
areaLines	src/terminal.go	/^	areaLines          int$/;"	m	struct:fzf.Terminal	typeref:typename:int
args	src/util/util_unix.go	/^	args    []string$/;"	m	struct:util.Executor	typeref:typename:[]string
args	src/util/util_windows.go	/^	args      []string$/;"	m	struct:util.Executor	typeref:typename:[]string
asTcellColor	src/tui/tcell.go	/^func asTcellColor(color Color) tcell.Color {$/;"	f	package:tui	typeref:typename:tcell.Color
asciiCharClasses	src/algo/algo.go	/^	asciiCharClasses [unicode.MaxASCII + 1]charClass$/;"	v	package:algo	typeref:typename:[unicode.MaxASCII + 1]charClass
asciiFuzzyIndex	src/algo/algo.go	/^func asciiFuzzyIndex(input *util.Chars, pattern []rune, caseSensitive bool) (int, int) {$/;"	f	package:algo	typeref:typename:(int, int)
ask	install	/^ask() {$/;"	f
ask	uninstall	/^ask() {$/;"	f
assert	src/merger_test.go	/^func assert(t *testing.T, cond bool, msg ...string) {$/;"	f	package:fzf
assert	src/tui/tcell_test.go	/^func assert(t *testing.T, context string, got any, want any) bool {$/;"	f	package:tui	typeref:typename:bool
assertMatch	src/algo/algo_test.go	/^func assertMatch(t *testing.T, fun Algo, caseSensitive, forward bool, input, pattern string, sid/;"	f	package:algo
assertMatch2	src/algo/algo_test.go	/^func assertMatch2(t *testing.T, fun Algo, caseSensitive, normalize, forward bool, input, pattern/;"	f	package:algo
assert_block	test/test_layout.rb	/^  def assert_block(expected, lines)$/;"	f	class:TestLayout
assert_equal	test/lib/common.rb	/^  def assert_equal(expected, actual)$/;"	f	class:TestBase
assert_equal_org	test/lib/common.rb	/^  alias assert_equal_org assert_equal$/;"	a	class:TestBase
asterisk	src/terminal.go	/^	asterisk      bool$/;"	m	struct:fzf.placeholderFlags	typeref:typename:bool
at	src/terminal.go	/^	at   time.Time$/;"	m	struct:fzf.selectedItem	typeref:typename:time.Time
atExitFuncs	src/util/atexit.go	/^var atExitFuncs []func()$/;"	v	package:util	typeref:typename:[]func()
atMost	src/terminal.go	/^	atMost   int$/;"	m	struct:fzf.numLinesCacheValue	typeref:typename:int
atof	src/options.go	/^func atof(str string) (float64, error) {$/;"	f	package:fzf	typeref:typename:(float64, error)
atoi	src/options.go	/^func atoi(str string) (int, error) {$/;"	f	package:fzf	typeref:typename:(int, error)
atoi	src/tui/light.go	/^func atoi(s string, defaultValue int) int {$/;"	f	package:tui	typeref:typename:int
attr	src/ansi.go	/^	attr tui.Attr$/;"	m	struct:fzf.ansiState	typeref:typename:tui.Attr
attr	src/tui/tui.go	/^	attr Attr$/;"	m	struct:tui.ColorPair	typeref:typename:Attr
attrCodes	src/tui/light.go	/^func attrCodes(attr Attr) []string {$/;"	f	package:tui	typeref:typename:[]string
auto	src/options.go	/^	auto    bool$/;"	m	struct:fzf.heightSpec	typeref:typename:bool
avgNumLines	src/terminal.go	/^func (t *Terminal) avgNumLines() int {$/;"	f	struct:fzf.Terminal	typeref:typename:int
awkBlack	src/tokenizer.go	/^	awkBlack$/;"	c	package:fzf
awkNil	src/tokenizer.go	/^	awkNil = iota$/;"	c	package:fzf
awkTokenizer	src/tokenizer.go	/^func awkTokenizer(input string) ([]string, int) {$/;"	f	package:fzf	typeref:typename:([]string, int)
awkWhite	src/tokenizer.go	/^	awkWhite$/;"	c	package:fzf
bar	src/terminal.go	/^	bar        []bool$/;"	m	struct:fzf.previewer	typeref:typename:[]bool
barCol	src/terminal.go	/^func (t *Terminal) barCol() int {$/;"	f	struct:fzf.Terminal	typeref:typename:int
bash	test/lib/common.rb	/^    def bash$/;"	S	class:Shell
bashCompletion	main.go	/^var bashCompletion []byte$/;"	v	package:main	typeref:typename:[]byte
bashKeyBindings	main.go	/^var bashKeyBindings []byte$/;"	v	package:main	typeref:typename:[]byte
basicMatch	src/pattern.go	/^func (p *Pattern) basicMatch(item *Item, withPos bool, slab *util.Slab) (Offset, int, *[]int) {$/;"	f	struct:fzf.Pattern	typeref:typename:(Offset, int, *[]int)
becomeSuffix	src/proxy.go	/^const becomeSuffix = ".become"$/;"	c	package:fzf
begin	src/tokenizer.go	/^	begin int$/;"	m	struct:fzf.Range	typeref:typename:int
bench	Makefile	/^bench:$/;"	t
bg	src/ansi.go	/^	bg   tui.Color$/;"	m	struct:fzf.ansiState	typeref:typename:tui.Color
bg	src/tui/light.go	/^	bg            Color$/;"	m	struct:tui.LightWindow	typeref:typename:Color
bg	src/tui/tui.go	/^	bg   Color$/;"	m	struct:tui.ColorPair	typeref:typename:Color
bgQueue	src/terminal.go	/^	bgQueue            map[action][]func(bool)$/;"	m	struct:fzf.Terminal	typeref:typename:map[action][]func(bool)
bgSemaphore	src/terminal.go	/^	bgSemaphore        chan struct{}$/;"	m	struct:fzf.Terminal	typeref:typename:chan struct{}
bgSemaphores	src/terminal.go	/^	bgSemaphores       map[action]chan struct{}$/;"	m	struct:fzf.Terminal	typeref:typename:map[action]chan struct{}
bgVersion	src/terminal.go	/^	bgVersion          int64$/;"	m	struct:fzf.Terminal	typeref:typename:int64
bin/fzf	Makefile	/^bin\/fzf: target\/$(BINARY) | bin$/;"	t
blockDuration	src/terminal.go	/^const blockDuration = 1 * time.Second$/;"	c	package:fzf
bonusAt	src/algo/algo.go	/^func bonusAt(input *util.Chars, idx int) int16 {$/;"	f	package:algo	typeref:typename:int16
bonusBoundary	src/algo/algo.go	/^	bonusBoundary = scoreMatch \/ 2$/;"	c	package:algo
bonusBoundaryDelimiter	src/algo/algo.go	/^	bonusBoundaryDelimiter int16 = bonusBoundary + 1$/;"	v	package:algo	typeref:typename:int16
bonusBoundaryWhite	src/algo/algo.go	/^	bonusBoundaryWhite int16 = bonusBoundary + 2$/;"	v	package:algo	typeref:typename:int16
bonusCamel123	src/algo/algo.go	/^	bonusCamel123 = bonusBoundary + scoreGapExtension$/;"	c	package:algo
bonusConsecutive	src/algo/algo.go	/^	bonusConsecutive = -(scoreGapStart + scoreGapExtension)$/;"	c	package:algo
bonusFirstCharMultiplier	src/algo/algo.go	/^	bonusFirstCharMultiplier = 2$/;"	c	package:algo
bonusFor	src/algo/algo.go	/^func bonusFor(prevClass charClass, class charClass) int16 {$/;"	f	package:algo	typeref:typename:int16
bonusMatrix	src/algo/algo.go	/^	bonusMatrix [charNumber + 1][charNumber + 1]int16$/;"	v	package:algo	typeref:typename:[charNumber + 1][charNumber + 1]int16
bonusNonWord	src/algo/algo.go	/^	bonusNonWord = scoreMatch \/ 2$/;"	c	package:algo
border	src/options.go	/^	border      tui.BorderShape$/;"	m	struct:fzf.previewOpts	typeref:typename:tui.BorderShape
border	src/options.go	/^	border   bool$/;"	m	struct:fzf.tmuxOptions	typeref:typename:bool
border	src/terminal.go	/^	border             tui.Window$/;"	m	struct:fzf.Terminal	typeref:typename:tui.Window
border	src/tui/light.go	/^	border        BorderStyle$/;"	m	struct:tui.LightWindow	typeref:typename:BorderStyle
borderColumns	src/terminal.go	/^func borderColumns(shape tui.BorderShape, borderWidth int) int {$/;"	f	package:fzf	typeref:typename:int
borderLabel	src/terminal.go	/^	borderLabel        labelPrinter$/;"	m	struct:fzf.Terminal	typeref:typename:labelPrinter
borderLabelLen	src/terminal.go	/^	borderLabelLen     int$/;"	m	struct:fzf.Terminal	typeref:typename:int
borderLabelOpts	src/terminal.go	/^	borderLabelOpts    labelOpts$/;"	m	struct:fzf.Terminal	typeref:typename:labelOpts
borderLines	src/terminal.go	/^func borderLines(shape tui.BorderShape) int {$/;"	f	package:fzf	typeref:typename:int
borderShape	src/terminal.go	/^	borderShape        tui.BorderShape$/;"	m	struct:fzf.Terminal	typeref:typename:tui.BorderShape
borderStyle	src/tui/tcell.go	/^	borderStyle   BorderStyle$/;"	m	struct:tui.TcellWindow	typeref:typename:BorderStyle
borderWidth	src/terminal.go	/^	borderWidth        int$/;"	m	struct:fzf.Terminal	typeref:typename:int
bottom	src/options.go	/^	bottom bool$/;"	m	struct:fzf.labelOpts	typeref:typename:bool
bottom	src/tui/tui.go	/^	bottom      rune$/;"	m	struct:tui.BorderStyle	typeref:typename:rune
bottomLeft	src/tui/tui.go	/^	bottomLeft  rune$/;"	m	struct:tui.BorderStyle	typeref:typename:rune
bottomRight	src/tui/tui.go	/^	bottomRight rune$/;"	m	struct:tui.BorderStyle	typeref:typename:rune
buffer	src/tui/light.go	/^	buffer        []byte$/;"	m	struct:tui.LightRenderer	typeref:typename:[]byte
build	Makefile	/^build:$/;"	t
buildCacheKey	src/pattern.go	/^func (p *Pattern) buildCacheKey() string {$/;"	f	struct:fzf.Pattern	typeref:typename:string
buildLists	src/merger_test.go	/^func buildLists(partiallySorted bool) ([][]Result, []Result) {$/;"	f	package:fzf	typeref:typename:([][]Result, []Result)
buildPattern	src/pattern_test.go	/^func buildPattern(fuzzy bool, fuzzyAlgo algo.Algo, extended bool, caseMode Case, normalize bool,/;"	f	package:fzf	typeref:typename:*Pattern
buildPlusList	src/terminal.go	/^func (t *Terminal) buildPlusList(template string, forcePlus bool) (bool, [3][]*Item) {$/;"	f	struct:fzf.Terminal	typeref:typename:(bool, [3][]*Item)
buildResult	src/result.go	/^func buildResult(item *Item, offsets []Offset, score int) Result {$/;"	f	package:fzf	typeref:typename:Result
bumpMajor	src/core.go	/^func (r *revision) bumpMajor() {$/;"	f	struct:fzf.revision
bumpMinor	src/core.go	/^func (r *revision) bumpMinor() {$/;"	f	struct:fzf.revision
byBegin	src/options.go	/^	byBegin$/;"	c	package:fzf
byChunk	src/options.go	/^	byChunk$/;"	c	package:fzf
byEnd	src/options.go	/^	byEnd$/;"	c	package:fzf
byLength	src/options.go	/^	byLength$/;"	c	package:fzf
byPathname	src/options.go	/^	byPathname$/;"	c	package:fzf
byScore	src/options.go	/^	byScore criterion = iota$/;"	c	package:fzf	typeref:type:criterion
byTimeOrder	src/terminal.go	/^type byTimeOrder []selectedItem$/;"	t	package:fzf	typeref:typename:[]selectedItem
byteString	src/functions.go	/^func byteString(data []byte) string {$/;"	f	package:fzf	typeref:typename:string
cache	src/cache.go	/^	cache map[*Chunk]*queryCache$/;"	m	struct:fzf.ChunkCache	typeref:typename:map[*Chunk]*queryCache
cache	src/chunklist.go	/^	cache  *ChunkCache$/;"	m	struct:fzf.ChunkList	typeref:typename:*ChunkCache
cache	src/matcher.go	/^	cache          *ChunkCache$/;"	m	struct:fzf.Matcher	typeref:typename:*ChunkCache
cache	src/pattern.go	/^	cache         *ChunkCache$/;"	m	struct:fzf.Pattern	typeref:typename:*ChunkCache
cacheKey	src/pattern.go	/^	cacheKey      string$/;"	m	struct:fzf.Pattern	typeref:typename:string
cacheable	src/merger.go	/^func (mg *Merger) cacheable() bool {$/;"	f	struct:fzf.Merger	typeref:typename:bool
cacheable	src/pattern.go	/^	cacheable     bool$/;"	m	struct:fzf.Pattern	typeref:typename:bool
calculateScore	src/algo/algo.go	/^func calculateScore(caseSensitive bool, normalize bool, text *util.Chars, pattern []rune, sidx i/;"	f	package:algo	typeref:typename:(int, *[]int)
calculateSize	src/terminal.go	/^func calculateSize(base int, size sizeSpec, occupied int, minSize int) int {$/;"	f	package:fzf	typeref:typename:int
callback	src/terminal.go	/^	callback func()$/;"	m	struct:fzf.versionedCallback	typeref:typename:func()
callbackChan	src/terminal.go	/^	callbackChan       chan versionedCallback$/;"	m	struct:fzf.Terminal	typeref:typename:chan versionedCallback
canPreview	src/terminal.go	/^func (t *Terminal) canPreview() bool {$/;"	f	struct:fzf.Terminal	typeref:typename:bool
canSpanMultiLines	src/terminal.go	/^func (t *Terminal) canSpanMultiLines() bool {$/;"	f	struct:fzf.Terminal	typeref:typename:bool
cancelPreview	src/terminal.go	/^func (t *Terminal) cancelPreview() {$/;"	f	struct:fzf.Terminal
capture	test/lib/common.rb	/^  def capture$/;"	f	class:Tmux
captureAsync	src/terminal.go	/^func (t *Terminal) captureAsync(a action, firstLineOnly bool, callback func(string)) {$/;"	f	struct:fzf.Terminal
captureLine	src/terminal.go	/^func (t *Terminal) captureLine(template string) string {$/;"	f	struct:fzf.Terminal	typeref:typename:string
captureLines	src/terminal.go	/^func (t *Terminal) captureLines(template string) string {$/;"	f	struct:fzf.Terminal	typeref:typename:string
caseSensitive	src/pattern.go	/^	caseSensitive bool$/;"	m	struct:fzf.Pattern	typeref:typename:bool
caseSensitive	src/pattern.go	/^	caseSensitive bool$/;"	m	struct:fzf.term	typeref:typename:bool
changeFooter	src/terminal.go	/^func (t *Terminal) changeFooter(footer string) {$/;"	f	struct:fzf.Terminal
changeHeader	src/terminal.go	/^func (t *Terminal) changeHeader(header string) bool {$/;"	f	struct:fzf.Terminal	typeref:typename:bool
changed	src/terminal.go	/^	changed  bool$/;"	m	struct:fzf.searchRequest	typeref:typename:bool
channelTimeout	src/server.go	/^	channelTimeout   = 2 * time.Second$/;"	c	package:fzf
charClass	src/algo/algo.go	/^type charClass int$/;"	t	package:algo	typeref:typename:int
charClassOf	src/algo/algo.go	/^func charClassOf(char rune) charClass {$/;"	f	package:algo	typeref:typename:charClass
charClassOfNonAscii	src/algo/algo.go	/^func charClassOfNonAscii(char rune) charClass {$/;"	f	package:algo	typeref:typename:charClass
charDelimiter	src/algo/algo.go	/^	charDelimiter$/;"	c	package:algo
charLetter	src/algo/algo.go	/^	charLetter$/;"	c	package:algo
charLower	src/algo/algo.go	/^	charLower$/;"	c	package:algo
charNonWord	src/algo/algo.go	/^	charNonWord$/;"	c	package:algo
charNumber	src/algo/algo.go	/^	charNumber$/;"	c	package:algo
charUpper	src/algo/algo.go	/^	charUpper$/;"	c	package:algo
charWhite	src/algo/algo.go	/^	charWhite charClass = iota$/;"	c	package:algo	typeref:type:charClass
checkAscii	src/util/chars.go	/^func checkAscii(bytes []byte) (bool, int) {$/;"	f	package:util	typeref:typename:(bool, int)
check_binary	install	/^check_binary() {$/;"	f
check_binary	install.ps1	/^function check_binary () {$/;"	f
chunkSize	src/constants.go	/^	chunkSize int = 100$/;"	c	package:fzf	typeref:typename:int
chunks	src/chunklist.go	/^	chunks []*Chunk$/;"	m	struct:fzf.ChunkList	typeref:typename:[]*Chunk
chunks	src/matcher.go	/^	chunks   []*Chunk$/;"	m	struct:fzf.MatchRequest	typeref:typename:[]*Chunk
chunks	src/merger.go	/^	chunks   *[]*Chunk$/;"	m	struct:fzf.Merger	typeref:typename:*[]*Chunk
clean	Makefile	/^clean:$/;"	t
cleanExit	src/terminal.go	/^	cleanExit          bool$/;"	m	struct:fzf.Terminal	typeref:typename:bool
cleanse	src/tui/light.go	/^func cleanse(str string) string {$/;"	f	package:tui	typeref:typename:string
cleanup	bin/fzf-tmux	/^cleanup() {$/;"	f
clearCode	src/terminal.go	/^const clearCode string = "\\x1b[2J"$/;"	c	package:fzf	typeref:typename:string
clearNumLinesCache	src/terminal.go	/^func (t *Terminal) clearNumLinesCache() {$/;"	f	struct:fzf.Terminal
clearOnExit	src/tui/light.go	/^	clearOnExit   bool$/;"	m	struct:tui.LightRenderer	typeref:typename:bool
clickFooterColumn	src/terminal.go	/^	clickFooterColumn  int$/;"	m	struct:fzf.Terminal	typeref:typename:int
clickFooterLine	src/terminal.go	/^	clickFooterLine    int$/;"	m	struct:fzf.Terminal	typeref:typename:int
clickHeaderColumn	src/terminal.go	/^	clickHeaderColumn  int$/;"	m	struct:fzf.Terminal	typeref:typename:int
clickHeaderLine	src/terminal.go	/^	clickHeaderLine    int$/;"	m	struct:fzf.Terminal	typeref:typename:int
clicks	src/tui/light.go	/^	clicks        [][2]int$/;"	m	struct:tui.LightRenderer	typeref:typename:[][2]int
clicks	src/tui/tui.go	/^	clicks       [][2]int$/;"	m	struct:tui.FullscreenRenderer	typeref:typename:[][2]int
closePlatform	src/tui/light_unix.go	/^func (r *LightRenderer) closePlatform() {$/;"	f	unknown:tui.LightRenderer
closePlatform	src/tui/light_windows.go	/^func (r *LightRenderer) closePlatform() {$/;"	f	unknown:tui.LightRenderer
cmd	src/terminal.go	/^	cmd       *exec.Cmd$/;"	m	struct:fzf.runningCmd	typeref:typename:*exec.Cmd
code	src/terminal.go	/^	code int$/;"	m	struct:fzf.quitSignal	typeref:typename:int
colBlack	src/tui/tui.go	/^	colBlack Color = iota$/;"	c	package:tui	typeref:type:Color
colBlue	src/tui/tui.go	/^	colBlue$/;"	c	package:tui
colBrightBlue	src/tui/tui.go	/^	colBrightBlue$/;"	c	package:tui
colBrightCyan	src/tui/tui.go	/^	colBrightCyan$/;"	c	package:tui
colBrightGreen	src/tui/tui.go	/^	colBrightGreen$/;"	c	package:tui
colBrightMagenta	src/tui/tui.go	/^	colBrightMagenta$/;"	c	package:tui
colBrightRed	src/tui/tui.go	/^	colBrightRed$/;"	c	package:tui
colBrightWhite	src/tui/tui.go	/^	colBrightWhite$/;"	c	package:tui
colBrightYellow	src/tui/tui.go	/^	colBrightYellow$/;"	c	package:tui
colCyan	src/tui/tui.go	/^	colCyan$/;"	c	package:tui
colDefault	src/tui/tui.go	/^	colDefault   Color = -1$/;"	c	package:tui	typeref:type:Color
colGreen	src/tui/tui.go	/^	colGreen$/;"	c	package:tui
colGrey	src/tui/tui.go	/^	colGrey$/;"	c	package:tui
colMagenta	src/tui/tui.go	/^	colMagenta$/;"	c	package:tui
colRed	src/tui/tui.go	/^	colRed$/;"	c	package:tui
colUndefined	src/tui/tui.go	/^	colUndefined Color = -2$/;"	c	package:tui	typeref:type:Color
colWhite	src/tui/tui.go	/^	colWhite$/;"	c	package:tui
colYellow	src/tui/tui.go	/^	colYellow$/;"	c	package:tui
color	src/ansi.go	/^	color  ansiState$/;"	m	struct:fzf.ansiOffset	typeref:typename:ansiState
color	src/result.go	/^	color  tui.ColorPair$/;"	m	struct:fzf.colorOffset	typeref:typename:tui.ColorPair
color	src/tui/tcell.go	/^	color         bool$/;"	m	struct:tui.TcellWindow	typeref:typename:bool
colorCodes	src/tui/light.go	/^func colorCodes(fg Color, bg Color) []string {$/;"	f	package:tui	typeref:typename:[]string
colorOffset	src/result.go	/^type colorOffset struct {$/;"	s	package:fzf
colorOffsets	src/result.go	/^func (result *Result) colorOffsets(matchOffsets []Offset, nthOffsets []Offset, theme *tui.ColorT/;"	f	struct:fzf.Result	typeref:typename:[]colorOffset
colored	src/ansi.go	/^func (s *ansiState) colored() bool {$/;"	f	struct:fzf.ansiState	typeref:typename:bool
colored	src/tui/light.go	/^	colored       bool$/;"	m	struct:tui.LightWindow	typeref:typename:bool
colors	src/item.go	/^	colors      *[]ansiOffset \/\/ 8$/;"	m	struct:fzf.Item	typeref:typename:*[]ansiOffset
column	src/options.go	/^	column int$/;"	m	struct:fzf.labelOpts	typeref:typename:int
command	src/options.go	/^	command     string$/;"	m	struct:fzf.previewOpts	typeref:typename:string
command	src/reader.go	/^	command  *string$/;"	m	struct:fzf.Reader	typeref:typename:*string
command	src/terminal.go	/^	command   string$/;"	m	struct:fzf.commandSpec	typeref:typename:string
command	src/terminal.go	/^	command  *commandSpec$/;"	m	struct:fzf.searchRequest	typeref:typename:*commandSpec
commandSpec	src/terminal.go	/^type commandSpec struct {$/;"	s	package:fzf
compare	src/options.go	/^func (o *previewOpts) compare(active *previewOpts, b *previewOpts) previewOptsCompare {$/;"	f	struct:fzf.previewOpts	typeref:typename:previewOptsCompare
compareRanges	src/tokenizer.go	/^func compareRanges(r1 []Range, r2 []Range) bool {$/;"	f	package:fzf	typeref:typename:bool
compareRanks	src/result_others.go	/^func compareRanks(irank Result, jrank Result, tac bool) bool {$/;"	f	package:fzf	typeref:typename:bool
compareRanks	src/result_x86.go	/^func compareRanks(irank Result, jrank Result, tac bool) bool {$/;"	f	package:fzf	typeref:typename:bool
compatible	src/core.go	/^func (r revision) compatible(other revision) bool {$/;"	f	struct:fzf.revision	typeref:typename:bool
cond	src/util/eventbox.go	/^	cond   *sync.Cond$/;"	m	struct:util.EventBox	typeref:typename:*sync.Cond
consoleFlagsInput	src/tui/light_windows.go	/^	consoleFlagsInput  = uint32(windows.ENABLE_VIRTUAL_TERMINAL_INPUT | windows.ENABLE_PROCESSED_IN/;"	v	package:tui
consoleFlagsOutput	src/tui/light_windows.go	/^	consoleFlagsOutput = uint32(windows.ENABLE_VIRTUAL_TERMINAL_PROCESSING | windows.ENABLE_PROCESS/;"	v	package:tui
constrain	src/terminal.go	/^func (t *Terminal) constrain() {$/;"	f	struct:fzf.Terminal
convertBoolToInt32	src/util/atomicbool.go	/^func convertBoolToInt32(b bool) int32 {$/;"	f	package:util	typeref:typename:int32
coordinatorDelayMax	src/constants.go	/^	coordinatorDelayMax  time.Duration = 100 * time.Millisecond$/;"	c	package:fzf	typeref:typename:time.Duration
coordinatorDelayStep	src/constants.go	/^	coordinatorDelayStep time.Duration = 10 * time.Millisecond$/;"	c	package:fzf	typeref:typename:time.Duration
copySlice	src/terminal.go	/^func copySlice(slice []rune) []rune {$/;"	f	package:fzf	typeref:typename:[]rune
count	src/chunklist.go	/^	count int$/;"	m	struct:fzf.Chunk	typeref:typename:int
count	src/merger.go	/^	count    int$/;"	m	struct:fzf.Merger	typeref:typename:int
count	src/terminal.go	/^	count              int$/;"	m	struct:fzf.Terminal	typeref:typename:int
counter	src/tui/light_windows.go	/^	counter            = uint64(0)$/;"	v	package:tui
counts	test/lib/common.rb	/^          def counts$/;"	f	method:Tmux.until
cprint2	src/tui/light.go	/^func (w *LightWindow) cprint2(fg Color, bg Color, attr Attr, text string) {$/;"	f	struct:tui.LightWindow
create_file	install	/^create_file() {$/;"	f
criterion	src/options.go	/^type criterion int$/;"	t	package:fzf	typeref:typename:int
crlf	src/server.go	/^	crlf             = "\\r\\n"$/;"	c	package:fzf
csi	src/tui/light.go	/^func (r *LightRenderer) csi(code string) string {$/;"	f	unknown:tui.LightRenderer	typeref:typename:string
csi	src/tui/light.go	/^func (w *LightWindow) csi(code string) string {$/;"	f	struct:tui.LightWindow	typeref:typename:string
csiColor	src/tui/light.go	/^func (w *LightWindow) csiColor(fg Color, bg Color, attr Attr) (bool, string) {$/;"	f	struct:tui.LightWindow	typeref:typename:(bool, string)
current	src/history.go	/^func (h *History) current() string {$/;"	f	struct:fzf.History	typeref:typename:string
current	src/terminal.go	/^	current   bool$/;"	m	struct:fzf.itemLine	typeref:typename:bool
currentIndex	src/terminal.go	/^func (t *Terminal) currentIndex() int32 {$/;"	f	struct:fzf.Terminal	typeref:typename:int32
currentItem	src/terminal.go	/^func (t *Terminal) currentItem() *Item {$/;"	f	struct:fzf.Terminal	typeref:typename:*Item
cursor	src/history.go	/^	cursor   int$/;"	m	struct:fzf.History	typeref:typename:int
cursors	src/merger.go	/^	cursors  []int$/;"	m	struct:fzf.Merger	typeref:typename:[]int
cx	src/terminal.go	/^	cx                 int$/;"	m	struct:fzf.Terminal	typeref:typename:int
cy	src/terminal.go	/^	cy                 int$/;"	m	struct:fzf.Terminal	typeref:typename:int
cy	src/terminal.go	/^	cy        int$/;"	m	struct:fzf.itemLine	typeref:typename:int
cycle	src/options.go	/^	cycle       bool$/;"	m	struct:fzf.previewOpts	typeref:typename:bool
cycle	src/terminal.go	/^	cycle              bool$/;"	m	struct:fzf.Terminal	typeref:typename:bool
debugV2	src/algo/algo.go	/^func debugV2(T []rune, pattern []rune, F []int32, lastIdx int, H []int16, C []int16) {$/;"	f	package:algo
defaultBorderShape	src/options.go	/^var defaultBorderShape tui.BorderShape = tui.DefaultBorderShape$/;"	v	package:fzf	typeref:typename:tui.BorderShape
defaultEscDelay	src/tui/light.go	/^	defaultEscDelay = 100$/;"	c	package:tui
defaultHeight	src/tui/light.go	/^	defaultHeight = 24$/;"	c	package:tui
defaultHistoryMax	src/constants.go	/^	defaultHistoryMax int = 1000$/;"	c	package:fzf	typeref:typename:int
defaultInfoPrefix	src/options.go	/^const defaultInfoPrefix = " < "$/;"	c	package:fzf
defaultJumpLabels	src/constants.go	/^	defaultJumpLabels string = "asdfghjklqwertyuiopzxcvbnm1234567890ASDFGHJKLQWERTYUIOPZXCVBNM`~;:,/;"	c	package:fzf	typeref:typename:string
defaultKeymap	src/terminal.go	/^func defaultKeymap() map[tui.Event][]*action {$/;"	f	package:fzf	typeref:typename:map[tui.Event][]*action
defaultListenAddr	src/server.go	/^var defaultListenAddr = listenAddress{"localhost", 0}$/;"	v	package:fzf
defaultMargin	src/options.go	/^func defaultMargin() [4]sizeSpec {$/;"	f	package:fzf	typeref:typename:[4]sizeSpec
defaultOptions	src/options.go	/^func defaultOptions() *Options {$/;"	f	package:fzf	typeref:typename:*Options
defaultPreviewOpts	src/options.go	/^func defaultPreviewOpts(command string) previewOpts {$/;"	f	package:fzf	typeref:typename:previewOpts
defaultTmuxOptions	src/options.go	/^func defaultTmuxOptions(index int) *tmuxOptions {$/;"	f	package:fzf	typeref:typename:*tmuxOptions
defaultWidth	src/tui/light.go	/^	defaultWidth  = 80$/;"	c	package:tui
deferActivation	src/terminal.go	/^func (t *Terminal) deferActivation() bool {$/;"	f	struct:fzf.Terminal	typeref:typename:bool
delChar	src/terminal.go	/^func (t *Terminal) delChar() bool {$/;"	f	struct:fzf.Terminal	typeref:typename:bool
delimNil	src/reader.go	/^	delimNil bool$/;"	m	struct:fzf.Reader	typeref:typename:bool
delimiter	src/pattern.go	/^	delimiter     Delimiter$/;"	m	struct:fzf.Pattern	typeref:typename:Delimiter
delimiter	src/terminal.go	/^	delimiter          Delimiter$/;"	m	struct:fzf.Terminal	typeref:typename:Delimiter
delimiter	src/terminal.go	/^	delimiter  Delimiter$/;"	m	struct:fzf.replacePlaceholderParams	typeref:typename:Delimiter
delimiterChars	src/algo/algo.go	/^var delimiterChars = "\/,:;|"$/;"	v	package:algo
delimiterRegexp	src/options.go	/^func delimiterRegexp(str string) Delimiter {$/;"	f	package:fzf	typeref:typename:Delimiter
denylist	src/pattern.go	/^	denylist      map[int32]struct{}$/;"	m	struct:fzf.Pattern	typeref:typename:map[int32]struct{}
denylist	src/terminal.go	/^	denylist []int32$/;"	m	struct:fzf.searchRequest	typeref:typename:[]int32
deselectItem	src/terminal.go	/^func (t *Terminal) deselectItem(item *Item) {$/;"	f	struct:fzf.Terminal
deselectItemChanged	src/terminal.go	/^func (t *Terminal) deselectItemChanged(item *Item) bool {$/;"	f	struct:fzf.Terminal	typeref:typename:bool
determineHeaderLinesShape	src/terminal.go	/^func (t *Terminal) determineHeaderLinesShape() (bool, tui.BorderShape) {$/;"	f	struct:fzf.Terminal	typeref:typename:(bool, tui.BorderShape)
devPrefixes	src/tui/ttyname_unix.go	/^var devPrefixes = [...]string{"\/dev\/pts\/", "\/dev\/"}$/;"	v	package:tui
dir	src/options.go	/^	dir    bool$/;"	m	struct:fzf.walkerOpts	typeref:typename:bool
disableModes	src/tui/light.go	/^func (r *LightRenderer) disableModes() {$/;"	f	struct:tui.LightRenderer
disableMouse	src/tui/light.go	/^func (r *LightRenderer) disableMouse() {$/;"	f	struct:tui.LightRenderer
disabledState	src/terminal.go	/^	disabledState resumableState = iota$/;"	c	package:fzf	typeref:type:resumableState
dispatchAsync	src/terminal.go	/^func (t *Terminal) dispatchAsync() {$/;"	f	struct:fzf.Terminal
displayWidth	src/terminal.go	/^func (t *Terminal) displayWidth(runes []rune) int {$/;"	f	struct:fzf.Terminal	typeref:typename:int
displayWidth	src/tui/light.go	/^	displayWidth int$/;"	m	struct:tui.wrappedLine	typeref:typename:int
displayWidthWithLimit	src/terminal.go	/^func (t *Terminal) displayWidthWithLimit(runes []rune, prefixWidth int, limit int) int {$/;"	f	struct:fzf.Terminal	typeref:typename:int
displayWidthWithPrefix	src/terminal.go	/^func (t *Terminal) displayWidthWithPrefix(str string, prefixWidth int) int {$/;"	f	struct:fzf.Terminal	typeref:typename:int
docker	Makefile	/^docker:$/;"	t
docker-test	Makefile	/^docker-test:$/;"	t
doubleClickDuration	src/tui/tui.go	/^	doubleClickDuration = 500 * time.Millisecond$/;"	c	package:tui
download	install	/^download() {$/;"	f
download	install.ps1	/^function download {$/;"	f
drawBorder	src/tui/light.go	/^func (w *LightWindow) drawBorder(onlyHorizontal bool) {$/;"	f	struct:tui.LightWindow
drawBorder	src/tui/tcell.go	/^func (w *TcellWindow) drawBorder(onlyHorizontal bool) {$/;"	f	struct:tui.TcellWindow
drawBorderAround	src/tui/light.go	/^func (w *LightWindow) drawBorderAround(onlyHorizontal bool) {$/;"	f	struct:tui.LightWindow
drawBorderHorizontal	src/tui/light.go	/^func (w *LightWindow) drawBorderHorizontal(top, bottom bool) {$/;"	f	struct:tui.LightWindow
drawBorderVertical	src/tui/light.go	/^func (w *LightWindow) drawBorderVertical(left, right bool) {$/;"	f	struct:tui.LightWindow
dumpItem	src/terminal.go	/^func (t *Terminal) dumpItem(i *Item) StatusItem {$/;"	f	struct:fzf.Terminal	typeref:typename:StatusItem
dumpStatus	src/terminal.go	/^func (t *Terminal) dumpStatus(params getParams) string {$/;"	f	struct:fzf.Terminal	typeref:typename:string
dupeTheme	src/options.go	/^func dupeTheme(theme *tui.ColorTheme) *tui.ColorTheme {$/;"	f	package:fzf	typeref:typename:*tui.ColorTheme
eachLine	src/terminal.go	/^type eachLine struct {$/;"	s	package:fzf
ellipsis	src/terminal.go	/^	ellipsis           string$/;"	m	struct:fzf.Terminal	typeref:typename:string
empty	src/terminal.go	/^	empty     bool$/;"	m	struct:fzf.itemLine	typeref:typename:bool
enableModes	src/tui/light.go	/^func (r *LightRenderer) enableModes() {$/;"	f	struct:tui.LightRenderer
enabledState	src/terminal.go	/^	enabledState$/;"	c	package:fzf
encodePlaceholder	src/terminal_test.go	/^func (flags placeholderFlags) encodePlaceholder() string {$/;"	f	unknown:fzf.placeholderFlags	typeref:typename:string
end	src/tokenizer.go	/^	end   int$/;"	m	struct:fzf.Range	typeref:typename:int
env	src/terminal.go	/^	env          []string$/;"	m	struct:fzf.previewRequest	typeref:typename:[]string
env_vars	test/test_core.rb	/^    def env_vars$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform.test_env_vars
environ	src/terminal.go	/^	environ  []string$/;"	m	struct:fzf.searchRequest	typeref:typename:[]string
environ	src/terminal.go	/^func (t *Terminal) environ() []string {$/;"	f	struct:fzf.Terminal	typeref:typename:[]string
environForPreview	src/terminal.go	/^func (t *Terminal) environForPreview() []string {$/;"	f	struct:fzf.Terminal	typeref:typename:[]string
environImpl	src/terminal.go	/^func (t *Terminal) environImpl(forPreview bool) []string {$/;"	f	struct:fzf.Terminal	typeref:typename:[]string
equals	src/ansi.go	/^func (s *ansiState) equals(t *ansiState) bool {$/;"	f	struct:fzf.ansiState	typeref:typename:bool
err	src/terminal.go	/^	err  error$/;"	m	struct:fzf.eachLine	typeref:typename:error
err	src/terminal.go	/^	err  error$/;"	m	struct:fzf.quitSignal	typeref:typename:error
escDelay	src/tui/light.go	/^	escDelay      int$/;"	m	struct:tui.LightRenderer	typeref:typename:int
escPollInterval	src/tui/light.go	/^	escPollInterval = 5$/;"	c	package:tui
escSequence	src/tui/light.go	/^func (r *LightRenderer) escSequence(sz *int) Event {$/;"	f	struct:tui.LightRenderer	typeref:typename:Event
escapeArg	src/util/util_windows.go	/^func escapeArg(s string) string {$/;"	f	package:util	typeref:typename:string
escapeRegex	src/util/util_windows.go	/^var escapeRegex = regexp.MustCompile(`[&|<>()^%!"]`)$/;"	v	package:util
escapeSingleQuote	src/proxy.go	/^func escapeSingleQuote(str string) string {$/;"	f	package:fzf	typeref:typename:string
escapedColon	src/options.go	/^	escapedColon = 0$/;"	c	package:fzf
escapedComma	src/options.go	/^	escapedComma = 1$/;"	c	package:fzf
escapedPlus	src/options.go	/^	escapedPlus  = 2$/;"	c	package:fzf
escaper	src/util/util_unix.go	/^	escaper *strings.Replacer$/;"	m	struct:util.Executor	typeref:typename:*strings.Replacer
evaluateHeight	src/terminal.go	/^func evaluateHeight(opts *Options, termHeight int) int {$/;"	f	package:fzf	typeref:typename:int
evaluateScrollOffset	src/terminal.go	/^func (t *Terminal) evaluateScrollOffset() int {$/;"	f	struct:fzf.Terminal	typeref:typename:int
event	src/reader.go	/^	event    int32$/;"	m	struct:fzf.Reader	typeref:typename:int32
eventBox	src/matcher.go	/^	eventBox       *util.EventBox$/;"	m	struct:fzf.Matcher	typeref:typename:*util.EventBox
eventBox	src/reader.go	/^	eventBox *util.EventBox$/;"	m	struct:fzf.Reader	typeref:typename:*util.EventBox
eventBox	src/terminal.go	/^	eventBox           *util.EventBox$/;"	m	struct:fzf.Terminal	typeref:typename:*util.EventBox
eventChan	src/terminal.go	/^	eventChan          chan tui.Event$/;"	m	struct:fzf.Terminal	typeref:typename:chan tui.Event
events	src/util/eventbox.go	/^	events Events$/;"	m	struct:util.EventBox	typeref:typename:Events
exactMatchNaive	src/algo/algo.go	/^func exactMatchNaive(caseSensitive bool, normalize bool, forward bool, boundaryCheck bool, text /;"	f	package:algo	typeref:typename:(Result, *[]int)
executeCommand	src/terminal.go	/^func (t *Terminal) executeCommand(template string, forcePlus bool, background bool, capture bool/;"	f	struct:fzf.Terminal	typeref:typename:string
executeRegexp	src/options.go	/^	executeRegexp    *regexp.Regexp$/;"	v	package:fzf	typeref:typename:*regexp.Regexp
executing	src/terminal.go	/^	executing          *util.AtomicBool$/;"	m	struct:fzf.Terminal	typeref:typename:*util.AtomicBool
executor	src/reader.go	/^	executor *util.Executor$/;"	m	struct:fzf.Reader	typeref:typename:*util.Executor
executor	src/terminal.go	/^	executor           *util.Executor$/;"	m	struct:fzf.Terminal	typeref:typename:*util.Executor
executor	src/terminal.go	/^	executor   *util.Executor$/;"	m	struct:fzf.replacePlaceholderParams	typeref:typename:*util.Executor
exit	main.go	/^func exit(code int, err error) {$/;"	f	package:main
expect	src/terminal.go	/^	expect             map[tui.Event]string$/;"	m	struct:fzf.Terminal	typeref:typename:map[tui.Event]string
extended	src/pattern.go	/^	extended      bool$/;"	m	struct:fzf.Pattern	typeref:typename:bool
extendedMatch	src/pattern.go	/^func (p *Pattern) extendedMatch(item *Item, withPos bool, slab *util.Slab) ([]Offset, int, *[]in/;"	f	struct:fzf.Pattern	typeref:typename:([]Offset, int, *[]int)
extraLines	src/terminal.go	/^func (t *Terminal) extraLines() int {$/;"	f	struct:fzf.Terminal	typeref:typename:int
extractColor	src/ansi.go	/^func extractColor(str string, state *ansiState, proc func(string, *ansiState) bool) (string, *[]/;"	f	package:fzf	typeref:typename:(string, *[]ansiOffset, *ansiState)
extractPassThroughs	src/terminal.go	/^func extractPassThroughs(line string) ([]string, string) {$/;"	f	package:fzf	typeref:typename:([]string, string)
extractReloadOnStart	src/options.go	/^func (opts *Options) extractReloadOnStart() string {$/;"	f	struct:fzf.Options	typeref:typename:string
fail	bin/fzf-tmux	/^fail() {$/;"	f
failed	src/terminal.go	/^	failed             *string$/;"	m	struct:fzf.Terminal	typeref:typename:*string
fd	src/tui/light_unix.go	/^func (r *LightRenderer) fd() int {$/;"	f	unknown:tui.LightRenderer	typeref:typename:int
feed	src/reader.go	/^func (r *Reader) feed(src io.Reader) {$/;"	f	struct:fzf.Reader
fg	src/ansi.go	/^	fg   tui.Color$/;"	m	struct:fzf.ansiState	typeref:typename:tui.Color
fg	src/tui/light.go	/^	fg            Color$/;"	m	struct:tui.LightWindow	typeref:typename:Color
fg	src/tui/tui.go	/^	fg   Color$/;"	m	struct:tui.ColorPair	typeref:typename:Color
fifo	src/proxy.go	/^func fifo(name string) (string, error) {$/;"	f	package:fzf	typeref:typename:(string, error)
file	src/options.go	/^	file   bool$/;"	m	struct:fzf.walkerOpts	typeref:typename:bool
file	src/terminal.go	/^	file          bool$/;"	m	struct:fzf.placeholderFlags	typeref:typename:bool
fill	src/tui/light.go	/^func (w *LightWindow) fill(str string, resetCode string) FillReturn {$/;"	f	struct:tui.LightWindow	typeref:typename:FillReturn
fill	src/tui/tcell.go	/^func fill(x, y, w, h int, n ColorPair, r rune) {$/;"	f	package:tui
fillString	src/tui/tcell.go	/^func (w *TcellWindow) fillString(text string, pair ColorPair) FillReturn {$/;"	f	struct:tui.TcellWindow	typeref:typename:FillReturn
filled	src/terminal.go	/^	filled    bool$/;"	m	struct:fzf.previewed	typeref:typename:bool
filterNonEmpty	src/options.go	/^func filterNonEmpty(input []string) []string {$/;"	f	package:fzf	typeref:typename:[]string
fin	src/reader.go	/^func (r *Reader) fin(success bool) {$/;"	f	struct:fzf.Reader
finChan	src/reader.go	/^	finChan  chan bool$/;"	m	struct:fzf.Reader	typeref:typename:chan bool
final	src/matcher.go	/^	final    bool$/;"	m	struct:fzf.MatchRequest	typeref:typename:bool
final	src/merger.go	/^	final    bool$/;"	m	struct:fzf.Merger	typeref:typename:bool
final	src/terminal.go	/^	final      bool$/;"	m	struct:fzf.previewer	typeref:typename:bool
findFirstMatch	src/terminal.go	/^func findFirstMatch(pattern string, str string) int {$/;"	f	package:fzf	typeref:typename:int
findLastMatch	src/terminal.go	/^func findLastMatch(pattern string, str string) int {$/;"	f	package:fzf	typeref:typename:int
findOffset	src/tui/light_unix.go	/^func (r *LightRenderer) findOffset() (row int, col int) {$/;"	f	unknown:tui.LightRenderer	typeref:typename:(row int, col int)
findOffset	src/tui/light_windows.go	/^func (r *LightRenderer) findOffset() (row int, col int) {$/;"	f	unknown:tui.LightRenderer	typeref:typename:(row int, col int)
findPassThrough	src/terminal.go	/^func findPassThrough(line string) []int {$/;"	f	package:fzf	typeref:typename:[]int
firstKey	src/options.go	/^func firstKey(keymap map[tui.Event]string) tui.Event {$/;"	f	package:fzf	typeref:typename:tui.Event
firstLine	src/options.go	/^func firstLine(s string) string {$/;"	f	package:fzf	typeref:typename:string
firstLine	src/terminal.go	/^	firstLine int$/;"	m	struct:fzf.itemLine	typeref:typename:int
fish	test/lib/common.rb	/^    def fish$/;"	S	class:Shell
fishKeyBindings	main.go	/^var fishKeyBindings []byte$/;"	v	package:main	typeref:typename:[]byte
fit	src/terminal.go	/^	fit int$/;"	m	struct:fzf.fitpad	typeref:typename:int
fitpad	src/terminal.go	/^type fitpad struct {$/;"	s	package:fzf
flush	src/terminal.go	/^func (t *Terminal) flush() {$/;"	f	struct:fzf.Terminal
flush	src/tui/light.go	/^func (r *LightRenderer) flush() {$/;"	f	unknown:tui.LightRenderer
flushRaw	src/tui/light.go	/^func (r *LightRenderer) flushRaw(sequence string) {$/;"	f	unknown:tui.LightRenderer
fmt	Makefile	/^fmt: $(SOURCES) $(BASH_SCRIPTS)$/;"	t
fmt	shell/update.sh	/^fmt() {$/;"	f
focus	test/lib/common.rb	/^  def focus$/;"	f	class:Tmux
follow	src/options.go	/^	follow      bool$/;"	m	struct:fzf.previewOpts	typeref:typename:bool
follow	src/options.go	/^	follow bool$/;"	m	struct:fzf.walkerOpts	typeref:typename:bool
following	src/terminal.go	/^	following  resumableState$/;"	m	struct:fzf.previewer	typeref:typename:resumableState
footer	src/terminal.go	/^	footer             []string$/;"	m	struct:fzf.Terminal	typeref:typename:[]string
footerBorder	src/terminal.go	/^	footerBorder       tui.Window$/;"	m	struct:fzf.Terminal	typeref:typename:tui.Window
footerBorderShape	src/terminal.go	/^	footerBorderShape  tui.BorderShape$/;"	m	struct:fzf.Terminal	typeref:typename:tui.BorderShape
footerLabel	src/terminal.go	/^	footerLabel        labelPrinter$/;"	m	struct:fzf.Terminal	typeref:typename:labelPrinter
footerLabelLen	src/terminal.go	/^	footerLabelLen     int$/;"	m	struct:fzf.Terminal	typeref:typename:int
footerLabelOpts	src/terminal.go	/^	footerLabelOpts    labelOpts$/;"	m	struct:fzf.Terminal	typeref:typename:labelOpts
footerWindow	src/terminal.go	/^	footerWindow       tui.Window$/;"	m	struct:fzf.Terminal	typeref:typename:tui.Window
forceBlack	src/tui/light.go	/^	forceBlack    bool$/;"	m	struct:tui.LightRenderer	typeref:typename:bool
forceBlack	src/tui/tui.go	/^	forceBlack   bool$/;"	m	struct:tui.FullscreenRenderer	typeref:typename:bool
forcePlus	src/terminal.go	/^	forcePlus  bool$/;"	m	struct:fzf.replacePlaceholderParams	typeref:typename:bool
forcePreview	src/terminal.go	/^	forcePreview       bool$/;"	m	struct:fzf.Terminal	typeref:typename:bool
forceRerenderList	src/terminal.go	/^func (t *Terminal) forceRerenderList() {$/;"	f	struct:fzf.Terminal
forceUpdate	src/terminal.go	/^	forceUpdate   bool$/;"	m	struct:fzf.placeholderFlags	typeref:typename:bool
forward	src/pattern.go	/^	forward       bool$/;"	m	struct:fzf.Pattern	typeref:typename:bool
fullRedraw	src/terminal.go	/^func (t *Terminal) fullRedraw() {$/;"	f	struct:fzf.Terminal
fullscreen	src/terminal.go	/^	fullscreen         bool$/;"	m	struct:fzf.Terminal	typeref:typename:bool
fullscreen	src/tui/light.go	/^	fullscreen    bool$/;"	m	struct:tui.LightRenderer	typeref:typename:bool
fuzzy	src/pattern.go	/^	fuzzy         bool$/;"	m	struct:fzf.Pattern	typeref:typename:bool
fuzzyAlgo	src/pattern.go	/^	fuzzyAlgo     algo.Algo$/;"	m	struct:fzf.Pattern	typeref:typename:algo.Algo
fzf	main.go	/^	fzf "github.com\/junegunn\/fzf\/src"$/;"	P	package:github.com/junegunn/fzf/src
fzf	man/man1/fzf.1	/^.TH fzf 1 "Sep 2025" "fzf 0.66.0" "fzf - a command-line fuzzy finder"$/;"	t
fzf	src/actiontype_string.go	/^package fzf$/;"	p
fzf	src/ansi.go	/^package fzf$/;"	p
fzf	src/ansi_test.go	/^package fzf$/;"	p
fzf	src/cache.go	/^package fzf$/;"	p
fzf	src/cache_test.go	/^package fzf$/;"	p
fzf	src/chunklist.go	/^package fzf$/;"	p
fzf	src/chunklist_test.go	/^package fzf$/;"	p
fzf	src/constants.go	/^package fzf$/;"	p
fzf	src/core.go	/^package fzf$/;"	p
fzf	src/functions.go	/^package fzf$/;"	p
fzf	src/history.go	/^package fzf$/;"	p
fzf	src/history_test.go	/^package fzf$/;"	p
fzf	src/item.go	/^package fzf$/;"	p
fzf	src/item_test.go	/^package fzf$/;"	p
fzf	src/matcher.go	/^package fzf$/;"	p
fzf	src/merger.go	/^package fzf$/;"	p
fzf	src/merger_test.go	/^package fzf$/;"	p
fzf	src/options.go	/^package fzf$/;"	p
fzf	src/options_no_pprof.go	/^package fzf$/;"	p
fzf	src/options_pprof.go	/^package fzf$/;"	p
fzf	src/options_pprof_test.go	/^package fzf$/;"	p
fzf	src/options_test.go	/^package fzf$/;"	p
fzf	src/pattern.go	/^package fzf$/;"	p
fzf	src/pattern_test.go	/^package fzf$/;"	p
fzf	src/proxy.go	/^package fzf$/;"	p
fzf	src/proxy_unix.go	/^package fzf$/;"	p
fzf	src/proxy_windows.go	/^package fzf$/;"	p
fzf	src/reader.go	/^package fzf$/;"	p
fzf	src/reader_test.go	/^package fzf$/;"	p
fzf	src/result.go	/^package fzf$/;"	p
fzf	src/result_others.go	/^package fzf$/;"	p
fzf	src/result_test.go	/^package fzf$/;"	p
fzf	src/result_x86.go	/^package fzf$/;"	p
fzf	src/server.go	/^package fzf$/;"	p
fzf	src/terminal.go	/^package fzf$/;"	p
fzf	src/terminal_test.go	/^package fzf$/;"	p
fzf	src/terminal_unix.go	/^package fzf$/;"	p
fzf	src/terminal_windows.go	/^package fzf$/;"	p
fzf	src/tmux.go	/^package fzf$/;"	p
fzf	src/tokenizer.go	/^package fzf$/;"	p
fzf	src/tokenizer_test.go	/^package fzf$/;"	p
fzf	src/winpty.go	/^package fzf$/;"	p
fzf	src/winpty_windows.go	/^package fzf$/;"	p
fzf	test/lib/common.rb	/^  def fzf(*opts)$/;"	f	class:TestBase
fzf Theme Playground	README.md	/^### fzf Theme Playground$/;"	S	section:Tips
fzf inside terminal buffer	README-VIM.md	/^### fzf inside terminal buffer$/;"	S	section:FZF Vim integration""Tips
fzf!	test/lib/common.rb	/^  def fzf!(*opts)$/;"	f	class:TestBase
fzf#exec	plugin/fzf.vim	/^function! fzf#exec(...)$/;"	f
fzf#install	plugin/fzf.vim	/^function! fzf#install()$/;"	f
fzf#run	plugin/fzf.vim	/^function! fzf#run(...) abort$/;"	f
fzf#shellescape	plugin/fzf.vim	/^function! fzf#shellescape(arg, ...)$/;"	f
fzf#wrap	plugin/fzf.vim	/^function! fzf#wrap(...)$/;"	f
fzf-cd-widget	shell/key-bindings.zsh	/^fzf-cd-widget() {$/;"	f
fzf-completion	shell/completion.zsh	/^fzf-completion() {$/;"	f
fzf-file-widget	shell/key-bindings.bash	/^fzf-file-widget() {$/;"	f
fzf-file-widget	shell/key-bindings.zsh	/^fzf-file-widget() {$/;"	f
fzf-history-widget	shell/key-bindings.zsh	/^fzf-history-widget() {$/;"	f
fzf.on_exit	plugin/fzf.vim	/^      function! fzf.on_exit(job_id, exit_status, event) dict$/;"	f	function:s:execute
fzf.on_exit	plugin/fzf.vim	/^  function! fzf.on_exit(id, code, ...)$/;"	f	function:s:execute_term
fzf.switch_back	plugin/fzf.vim	/^  function! fzf.switch_back(inplace)$/;"	f	function:s:execute_term
fzf\\-tmux	man/man1/fzf-tmux.1	/^.TH fzf\\-tmux 1 "Aug 2025" "fzf 0.65.2" "fzf\\-tmux - open fzf in tmux split pane"$/;"	t
fzf_base	install.ps1	/^$fzf_base=Split-Path -Parent $MyInvocation.MyCommand.Definition$/;"	v
fzf_output	test/lib/common.rb	/^  def fzf_output$/;"	f	class:TestBase
fzf_output_lines	test/lib/common.rb	/^  def fzf_output_lines$/;"	f	class:TestBase
fzf_popd	plugin/fzf.vim	/^augroup fzf_popd$/;"	a
fzf_swap	plugin/fzf.vim	/^    augroup fzf_swap$/;"	a
g:loaded_fzf	plugin/fzf.vim	/^let g:loaded_fzf = 1$/;"	v
gap	src/terminal.go	/^	gap                int$/;"	m	struct:fzf.Terminal	typeref:typename:int
gapLine	src/terminal.go	/^	gapLine            labelPrinter$/;"	m	struct:fzf.Terminal	typeref:typename:labelPrinter
gapLineLen	src/terminal.go	/^	gapLineLen         int$/;"	m	struct:fzf.Terminal	typeref:typename:int
generate	Makefile	/^generate:$/;"	t
getBytes	src/tui/light.go	/^func (r *LightRenderer) getBytes() ([]byte, error) {$/;"	f	struct:tui.LightRenderer	typeref:typename:([]byte, error)
getBytesInternal	src/tui/light.go	/^func (r *LightRenderer) getBytesInternal(buffer []byte, nonblock bool) ([]byte, error) {$/;"	f	struct:tui.LightRenderer	typeref:typename:([]byte, error)
getEnv	src/tui/light.go	/^func getEnv(name string, defaultValue int) int {$/;"	f	package:tui	typeref:typename:int
getHandler	src/server.go	/^	getHandler    func(getParams) string$/;"	m	struct:fzf.httpServer	typeref:typename:func(getParams) string
getParams	src/server.go	/^type getParams struct {$/;"	s	package:fzf
getRegex	src/server.go	/^var getRegex *regexp.Regexp$/;"	v	package:fzf	typeref:typename:*regexp.Regexp
getScreen	src/tui/tcell.go	/^func (r *FullscreenRenderer) getScreen() (tcell.Screen, error) {$/;"	f	unknown:tui.FullscreenRenderer	typeref:typename:(tcell.Screen, error)
getScrollbar	src/terminal.go	/^func (t *Terminal) getScrollbar() (int, int) {$/;"	f	struct:fzf.Terminal	typeref:typename:(int, int)
getScrollbar	src/terminal.go	/^func getScrollbar(perLine int, total int, height int, offset int) (int, int) {$/;"	f	package:fzf	typeref:typename:(int, int)
getch	src/tui/light_unix.go	/^func (r *LightRenderer) getch(nonblock bool) (int, bool) {$/;"	f	unknown:tui.LightRenderer	typeref:typename:(int, bool)
getch	src/tui/light_windows.go	/^func (r *LightRenderer) getch(nonblock bool) (int, bool) {$/;"	f	unknown:tui.LightRenderer	typeref:typename:(int, bool)
ghost	src/terminal.go	/^	ghost              string$/;"	m	struct:fzf.Terminal	typeref:typename:string
give	src/terminal_test.go	/^	give$/;"	M	struct:fzf.testCase	typeref:typename:give
give	src/terminal_test.go	/^type give struct {$/;"	s	package:fzf
go	test/lib/common.rb	/^  def go(args)$/;"	f	class:Tmux
gutter	src/terminal.go	/^func (t *Terminal) gutter(current bool) {$/;"	f	struct:fzf.Terminal
gutterReverse	src/terminal.go	/^	gutterReverse      bool$/;"	m	struct:fzf.Terminal	typeref:typename:bool
handleHttpRequest	src/server.go	/^func (server *httpServer) handleHttpRequest(conn net.Conn) string {$/;"	f	struct:fzf.httpServer	typeref:typename:string
hasBar	src/terminal.go	/^	hasBar    bool$/;"	m	struct:fzf.itemLine	typeref:typename:bool
hasFocusActions	src/terminal.go	/^	hasFocusActions    bool$/;"	m	struct:fzf.Terminal	typeref:typename:bool
hasHeaderLinesWindow	src/terminal.go	/^func (t *Terminal) hasHeaderLinesWindow() bool {$/;"	f	struct:fzf.Terminal	typeref:typename:bool
hasHeaderWindow	src/terminal.go	/^func (t *Terminal) hasHeaderWindow() bool {$/;"	f	struct:fzf.Terminal	typeref:typename:bool
hasLoadActions	src/terminal.go	/^	hasLoadActions     bool$/;"	m	struct:fzf.Terminal	typeref:typename:bool
hasPreviewFlags	src/terminal.go	/^func hasPreviewFlags(template string) (slot bool, plus bool, asterisk bool, forceUpdate bool) {$/;"	f	package:fzf	typeref:typename:(slot bool, plus bool, asterisk bool, forceUpdate bool)
hasPreviewWindow	src/terminal.go	/^func (t *Terminal) hasPreviewWindow() bool {$/;"	f	struct:fzf.Terminal	typeref:typename:bool
hasPreviewWindowOnRight	src/terminal.go	/^func (t *Terminal) hasPreviewWindowOnRight() bool {$/;"	f	struct:fzf.Terminal	typeref:typename:bool
hasPreviewer	src/terminal.go	/^func (t *Terminal) hasPreviewer() bool {$/;"	f	struct:fzf.Terminal	typeref:typename:bool
hasReloadOrTransformOnStart	src/options.go	/^func (opts *Options) hasReloadOrTransformOnStart() bool {$/;"	f	struct:fzf.Options	typeref:typename:bool
hasResizeActions	src/terminal.go	/^	hasResizeActions   bool$/;"	m	struct:fzf.Terminal	typeref:typename:bool
hasResultActions	src/terminal.go	/^	hasResultActions   bool$/;"	m	struct:fzf.Terminal	typeref:typename:bool
hasStartActions	src/terminal.go	/^	hasStartActions    bool$/;"	m	struct:fzf.Terminal	typeref:typename:bool
header	src/terminal.go	/^	header             []string$/;"	m	struct:fzf.Terminal	typeref:typename:[]string
header0	src/terminal.go	/^	header0            []string$/;"	m	struct:fzf.Terminal	typeref:typename:[]string
headerBorder	src/terminal.go	/^	headerBorder       tui.Window$/;"	m	struct:fzf.Terminal	typeref:typename:tui.Window
headerBorderShape	src/terminal.go	/^	headerBorderShape  tui.BorderShape$/;"	m	struct:fzf.Terminal	typeref:typename:tui.BorderShape
headerFirst	src/terminal.go	/^	headerFirst        bool$/;"	m	struct:fzf.Terminal	typeref:typename:bool
headerIndent	src/terminal.go	/^func (t *Terminal) headerIndent(borderShape tui.BorderShape) int {$/;"	f	struct:fzf.Terminal	typeref:typename:int
headerLabel	src/terminal.go	/^	headerLabel        labelPrinter$/;"	m	struct:fzf.Terminal	typeref:typename:labelPrinter
headerLabelLen	src/terminal.go	/^	headerLabelLen     int$/;"	m	struct:fzf.Terminal	typeref:typename:int
headerLabelOpts	src/terminal.go	/^	headerLabelOpts    labelOpts$/;"	m	struct:fzf.Terminal	typeref:typename:labelOpts
headerLines	src/options.go	/^	headerLines int$/;"	m	struct:fzf.previewOpts	typeref:typename:int
headerLines	src/terminal.go	/^	headerLines        int$/;"	m	struct:fzf.Terminal	typeref:typename:int
headerLinesBorder	src/terminal.go	/^	headerLinesBorder  tui.Window$/;"	m	struct:fzf.Terminal	typeref:typename:tui.Window
headerLinesShape	src/terminal.go	/^	headerLinesShape   tui.BorderShape$/;"	m	struct:fzf.Terminal	typeref:typename:tui.BorderShape
headerLinesWindow	src/terminal.go	/^	headerLinesWindow  tui.Window$/;"	m	struct:fzf.Terminal	typeref:typename:tui.Window
headerVisible	src/terminal.go	/^	headerVisible      bool$/;"	m	struct:fzf.Terminal	typeref:typename:bool
headerWindow	src/terminal.go	/^	headerWindow       tui.Window$/;"	m	struct:fzf.Terminal	typeref:typename:tui.Window
height	src/options.go	/^	height   sizeSpec$/;"	m	struct:fzf.tmuxOptions	typeref:typename:sizeSpec
height	src/tui/light.go	/^	height        int$/;"	m	struct:tui.LightRenderer	typeref:typename:int
height	src/tui/light.go	/^	height        int$/;"	m	struct:tui.LightWindow	typeref:typename:int
height	src/tui/tcell.go	/^	height        int$/;"	m	struct:tui.TcellWindow	typeref:typename:int
heightSpec	src/options.go	/^type heightSpec struct {$/;"	s	package:fzf
help	bin/fzf-tmux	/^help() {$/;"	f
help	install	/^help() {$/;"	f
help	uninstall	/^help() {$/;"	f
hidden	src/options.go	/^	hidden      bool$/;"	m	struct:fzf.previewOpts	typeref:typename:bool
hidden	src/options.go	/^	hidden bool$/;"	m	struct:fzf.walkerOpts	typeref:typename:bool
highlightLine	src/terminal.go	/^	highlightLine      bool$/;"	m	struct:fzf.Terminal	typeref:typename:bool
history	src/terminal.go	/^	history            *History$/;"	m	struct:fzf.Terminal	typeref:typename:*History
host	src/server.go	/^	host string$/;"	m	struct:fzf.listenAddress	typeref:typename:string
hscroll	src/terminal.go	/^	hscroll            bool$/;"	m	struct:fzf.Terminal	typeref:typename:bool
hscrollOff	src/terminal.go	/^	hscrollOff         int$/;"	m	struct:fzf.Terminal	typeref:typename:int
httpBadRequest	src/server.go	/^	httpBadRequest   = "HTTP\/1.1 400 Bad Request" + crlf$/;"	c	package:fzf
httpOk	src/server.go	/^	httpOk           = "HTTP\/1.1 200 OK" + crlf$/;"	c	package:fzf
httpReadTimeout	src/server.go	/^	httpReadTimeout  = 10 * time.Second$/;"	c	package:fzf
httpServer	src/server.go	/^type httpServer struct {$/;"	s	package:fzf
httpUnauthorized	src/server.go	/^	httpUnauthorized = "HTTP\/1.1 401 Unauthorized" + crlf$/;"	c	package:fzf
httpUnavailable	src/server.go	/^	httpUnavailable  = "HTTP\/1.1 503 Service Unavailable" + crlf$/;"	c	package:fzf
ignore	src/util/eventbox.go	/^	ignore map[EventType]bool$/;"	m	struct:util.EventBox	typeref:typename:map[EventType]bool
image	src/terminal.go	/^	image     bool$/;"	m	struct:fzf.previewed	typeref:typename:bool
inBytes	src/util/chars.go	/^	inBytes         bool$/;"	m	struct:util.Chars	typeref:typename:bool
inHandle	src/tui/light.go	/^	inHandle        uintptr$/;"	m	struct:tui.LightRenderer	typeref:typename:uintptr
inListWindow	src/terminal.go	/^func (t *Terminal) inListWindow() bool {$/;"	f	unknown:fzf.Terminal	typeref:typename:bool
index	src/matcher.go	/^	index   int$/;"	m	struct:fzf.partialResult	typeref:typename:int
index	src/options.go	/^	index    int$/;"	m	struct:fzf.tmuxOptions	typeref:typename:int
index	src/options.go	/^	index   int$/;"	m	struct:fzf.heightSpec	typeref:typename:int
indexAt	src/algo/algo.go	/^func indexAt(index int, max int, forward bool) int {$/;"	f	package:algo	typeref:typename:int
info	src/options.go	/^	info        bool$/;"	m	struct:fzf.previewOpts	typeref:typename:bool
infoCommand	src/terminal.go	/^	infoCommand        string$/;"	m	struct:fzf.Terminal	typeref:typename:string
infoDefault	src/options.go	/^	infoDefault infoStyle = iota$/;"	c	package:fzf	typeref:type:infoStyle
infoHidden	src/options.go	/^	infoHidden$/;"	c	package:fzf
infoInline	src/options.go	/^	infoInline$/;"	c	package:fzf
infoInlineRight	src/options.go	/^	infoInlineRight$/;"	c	package:fzf
infoPrefix	src/terminal.go	/^	infoPrefix         string$/;"	m	struct:fzf.Terminal	typeref:typename:string
infoRight	src/options.go	/^	infoRight$/;"	c	package:fzf
infoStyle	src/options.go	/^type infoStyle int$/;"	t	package:fzf	typeref:typename:int
infoStyle	src/terminal.go	/^	infoStyle          infoStyle$/;"	m	struct:fzf.Terminal	typeref:typename:infoStyle
init	src/algo/algo_test.go	/^func init() {$/;"	f	package:algo
init	src/options.go	/^func init() {$/;"	f	package:fzf
init	src/pattern.go	/^func init() {$/;"	f	package:fzf
init	src/pattern_test.go	/^func init() {$/;"	f	package:fzf
init	src/server.go	/^func init() {$/;"	f	package:fzf
init	src/terminal.go	/^func init() {$/;"	f	package:fzf
init	src/tui/tui.go	/^func init() {$/;"	f	package:tui
initDelay	src/terminal.go	/^	initDelay          time.Duration$/;"	m	struct:fzf.Terminal	typeref:typename:time.Duration
initFunc	src/terminal.go	/^	initFunc           func() error$/;"	m	struct:fzf.Terminal	typeref:typename:func() error
initPalette	src/tui/tui.go	/^func initPalette(theme *ColorTheme) {$/;"	f	package:tui
initPlatform	src/tui/light_unix.go	/^func (r *LightRenderer) initPlatform() (err error) {$/;"	f	unknown:tui.LightRenderer	typeref:typename:(err error)
initPlatform	src/tui/light_windows.go	/^func (r *LightRenderer) initPlatform() error {$/;"	f	unknown:tui.LightRenderer	typeref:typename:error
initProfiling	src/options_no_pprof.go	/^func (o *Options) initProfiling() error {$/;"	f	unknown:fzf.Options	typeref:typename:error
initProfiling	src/options_pprof.go	/^func (o *Options) initProfiling() error {$/;"	f	unknown:fzf.Options	typeref:typename:error
initScreen	src/tui/tcell.go	/^func (r *FullscreenRenderer) initScreen() error {$/;"	f	unknown:tui.FullscreenRenderer	typeref:typename:error
initialCharClass	src/algo/algo.go	/^	initialCharClass = charWhite$/;"	v	package:algo
initialDelay	src/constants.go	/^	initialDelay      = 20 * time.Millisecond$/;"	c	package:fzf
initialDelayTac	src/constants.go	/^	initialDelayTac   = 100 * time.Millisecond$/;"	c	package:fzf
initialPreviewOpts	src/terminal.go	/^	initialPreviewOpts previewOpts$/;"	m	struct:fzf.Terminal	typeref:typename:previewOpts
initialize	test/lib/common.rb	/^  def initialize(shell = :bash)$/;"	f	class:Tmux
input	src/terminal.go	/^	input              []rune$/;"	m	struct:fzf.Terminal	typeref:typename:[]rune
inputBorder	src/terminal.go	/^	inputBorder        tui.Window$/;"	m	struct:fzf.Terminal	typeref:typename:tui.Window
inputBorderShape	src/terminal.go	/^	inputBorderShape   tui.BorderShape$/;"	m	struct:fzf.Terminal	typeref:typename:tui.BorderShape
inputLabel	src/terminal.go	/^	inputLabel         labelPrinter$/;"	m	struct:fzf.Terminal	typeref:typename:labelPrinter
inputLabelLen	src/terminal.go	/^	inputLabelLen      int$/;"	m	struct:fzf.Terminal	typeref:typename:int
inputLabelOpts	src/terminal.go	/^	inputLabelOpts     labelOpts$/;"	m	struct:fzf.Terminal	typeref:typename:labelOpts
inputOverride	src/terminal.go	/^	inputOverride      *[]rune$/;"	m	struct:fzf.Terminal	typeref:typename:*[]rune
inputWindow	src/terminal.go	/^	inputWindow        tui.Window$/;"	m	struct:fzf.Terminal	typeref:typename:tui.Window
inputless	src/terminal.go	/^	inputless          bool$/;"	m	struct:fzf.Terminal	typeref:typename:bool
install	Makefile	/^install: bin\/fzf$/;"	t
interpretCode	src/ansi.go	/^func interpretCode(ansiCode string, prevState *ansiState) ansiState {$/;"	f	package:fzf	typeref:typename:ansiState
inv	src/pattern.go	/^	inv           bool$/;"	m	struct:fzf.term	typeref:typename:bool
inverse	src/options.go	/^	inverse bool$/;"	m	struct:fzf.heightSpec	typeref:typename:bool
is24	src/tui/tui.go	/^func (c Color) is24() bool {$/;"	f	type:tui.Color	typeref:typename:bool
isAlphabet	src/options.go	/^func isAlphabet(char uint8) bool {$/;"	f	package:fzf	typeref:typename:bool
isAscii	src/algo/algo.go	/^func isAscii(runes []rune) bool {$/;"	f	package:algo	typeref:typename:bool
isCtrlSeqStart	src/ansi.go	/^func isCtrlSeqStart(c uint8) bool {$/;"	f	package:fzf	typeref:typename:bool
isDir	src/options.go	/^func isDir(path string) bool {$/;"	f	package:fzf	typeref:typename:bool
isExecuteAction	src/options.go	/^func isExecuteAction(str string) actionType {$/;"	f	package:fzf	typeref:typename:actionType
isMintty345	src/winpty_windows.go	/^func isMintty345() bool {$/;"	f	package:fzf	typeref:typename:bool
isNumeric	src/options.go	/^func isNumeric(char uint8) bool {$/;"	f	package:fzf	typeref:typename:bool
isPrint	src/ansi.go	/^func isPrint(c uint8) bool {$/;"	f	package:fzf	typeref:typename:bool
isSymlinkToDir	src/reader.go	/^func isSymlinkToDir(path string, de os.DirEntry) bool {$/;"	f	package:fzf	typeref:typename:bool
item	src/result.go	/^	item   *Item$/;"	m	struct:fzf.Result	typeref:typename:*Item
item	src/terminal.go	/^	item *Item$/;"	m	struct:fzf.selectedItem	typeref:typename:*Item
itemLine	src/terminal.go	/^type itemLine struct {$/;"	s	package:fzf
itemLines	src/terminal.go	/^func (t *Terminal) itemLines(item *Item, atMost int) ([][]rune, bool) {$/;"	f	struct:fzf.Terminal	typeref:typename:([][]rune, bool)
item_count	test/lib/common.rb	/^          def item_count$/;"	f	method:Tmux.until
items	src/chunklist.go	/^	items [chunkSize]Item$/;"	m	struct:fzf.Chunk	typeref:typename:[chunkSize]Item
iter	src/pattern.go	/^func (p *Pattern) iter(pfun algo.Algo, tokens []Token, caseSensitive bool, normalize bool, forwa/;"	f	struct:fzf.Pattern	typeref:typename:(Offset, int, *[]int)
itest	Makefile	/^itest:$/;"	t
jsonContentType	src/server.go	/^	jsonContentType  = "Content-Type: application\/json" + crlf$/;"	c	package:fzf
jumpAcceptEnabled	src/terminal.go	/^	jumpAcceptEnabled$/;"	c	package:fzf
jumpDisabled	src/terminal.go	/^	jumpDisabled jumpMode = iota$/;"	c	package:fzf	typeref:type:jumpMode
jumpEnabled	src/terminal.go	/^	jumpEnabled$/;"	c	package:fzf
jumpLabels	src/terminal.go	/^	jumpLabels         string$/;"	m	struct:fzf.Terminal	typeref:typename:string
jumpMode	src/terminal.go	/^type jumpMode int$/;"	t	package:fzf	typeref:typename:int
jumping	src/terminal.go	/^	jumping            jumpMode$/;"	m	struct:fzf.Terminal	typeref:typename:jumpMode
junegunn/seoul256.vim (dark)	ADVANCED.md	/^# junegunn\/seoul256.vim (dark)$/;"	c
junegunn/seoul256.vim (light)	ADVANCED.md	/^# junegunn\/seoul256.vim (light)$/;"	c
keepRight	src/terminal.go	/^	keepRight          bool$/;"	m	struct:fzf.Terminal	typeref:typename:bool
keyChan	src/terminal.go	/^	keyChan            chan tui.Event$/;"	m	struct:fzf.Terminal	typeref:typename:chan tui.Event
keyMatch	src/terminal.go	/^func keyMatch(key tui.Event, event tui.Event) bool {$/;"	f	package:fzf	typeref:typename:bool
keymap	src/terminal.go	/^	keymap             map[tui.Event][]*action$/;"	m	struct:fzf.Terminal	typeref:typename:map[tui.Event][]*action
keymapOrg	src/terminal.go	/^	keymapOrg          map[tui.Event][]*action$/;"	m	struct:fzf.Terminal	typeref:typename:map[tui.Event][]*action
kill	test/lib/common.rb	/^  def kill$/;"	f	class:Tmux
killChan	src/terminal.go	/^	killChan           chan bool$/;"	m	struct:fzf.Terminal	typeref:typename:chan bool
killPreview	src/terminal.go	/^func (t *Terminal) killPreview() {$/;"	f	struct:fzf.Terminal
killed	src/reader.go	/^	killed   bool$/;"	m	struct:fzf.Reader	typeref:typename:bool
label	src/options.go	/^	label  string$/;"	m	struct:fzf.labelOpts	typeref:typename:string
label	src/terminal.go	/^	label     string$/;"	m	struct:fzf.itemLine	typeref:typename:string
labelOpts	src/options.go	/^type labelOpts struct {$/;"	s	package:fzf
labelPrinter	src/terminal.go	/^type labelPrinter func(tui.Window, int)$/;"	t	package:fzf	typeref:typename:func(tui.Window, int)
lastAction	src/terminal.go	/^	lastAction         actionType$/;"	m	struct:fzf.Terminal	typeref:typename:actionType
lastAction	src/terminal.go	/^	lastAction actionType$/;"	m	struct:fzf.replacePlaceholderParams	typeref:typename:actionType
lastChunk	src/chunklist.go	/^func (cl *ChunkList) lastChunk() *Chunk {$/;"	f	struct:fzf.ChunkList	typeref:typename:*Chunk
lastFocus	src/terminal.go	/^	lastFocus          int32$/;"	m	struct:fzf.Terminal	typeref:typename:int32
lastIndex	src/chunklist.go	/^func (c *Chunk) lastIndex(minValue int32) int32 {$/;"	f	struct:fzf.Chunk	typeref:typename:int32
lastKey	src/terminal.go	/^	lastKey            string$/;"	m	struct:fzf.Terminal	typeref:typename:string
lastX	src/tui/tcell.go	/^	lastX         int$/;"	m	struct:tui.TcellWindow	typeref:typename:int
lastY	src/tui/tcell.go	/^	lastY         int$/;"	m	struct:tui.TcellWindow	typeref:typename:int
layout	src/terminal.go	/^	layout             layoutType$/;"	m	struct:fzf.Terminal	typeref:typename:layoutType
layoutDefault	src/options.go	/^	layoutDefault layoutType = iota$/;"	c	package:fzf	typeref:type:layoutType
layoutReverse	src/options.go	/^	layoutReverse$/;"	c	package:fzf
layoutReverseList	src/options.go	/^	layoutReverseList$/;"	c	package:fzf
layoutType	src/options.go	/^type layoutType int$/;"	t	package:fzf	typeref:typename:int
lbg	src/ansi.go	/^	lbg  tui.Color$/;"	m	struct:fzf.ansiState	typeref:typename:tui.Color
left	src/tui/light.go	/^	left          int$/;"	m	struct:tui.LightWindow	typeref:typename:int
left	src/tui/tcell.go	/^	left          int$/;"	m	struct:tui.TcellWindow	typeref:typename:int
left	src/tui/tui.go	/^	left        rune$/;"	m	struct:tui.BorderStyle	typeref:typename:rune
limit	src/server.go	/^	limit  int$/;"	m	struct:fzf.getParams	typeref:typename:int
line	src/terminal.go	/^	line string$/;"	m	struct:fzf.eachLine	typeref:typename:string
lines	src/history.go	/^	lines    []string$/;"	m	struct:fzf.History	typeref:typename:[]string
lines	src/terminal.go	/^	lines      []string$/;"	m	struct:fzf.previewer	typeref:typename:[]string
lines	src/terminal.go	/^	lines   []string$/;"	m	struct:fzf.previewResult	typeref:typename:[]string
link_fzf_in_path	install	/^link_fzf_in_path() {$/;"	f
lint	Makefile	/^lint: $(SOURCES) test\/*.rb test\/lib\/*.rb ${BASH_SCRIPTS}$/;"	t
list	src/terminal.go	/^	list         [3][]*Item \/\/ current, select, and all matched items$/;"	m	struct:fzf.previewRequest	typeref:typename:[3][]*Item
listBorderShape	src/terminal.go	/^	listBorderShape    tui.BorderShape$/;"	m	struct:fzf.Terminal	typeref:typename:tui.BorderShape
listLabel	src/terminal.go	/^	listLabel          labelPrinter$/;"	m	struct:fzf.Terminal	typeref:typename:labelPrinter
listLabelLen	src/terminal.go	/^	listLabelLen       int$/;"	m	struct:fzf.Terminal	typeref:typename:int
listLabelOpts	src/terminal.go	/^	listLabelOpts      labelOpts$/;"	m	struct:fzf.Terminal	typeref:typename:labelOpts
listenAddr	src/terminal.go	/^	listenAddr         *listenAddress$/;"	m	struct:fzf.Terminal	typeref:typename:*listenAddress
listenAddress	src/server.go	/^type listenAddress struct {$/;"	s	package:fzf
listenPort	src/terminal.go	/^	listenPort         *int$/;"	m	struct:fzf.Terminal	typeref:typename:*int
listenUnsafe	src/terminal.go	/^	listenUnsafe       bool$/;"	m	struct:fzf.Terminal	typeref:typename:bool
listener	src/terminal.go	/^	listener           net.Listener$/;"	m	struct:fzf.Terminal	typeref:typename:net.Listener
lists	src/merger.go	/^	lists    [][]Result$/;"	m	struct:fzf.Merger	typeref:typename:[][]Result
main	main.go	/^func main() {$/;"	f	package:main
main	main.go	/^package main$/;"	p
major	src/core.go	/^	major int$/;"	m	struct:fzf.revision	typeref:typename:int
makeImageBorder	src/terminal.go	/^func (t *Terminal) makeImageBorder(width int, top bool) string {$/;"	f	struct:fzf.Terminal	typeref:typename:string
makeSpace	src/tui/light.go	/^func (r *LightRenderer) makeSpace() {$/;"	f	struct:tui.LightRenderer
makeSpinner	src/terminal.go	/^func makeSpinner(unicode bool) []string {$/;"	f	package:fzf	typeref:typename:[]string
manPage	main.go	/^var manPage []byte$/;"	v	package:main	typeref:typename:[]byte
margin	src/terminal.go	/^	margin             [4]sizeSpec$/;"	m	struct:fzf.Terminal	typeref:typename:[4]sizeSpec
markEmptyLine	src/terminal.go	/^func (t *Terminal) markEmptyLine(line int) {$/;"	f	unknown:fzf.Terminal
markOtherLine	src/terminal.go	/^func (t *Terminal) markOtherLine(line int) {$/;"	f	unknown:fzf.Terminal
marker	src/terminal.go	/^	marker             string$/;"	m	struct:fzf.Terminal	typeref:typename:string
markerBottom	src/terminal.go	/^	markerBottom$/;"	c	package:fzf
markerClass	src/terminal.go	/^type markerClass int$/;"	t	package:fzf	typeref:typename:int
markerEmpty	src/terminal.go	/^	markerEmpty        string$/;"	m	struct:fzf.Terminal	typeref:typename:string
markerLen	src/terminal.go	/^	markerLen          int$/;"	m	struct:fzf.Terminal	typeref:typename:int
markerMiddle	src/terminal.go	/^	markerMiddle$/;"	c	package:fzf
markerMultiLine	src/terminal.go	/^	markerMultiLine    [3]string$/;"	m	struct:fzf.Terminal	typeref:typename:[3]string
markerSingle	src/terminal.go	/^	markerSingle markerClass = iota$/;"	c	package:fzf	typeref:type:markerClass
markerTop	src/terminal.go	/^	markerTop$/;"	c	package:fzf
maskActionContents	src/options.go	/^func maskActionContents(action string) string {$/;"	f	package:fzf	typeref:typename:string
match	src/result.go	/^	match  bool$/;"	m	struct:fzf.colorOffset	typeref:typename:bool
match	src/terminal_test.go	/^	match  string \/\/ output is matched against this regex (when output is empty string)$/;"	m	struct:fzf.want	typeref:typename:string
matchChunk	src/pattern.go	/^func (p *Pattern) matchChunk(chunk *Chunk, space []Result, slab *util.Slab) []Result {$/;"	f	struct:fzf.Pattern	typeref:typename:[]Result
matchControlSequence	src/ansi.go	/^func matchControlSequence(s string) int {$/;"	f	package:fzf	typeref:typename:int
matchOperatingSystemCommand	src/ansi.go	/^func matchOperatingSystemCommand(s string, start int) int {$/;"	f	package:fzf	typeref:typename:int
match_count	test/lib/common.rb	/^          def match_count$/;"	f	method:Tmux.until
matches	src/matcher.go	/^	matches []Result$/;"	m	struct:fzf.partialResult	typeref:typename:[]Result
maxBgProcesses	src/constants.go	/^	maxBgProcesses          = 30$/;"	c	package:fzf
maxBgProcessesPerAction	src/constants.go	/^	maxBgProcessesPerAction = 3$/;"	c	package:fzf
maxContentLength	src/server.go	/^	maxContentLength = 1024 * 1024$/;"	c	package:fzf
maxFocusEvents	src/terminal.go	/^const maxFocusEvents = 10000$/;"	c	package:fzf
maxHeightFunc	src/tui/light.go	/^	maxHeightFunc func(int) int$/;"	m	struct:tui.LightRenderer	typeref:typename:func(int) int
maxIndex	src/merger.go	/^	maxIndex int32$/;"	m	struct:fzf.Merger	typeref:typename:int32
maxInputBuffer	src/tui/light.go	/^	maxInputBuffer  = 1024 * 1024$/;"	c	package:tui
maxItems	src/terminal.go	/^func (t *Terminal) maxItems() int {$/;"	f	struct:fzf.Terminal	typeref:typename:int
maxMulti	src/constants.go	/^	maxMulti          = math.MaxInt32$/;"	c	package:fzf
maxPartitions	src/constants.go	/^	maxPartitions           = 32$/;"	c	package:fzf
maxPatternLength	src/constants.go	/^	maxPatternLength  = 1000$/;"	c	package:fzf
maxSize	src/history.go	/^	maxSize  int$/;"	m	struct:fzf.History	typeref:typename:int
mayTriggerPreview	src/terminal.go	/^func mayTriggerPreview(opts *Options) bool {$/;"	f	package:fzf	typeref:typename:bool
merge	src/tui/tui.go	/^func (p ColorPair) merge(other ColorPair, except Color) ColorPair {$/;"	f	struct:tui.ColorPair	typeref:typename:ColorPair
merged	src/merger.go	/^	merged   []Result$/;"	m	struct:fzf.Merger	typeref:typename:[]Result
mergedGet	src/merger.go	/^func (mg *Merger) mergedGet(idx int) Result {$/;"	f	struct:fzf.Merger	typeref:typename:Result
merger	src/terminal.go	/^	merger             *Merger$/;"	m	struct:fzf.Terminal	typeref:typename:*Merger
mergerCache	src/matcher.go	/^	mergerCache    map[string]*Merger$/;"	m	struct:fzf.Matcher	typeref:typename:map[string]*Merger
mergerCacheMax	src/constants.go	/^	mergerCacheMax int = 100000$/;"	c	package:fzf	typeref:typename:int
minHeight	src/terminal.go	/^	minHeight = 3$/;"	c	package:fzf
minIndex	src/merger.go	/^	minIndex int32$/;"	m	struct:fzf.Merger	typeref:typename:int32
minItem	src/item.go	/^var minItem = Item{text: util.Chars{Index: math.MinInt32}}$/;"	v	package:fzf
minPreviewSize	src/terminal.go	/^func (t *Terminal) minPreviewSize(opts *previewOpts) (int, int) {$/;"	f	struct:fzf.Terminal	typeref:typename:(int, int)
minRank	src/result.go	/^func minRank() Result {$/;"	f	package:fzf	typeref:typename:Result
minWidth	src/terminal.go	/^	minWidth  = 4$/;"	c	package:fzf
minor	src/core.go	/^	minor int$/;"	m	struct:fzf.revision	typeref:typename:int
mkfifo	src/proxy_unix.go	/^func mkfifo(path string, mode uint32) (string, error) {$/;"	f	package:fzf	typeref:typename:(string, error)
mkfifo	src/proxy_windows.go	/^func mkfifo(path string, mode uint32) (string, error) {$/;"	f	package:fzf	typeref:typename:(string, error)
modified	src/history.go	/^	modified map[int]string$/;"	m	struct:fzf.History	typeref:typename:map[int]string
morhetz/gruvbox	ADVANCED.md	/^# morhetz\/gruvbox$/;"	c
mouse	src/tui/light.go	/^	mouse         bool$/;"	m	struct:tui.LightRenderer	typeref:typename:bool
mouse	src/tui/tui.go	/^	mouse        bool$/;"	m	struct:tui.FullscreenRenderer	typeref:typename:bool
mouseSequence	src/tui/light.go	/^func (r *LightRenderer) mouseSequence(sz *int) Event {$/;"	f	struct:tui.LightRenderer	typeref:typename:Event
move	src/terminal.go	/^func (t *Terminal) move(y int, x int, clear bool) {$/;"	f	struct:fzf.Terminal
move	src/tui/light.go	/^func (r *LightRenderer) move(y int, x int) {$/;"	f	struct:tui.LightRenderer
moveCursor	src/tui/tcell.go	/^	moveCursor    bool$/;"	m	struct:tui.TcellWindow	typeref:typename:bool
multi	src/terminal.go	/^	multi              int$/;"	m	struct:fzf.Terminal	typeref:typename:int
multiLine	src/terminal.go	/^	multiLine          bool$/;"	m	struct:fzf.Terminal	typeref:typename:bool
mutex	src/cache.go	/^	mutex sync.Mutex$/;"	m	struct:fzf.ChunkCache	typeref:typename:sync.Mutex
mutex	src/chunklist.go	/^	mutex  sync.Mutex$/;"	m	struct:fzf.ChunkList	typeref:typename:sync.Mutex
mutex	src/reader.go	/^	mutex    sync.Mutex$/;"	m	struct:fzf.Reader	typeref:typename:sync.Mutex
mutex	src/terminal.go	/^	mutex              sync.Mutex$/;"	m	struct:fzf.Terminal	typeref:typename:sync.Mutex
mutex	src/tui/light.go	/^	mutex           sync.Mutex$/;"	m	struct:tui.LightRenderer	typeref:typename:sync.Mutex
needPreviewWindow	src/terminal.go	/^func (t *Terminal) needPreviewWindow() bool {$/;"	f	struct:fzf.Terminal	typeref:typename:bool
needWinpty	src/winpty.go	/^func needWinpty(_ *Options) bool {$/;"	f	package:fzf	typeref:typename:bool
needWinpty	src/winpty_windows.go	/^func needWinpty(opts *Options) bool {$/;"	f	package:fzf	typeref:typename:bool
newItem	src/terminal_test.go	/^func newItem(str string) *Item {$/;"	f	package:fzf	typeref:typename:*Item
newItems	src/terminal_test.go	/^func newItems(str ...string) [3][]*Item {$/;"	f	package:fzf	typeref:typename:[3][]*Item
newRange	src/tokenizer.go	/^func newRange(begin int, end int) Range {$/;"	f	package:fzf	typeref:typename:Range
new_shell	test/test_shell_integration.rb	/^  def new_shell$/;"	f	class:TestShell.CompletionTest.TestBash
new_shell	test/test_shell_integration.rb	/^  def new_shell$/;"	f	class:TestShell.CompletionTest.TestFish
new_shell	test/test_shell_integration.rb	/^  def new_shell$/;"	f	class:TestShell.CompletionTest.TestZsh
next	src/history.go	/^func (h *History) next() string {$/;"	f	struct:fzf.History	typeref:typename:string
nextAnsiEscapeSequence	src/ansi.go	/^func nextAnsiEscapeSequence(s string) (int, int) {$/;"	f	package:fzf	typeref:typename:(int, int)
noSeparatorLine	src/options.go	/^func (opts *Options) noSeparatorLine() bool {$/;"	f	struct:fzf.Options	typeref:typename:bool
noSeparatorLine	src/options.go	/^func noSeparatorLine(style infoStyle, separator bool) bool {$/;"	f	package:fzf	typeref:typename:bool
noSeparatorLine	src/terminal.go	/^func (t *Terminal) noSeparatorLine() bool {$/;"	f	struct:fzf.Terminal	typeref:typename:bool
normal	src/tui/tcell.go	/^	normal        ColorPair$/;"	m	struct:tui.TcellWindow	typeref:typename:ColorPair
normalize	src/pattern.go	/^	normalize     bool$/;"	m	struct:fzf.Pattern	typeref:typename:bool
normalize	src/pattern.go	/^	normalize     bool$/;"	m	struct:fzf.term	typeref:typename:bool
normalizeRune	src/algo/algo.go	/^func normalizeRune(r rune) rune {$/;"	f	package:algo	typeref:typename:rune
normalized	src/algo/normalize.go	/^var normalized = map[rune]rune{$/;"	v	package:algo
notifyOnResize	src/terminal_unix.go	/^func notifyOnResize(resizeChan chan<- os.Signal) {$/;"	f	package:fzf
notifyOnResize	src/terminal_windows.go	/^func notifyOnResize(resizeChan chan<- os.Signal) {$/;"	f	package:fzf
notifyStop	src/terminal_unix.go	/^func notifyStop(p *os.Process) {$/;"	f	package:fzf
notifyStop	src/terminal_windows.go	/^func notifyStop(p *os.Process) {$/;"	f	package:fzf
nth	src/pattern.go	/^	nth           []Range$/;"	m	struct:fzf.Pattern	typeref:typename:[]Range
nth	src/terminal.go	/^	nth                []Range$/;"	m	struct:fzf.Terminal	typeref:typename:[]Range
nth	src/terminal.go	/^	nth      *[]Range$/;"	m	struct:fzf.searchRequest	typeref:typename:*[]Range
nthAttr	src/terminal.go	/^	nthAttr            tui.Attr$/;"	m	struct:fzf.Terminal	typeref:typename:tui.Attr
nthCurrent	src/terminal.go	/^	nthCurrent         []Range$/;"	m	struct:fzf.Terminal	typeref:typename:[]Range
nthTransformer	src/options.go	/^func nthTransformer(str string) (func(Delimiter) func([]Token, int32) string, error) {$/;"	f	package:fzf	typeref:typename:(func(Delimiter) func([]Token, int32) string, error)
numItemLines	src/terminal.go	/^func (t *Terminal) numItemLines(item *Item, atMost int) (int, bool) {$/;"	f	struct:fzf.Terminal	typeref:typename:(int, bool)
numLines	src/terminal.go	/^	numLines  int$/;"	m	struct:fzf.itemLine	typeref:typename:int
numLines	src/terminal.go	/^	numLines  int$/;"	m	struct:fzf.previewed	typeref:typename:int
numLines	src/terminal.go	/^	numLines int$/;"	m	struct:fzf.numLinesCacheValue	typeref:typename:int
numLinesCache	src/terminal.go	/^	numLinesCache      map[int32]numLinesCacheValue$/;"	m	struct:fzf.Terminal	typeref:typename:map[int32]numLinesCacheValue
numLinesCacheValue	src/terminal.go	/^type numLinesCacheValue struct {$/;"	s	package:fzf
numPartitionsMultiplier	src/constants.go	/^	numPartitionsMultiplier = 8$/;"	c	package:fzf
number	src/terminal.go	/^	number        bool$/;"	m	struct:fzf.placeholderFlags	typeref:typename:bool
offset	src/ansi.go	/^	offset [2]int32$/;"	m	struct:fzf.ansiOffset	typeref:typename:[2]int32
offset	src/result.go	/^	offset [2]int32$/;"	m	struct:fzf.colorOffset	typeref:typename:[2]int32
offset	src/server.go	/^	offset int$/;"	m	struct:fzf.getParams	typeref:typename:int
offset	src/terminal.go	/^	offset             int$/;"	m	struct:fzf.Terminal	typeref:typename:int
offset	src/terminal.go	/^	offset     int$/;"	m	struct:fzf.previewer	typeref:typename:int
offset	src/terminal.go	/^	offset    int$/;"	m	struct:fzf.previewed	typeref:typename:int
offset	src/terminal.go	/^	offset  int$/;"	m	struct:fzf.previewResult	typeref:typename:int
offsetComponentRegex	src/terminal.go	/^var offsetComponentRegex *regexp.Regexp$/;"	v	package:fzf	typeref:typename:*regexp.Regexp
offsetPollTries	src/tui/light.go	/^	offsetPollTries = 10$/;"	c	package:tui
offsetRegexp	src/tui/light.go	/^var offsetRegexp = regexp.MustCompile("(.*?)\\x00?\\x1b\\\\[([0-9]+);([0-9]+)R")$/;"	v	package:tui
offsetRegexpBegin	src/tui/light.go	/^var offsetRegexpBegin = regexp.MustCompile("^\\x1b\\\\[[0-9]+;[0-9]+R")$/;"	v	package:tui
offsetTrimCharsRegex	src/terminal.go	/^var offsetTrimCharsRegex *regexp.Regexp$/;"	v	package:fzf	typeref:typename:*regexp.Regexp
openTty	src/tui/light_unix.go	/^func openTty(ttyDefault string, mode int) (*os.File, error) {$/;"	f	package:tui	typeref:typename:(*os.File, error)
openTtyIn	src/tui/light_unix.go	/^func openTtyIn(ttyDefault string) (*os.File, error) {$/;"	f	package:tui	typeref:typename:(*os.File, error)
openTtyIn	src/tui/light_windows.go	/^func openTtyIn(ttyDefault string) (*os.File, error) {$/;"	f	package:tui	typeref:typename:(*os.File, error)
openTtyOut	src/tui/light_unix.go	/^func openTtyOut(ttyDefault string) (*os.File, error) {$/;"	f	package:tui	typeref:typename:(*os.File, error)
openTtyOut	src/tui/light_windows.go	/^func openTtyOut(ttyDefault string) (*os.File, error) {$/;"	f	package:tui	typeref:typename:(*os.File, error)
optString	src/options.go	/^func optString(arg string, prefix string) (bool, string) {$/;"	f	package:fzf	typeref:typename:(bool, string)
optionalRunes	src/util/chars.go	/^func (chars *Chars) optionalRunes() []rune {$/;"	f	struct:util.Chars	typeref:typename:[]rune
opts.sinklist	plugin/fzf.vim	/^    function! opts.sinklist(lines) abort$/;"	f	function:fzf#wrap
optsFor	src/options_test.go	/^func optsFor(words ...string) *Options {$/;"	f	package:fzf	typeref:typename:*Options
origState	src/tui/light.go	/^	origState     *term.State$/;"	m	struct:tui.LightRenderer	typeref:typename:*term.State
origStateInput	src/tui/light.go	/^	origStateInput  uint32$/;"	m	struct:tui.LightRenderer	typeref:typename:uint32
origStateOutput	src/tui/light.go	/^	origStateOutput uint32$/;"	m	struct:tui.LightRenderer	typeref:typename:uint32
origText	src/item.go	/^	origText    *[]byte       \/\/ 8$/;"	m	struct:fzf.Item	typeref:typename:*[]byte
origin	src/tui/light.go	/^func (r *LightRenderer) origin() {$/;"	f	struct:tui.LightRenderer
other	src/terminal.go	/^	other     bool$/;"	m	struct:fzf.itemLine	typeref:typename:bool
outHandle	src/tui/light.go	/^	outHandle       uintptr$/;"	m	struct:tui.LightRenderer	typeref:typename:uintptr
output	src/terminal.go	/^func (t *Terminal) output() bool {$/;"	f	struct:fzf.Terminal	typeref:typename:bool
output	src/terminal_test.go	/^	output string \/\/ literal output$/;"	m	struct:fzf.want	typeref:typename:string
overflow	src/terminal.go	/^func (t *Terminal) overflow(runes []rune, max int) bool {$/;"	f	struct:fzf.Terminal	typeref:typename:bool
overflow32	src/util/chars.go	/^	overflow32 uint32 = 0x80808080$/;"	c	package:util	typeref:typename:uint32
overflow64	src/util/chars.go	/^	overflow64 uint64 = 0x8080808080808080$/;"	c	package:util	typeref:typename:uint64
override	src/history.go	/^func (h *History) override(str string) {$/;"	f	struct:fzf.History
pad	src/terminal.go	/^	pad int$/;"	m	struct:fzf.fitpad	typeref:typename:int
padding	src/terminal.go	/^	padding            [4]sizeSpec$/;"	m	struct:fzf.Terminal	typeref:typename:[4]sizeSpec
params	src/ansi.go	/^	params string$/;"	m	struct:fzf.url	typeref:typename:string
params	src/tui/tcell.go	/^	params        *string$/;"	m	struct:tui.TcellWindow	typeref:typename:*string
parseActionList	src/options.go	/^func parseActionList(masked string, original string, prevActions []*action, putAllowed bool) ([]/;"	f	package:fzf	typeref:typename:([]*action, error)
parseAlgo	src/options.go	/^func parseAlgo(str string) (algo.Algo, error) {$/;"	f	package:fzf	typeref:typename:(algo.Algo, error)
parseAnsiCode	src/ansi.go	/^func parseAnsiCode(s string) (int, string) {$/;"	f	package:fzf	typeref:typename:(int, string)
parseBorder	src/options.go	/^func parseBorder(str string, optional bool) (tui.BorderShape, error) {$/;"	f	package:fzf	typeref:typename:(tui.BorderShape, error)
parseGetParams	src/server.go	/^func parseGetParams(query string) getParams {$/;"	f	package:fzf	typeref:typename:getParams
parseHeight	src/options.go	/^func parseHeight(str string, index int) (heightSpec, error) {$/;"	f	package:fzf	typeref:typename:(heightSpec, error)
parseInfoStyle	src/options.go	/^func parseInfoStyle(str string) (infoStyle, string, error) {$/;"	f	package:fzf	typeref:typename:(infoStyle, string, error)
parseKeyChords	src/options.go	/^func parseKeyChords(str string, message string) (map[tui.Event]string, []tui.Event, error) {$/;"	f	package:fzf	typeref:typename:(map[tui.Event]string, []tui.Event, error)
parseKeymap	src/options.go	/^func parseKeymap(keymap map[tui.Event][]*action, str string) error {$/;"	f	package:fzf	typeref:typename:error
parseLabelPosition	src/options.go	/^func parseLabelPosition(opts *labelOpts, arg string) error {$/;"	f	package:fzf	typeref:typename:error
parseLayout	src/options.go	/^func parseLayout(str string) (layoutType, error) {$/;"	f	package:fzf	typeref:typename:(layoutType, error)
parseListenAddress	src/server.go	/^func parseListenAddress(address string) (listenAddress, error) {$/;"	f	package:fzf	typeref:typename:(listenAddress, error)
parseMargin	src/options.go	/^func parseMargin(opt string, margin string) ([4]sizeSpec, error) {$/;"	f	package:fzf	typeref:typename:([4]sizeSpec, error)
parseMarkerMultiLine	src/options.go	/^func parseMarkerMultiLine(str string) (*[3]string, error) {$/;"	f	package:fzf	typeref:typename:(*[3]string, error)
parseOptions	src/options.go	/^func parseOptions(index *int, opts *Options, allArgs []string) error {$/;"	f	package:fzf	typeref:typename:error
parsePlaceholder	src/terminal.go	/^func parsePlaceholder(match string) (bool, string, placeholderFlags) {$/;"	f	package:fzf	typeref:typename:(bool, string, placeholderFlags)
parsePreviewWindow	src/options.go	/^func parsePreviewWindow(opts *previewOpts, input string) error {$/;"	f	package:fzf	typeref:typename:error
parsePreviewWindowImpl	src/options.go	/^func parsePreviewWindowImpl(opts *previewOpts, input string) error {$/;"	f	package:fzf	typeref:typename:error
parsePrompt	src/terminal.go	/^func (t *Terminal) parsePrompt(prompt string) (func(), int) {$/;"	f	struct:fzf.Terminal	typeref:typename:(func(), int)
parseScheme	src/options.go	/^func parseScheme(str string) (string, []criterion, error) {$/;"	f	package:fzf	typeref:typename:(string, []criterion, error)
parseShellWords	src/options.go	/^func parseShellWords(str string) ([]string, error) {$/;"	f	package:fzf	typeref:typename:([]string, error)
parseSingleActionList	src/options.go	/^func parseSingleActionList(str string) ([]*action, error) {$/;"	f	package:fzf	typeref:typename:([]*action, error)
parseSize	src/options.go	/^func parseSize(str string, maxPercent float64, label string) (sizeSpec, error) {$/;"	f	package:fzf	typeref:typename:(sizeSpec, error)
parseTerms	src/pattern.go	/^func parseTerms(fuzzy bool, caseMode Case, normalize bool, str string) []termSet {$/;"	f	package:fzf	typeref:typename:[]termSet
parseTheme	src/options.go	/^func parseTheme(defaultTheme *tui.ColorTheme, str string) (*tui.ColorTheme, error) {$/;"	f	package:fzf	typeref:typename:(*tui.ColorTheme, error)
parseTiebreak	src/options.go	/^func parseTiebreak(str string) ([]criterion, error) {$/;"	f	package:fzf	typeref:typename:([]criterion, error)
parseTmuxOptions	src/options.go	/^func parseTmuxOptions(arg string, index int) (*tmuxOptions, error) {$/;"	f	package:fzf	typeref:typename:(*tmuxOptions, error)
parseToggleSort	src/options.go	/^func parseToggleSort(keymap map[tui.Event][]*action, str string) error {$/;"	f	package:fzf	typeref:typename:error
parseWalkerOpts	src/options.go	/^func parseWalkerOpts(str string) (walkerOpts, error) {$/;"	f	package:fzf	typeref:typename:(walkerOpts, error)
partialResult	src/matcher.go	/^type partialResult struct {$/;"	s	package:fzf
partitions	src/matcher.go	/^	partitions     int$/;"	m	struct:fzf.Matcher	typeref:typename:int
pass	src/merger.go	/^	pass     bool$/;"	m	struct:fzf.Merger	typeref:typename:bool
passThroughBeginRegex	src/terminal.go	/^var passThroughBeginRegex *regexp.Regexp$/;"	v	package:fzf	typeref:typename:*regexp.Regexp
passThroughEndTmuxRegex	src/terminal.go	/^var passThroughEndTmuxRegex *regexp.Regexp$/;"	v	package:fzf	typeref:typename:*regexp.Regexp
paste	test/lib/common.rb	/^  def paste(str)$/;"	f	class:Tmux
pasting	src/terminal.go	/^	pasting            *[]rune$/;"	m	struct:fzf.Terminal	typeref:typename:*[]rune
path	src/history.go	/^	path     string$/;"	m	struct:fzf.History	typeref:typename:string
pattern	src/matcher.go	/^	pattern  *Pattern$/;"	m	struct:fzf.MatchRequest	typeref:typename:*Pattern
pattern	src/merger.go	/^	pattern  *Pattern$/;"	m	struct:fzf.Merger	typeref:typename:*Pattern
patternBuilder	src/matcher.go	/^	patternBuilder func([]rune) *Pattern$/;"	m	struct:fzf.Matcher	typeref:typename:func([]rune) *Pattern
paused	src/terminal.go	/^	paused             bool$/;"	m	struct:fzf.Terminal	typeref:typename:bool
pausedState	src/terminal.go	/^	pausedState$/;"	c	package:fzf
pborder	src/terminal.go	/^	pborder            tui.Window$/;"	m	struct:fzf.Terminal	typeref:typename:tui.Window
percent	src/options.go	/^	percent bool$/;"	m	struct:fzf.heightSpec	typeref:typename:bool
percent	src/options.go	/^	percent bool$/;"	m	struct:fzf.sizeSpec	typeref:typename:bool
placeCursor	src/terminal.go	/^func (t *Terminal) placeCursor() {$/;"	f	struct:fzf.Terminal
placeholder	src/terminal.go	/^var placeholder *regexp.Regexp$/;"	v	package:fzf	typeref:typename:*regexp.Regexp
placeholderFlags	src/terminal.go	/^type placeholderFlags struct {$/;"	s	package:fzf
plus	src/terminal.go	/^	plus          bool$/;"	m	struct:fzf.placeholderFlags	typeref:typename:bool
pointer	src/terminal.go	/^	pointer            string$/;"	m	struct:fzf.Terminal	typeref:typename:string
pointerEmpty	src/terminal.go	/^	pointerEmpty       string$/;"	m	struct:fzf.Terminal	typeref:typename:string
pointerLen	src/terminal.go	/^	pointerLen         int$/;"	m	struct:fzf.Terminal	typeref:typename:int
points	src/result.go	/^	points [4]uint16$/;"	m	struct:fzf.Result	typeref:typename:[4]uint16
port	src/server.go	/^	port int$/;"	m	struct:fzf.listenAddress	typeref:typename:int
posArray	src/algo/algo.go	/^func posArray(withPos bool, len int) *[]int {$/;"	f	package:algo	typeref:typename:*[]int
posCenter	src/options.go	/^	posCenter$/;"	c	package:fzf
posDown	src/options.go	/^	posDown$/;"	c	package:fzf
posLeft	src/options.go	/^	posLeft$/;"	c	package:fzf
posRight	src/options.go	/^	posRight$/;"	c	package:fzf
posUp	src/options.go	/^	posUp windowPosition = iota$/;"	c	package:fzf	typeref:type:windowPosition
position	src/options.go	/^	position    windowPosition$/;"	m	struct:fzf.previewOpts	typeref:typename:windowPosition
position	src/options.go	/^	position windowPosition$/;"	m	struct:fzf.tmuxOptions	typeref:typename:windowPosition
postProcessOptions	src/options.go	/^func postProcessOptions(opts *Options) error {$/;"	f	package:fzf	typeref:typename:error
posx	src/tui/light.go	/^	posx          int$/;"	m	struct:tui.LightWindow	typeref:typename:int
posy	src/tui/light.go	/^	posy          int$/;"	m	struct:tui.LightWindow	typeref:typename:int
prefixLength	src/tokenizer.go	/^	prefixLength int32$/;"	m	struct:fzf.Token	typeref:typename:int32
prepare	test/lib/common.rb	/^  def prepare$/;"	f	class:Tmux
preserveSpace	src/terminal.go	/^	preserveSpace bool$/;"	m	struct:fzf.placeholderFlags	typeref:typename:bool
pressed	src/terminal.go	/^	pressed            string$/;"	m	struct:fzf.Terminal	typeref:typename:string
prevDownTime	src/tui/light.go	/^	prevDownTime  time.Time$/;"	m	struct:tui.LightRenderer	typeref:typename:time.Time
prevDownTime	src/tui/tui.go	/^	prevDownTime time.Time$/;"	m	struct:tui.FullscreenRenderer	typeref:typename:time.Time
prevLines	src/terminal.go	/^	prevLines          []itemLine$/;"	m	struct:fzf.Terminal	typeref:typename:[]itemLine
previewBox	src/terminal.go	/^	previewBox         *util.EventBox$/;"	m	struct:fzf.Terminal	typeref:typename:*util.EventBox
previewCancelWait	src/constants.go	/^	previewCancelWait = 500 * time.Millisecond$/;"	c	package:fzf
previewChunkDelay	src/constants.go	/^	previewChunkDelay = 100 * time.Millisecond$/;"	c	package:fzf
previewDelayed	src/constants.go	/^	previewDelayed    = 500 * time.Millisecond$/;"	c	package:fzf
previewLabel	src/terminal.go	/^	previewLabel       labelPrinter$/;"	m	struct:fzf.Terminal	typeref:typename:labelPrinter
previewLabelLen	src/terminal.go	/^	previewLabelLen    int$/;"	m	struct:fzf.Terminal	typeref:typename:int
previewLabelOpts	src/terminal.go	/^	previewLabelOpts   labelOpts$/;"	m	struct:fzf.Terminal	typeref:typename:labelOpts
previewOpts	src/options.go	/^type previewOpts struct {$/;"	s	package:fzf
previewOpts	src/terminal.go	/^	previewOpts        previewOpts$/;"	m	struct:fzf.Terminal	typeref:typename:previewOpts
previewOptsCompare	src/options.go	/^type previewOptsCompare int$/;"	t	package:fzf	typeref:typename:int
previewOptsDifferentContentLayout	src/options.go	/^	previewOptsDifferentContentLayout$/;"	c	package:fzf
previewOptsDifferentLayout	src/options.go	/^	previewOptsDifferentLayout$/;"	c	package:fzf
previewOptsSame	src/options.go	/^	previewOptsSame previewOptsCompare = iota$/;"	c	package:fzf	typeref:type:previewOptsCompare
previewRequest	src/terminal.go	/^type previewRequest struct {$/;"	s	package:fzf
previewResult	src/terminal.go	/^type previewResult struct {$/;"	s	package:fzf
previewScrollbar	src/terminal.go	/^	previewScrollbar   string$/;"	m	struct:fzf.Terminal	typeref:typename:string
previewed	src/terminal.go	/^	previewed          previewed$/;"	m	struct:fzf.Terminal	typeref:typename:previewed
previewed	src/terminal.go	/^type previewed struct {$/;"	s	package:fzf
previewer	src/terminal.go	/^	previewer          previewer$/;"	m	struct:fzf.Terminal	typeref:typename:previewer
previewer	src/terminal.go	/^type previewer struct {$/;"	s	package:fzf
previous	src/history.go	/^func (h *History) previous() string {$/;"	f	struct:fzf.History	typeref:typename:string
printAll	src/terminal.go	/^func (t *Terminal) printAll() {$/;"	f	struct:fzf.Terminal
printBar	src/terminal.go	/^func (t *Terminal) printBar(lineNum int, forceRedraw bool, barRange [2]int) bool {$/;"	f	struct:fzf.Terminal	typeref:typename:bool
printColoredString	src/terminal.go	/^func (t *Terminal) printColoredString(window tui.Window, text []rune, offsets []colorOffset, col/;"	f	struct:fzf.Terminal
printFooter	src/terminal.go	/^func (t *Terminal) printFooter() {$/;"	f	struct:fzf.Terminal
printHeader	src/terminal.go	/^func (t *Terminal) printHeader() {$/;"	f	struct:fzf.Terminal
printHeaderImpl	src/terminal.go	/^func (t *Terminal) printHeaderImpl(window tui.Window, borderShape tui.BorderShape, lines1 []stri/;"	f	struct:fzf.Terminal
printHighlighted	src/terminal.go	/^func (t *Terminal) printHighlighted(result Result, colBase tui.ColorPair, colMatch tui.ColorPair/;"	f	struct:fzf.Terminal	typeref:typename:int
printInfo	src/terminal.go	/^func (t *Terminal) printInfo() {$/;"	f	struct:fzf.Terminal
printInfoImpl	src/terminal.go	/^func (t *Terminal) printInfoImpl() {$/;"	f	struct:fzf.Terminal
printItem	src/terminal.go	/^func (t *Terminal) printItem(result Result, line int, maxLine int, index int, current bool, barR/;"	f	struct:fzf.Terminal	typeref:typename:int
printLabel	src/terminal.go	/^func (t *Terminal) printLabel(window tui.Window, render labelPrinter, opts labelOpts, length int/;"	f	struct:fzf.Terminal
printList	src/terminal.go	/^func (t *Terminal) printList() {$/;"	f	struct:fzf.Terminal
printPreview	src/terminal.go	/^func (t *Terminal) printPreview() {$/;"	f	struct:fzf.Terminal
printPreviewDelayed	src/terminal.go	/^func (t *Terminal) printPreviewDelayed() {$/;"	f	struct:fzf.Terminal
printPrompt	src/terminal.go	/^func (t *Terminal) printPrompt() {$/;"	f	struct:fzf.Terminal
printQuery	src/terminal.go	/^	printQuery         bool$/;"	m	struct:fzf.Terminal	typeref:typename:bool
printQueue	src/terminal.go	/^	printQueue         []string$/;"	m	struct:fzf.Terminal	typeref:typename:[]string
printScript	main.go	/^func printScript(label string, content []byte) {$/;"	f	package:main
printString	src/tui/tcell.go	/^func (w *TcellWindow) printString(text string, pair ColorPair) {$/;"	f	struct:tui.TcellWindow
printer	src/terminal.go	/^	printer            func(string)$/;"	m	struct:fzf.Terminal	typeref:typename:func(string)
printsep	src/terminal.go	/^	printsep           string$/;"	m	struct:fzf.Terminal	typeref:typename:string
printsep	src/terminal.go	/^	printsep   string$/;"	m	struct:fzf.replacePlaceholderParams	typeref:typename:string
procFun	src/pattern.go	/^	procFun       map[termType]algo.Algo$/;"	m	struct:fzf.Pattern	typeref:typename:map[termType]algo.Algo
processExecution	src/terminal.go	/^func processExecution(action actionType) bool {$/;"	f	package:fzf	typeref:typename:bool
processTabs	src/terminal.go	/^func (t *Terminal) processTabs(runes []rune, prefixWidth int) (string, int) {$/;"	f	struct:fzf.Terminal	typeref:typename:(string, int)
progress	src/terminal.go	/^	progress           int$/;"	m	struct:fzf.Terminal	typeref:typename:int
progressMinDuration	src/constants.go	/^	progressMinDuration     = 200 * time.Millisecond$/;"	c	package:fzf
prompt	src/terminal.go	/^	prompt             func()$/;"	m	struct:fzf.Terminal	typeref:typename:func()
prompt	src/terminal.go	/^	prompt     string$/;"	m	struct:fzf.replacePlaceholderParams	typeref:typename:string
promptLen	src/terminal.go	/^	promptLen          int$/;"	m	struct:fzf.Terminal	typeref:typename:int
promptLine	src/terminal.go	/^func (t *Terminal) promptLine() int {$/;"	f	struct:fzf.Terminal	typeref:typename:int
promptLines	src/terminal.go	/^func (t *Terminal) promptLines() int {$/;"	f	struct:fzf.Terminal	typeref:typename:int
promptString	src/terminal.go	/^	promptString       string$/;"	m	struct:fzf.Terminal	typeref:typename:string
protector	src/protector/protector.go	/^package protector$/;"	p
protector	src/protector/protector_openbsd.go	/^package protector$/;"	p
proxyScript	src/terminal.go	/^	proxyScript        string$/;"	m	struct:fzf.Terminal	typeref:typename:string
push	src/chunklist.go	/^func (c *Chunk) push(trans ItemBuilder, data []byte) bool {$/;"	f	struct:fzf.Chunk	typeref:typename:bool
pusher	src/reader.go	/^	pusher   func([]byte) bool$/;"	m	struct:fzf.Reader	typeref:typename:func([]byte) bool
pwindow	src/terminal.go	/^	pwindow            tui.Window$/;"	m	struct:fzf.Terminal	typeref:typename:tui.Window
pwindowSize	src/terminal.go	/^func (t *Terminal) pwindowSize() tui.TermSize {$/;"	f	struct:fzf.Terminal	typeref:typename:tui.TermSize
query	src/terminal.go	/^	query        string$/;"	m	struct:fzf.previewRequest	typeref:typename:string
query	src/terminal.go	/^	query      string$/;"	m	struct:fzf.replacePlaceholderParams	typeref:typename:string
query	src/terminal_test.go	/^	query    string$/;"	m	struct:fzf.give	typeref:typename:string
queryCache	src/cache.go	/^type queryCache map[string][]Result$/;"	t	package:fzf	typeref:typename:map[string][]Result
queryCacheMax	src/constants.go	/^	queryCacheMax int = chunkSize \/ 5$/;"	c	package:fzf	typeref:typename:int
queryLen	src/terminal.go	/^	queryLen           [2]int$/;"	m	struct:fzf.Terminal	typeref:typename:[2]int
queryLen	src/terminal.go	/^	queryLen  int$/;"	m	struct:fzf.itemLine	typeref:typename:int
queued	src/tui/light.go	/^	queued        strings.Builder$/;"	m	struct:tui.LightRenderer	typeref:typename:strings.Builder
quitSignal	src/terminal.go	/^type quitSignal struct {$/;"	s	package:fzf
randResult	src/merger_test.go	/^func randResult() Result {$/;"	f	package:fzf	typeref:typename:Result
rangeEllipsis	src/tokenizer.go	/^const rangeEllipsis = 0$/;"	c	package:fzf
raw	src/terminal.go	/^	raw           bool$/;"	m	struct:fzf.placeholderFlags	typeref:typename:bool
readChannel	src/reader.go	/^func (r *Reader) readChannel(inputChan chan string) bool {$/;"	f	struct:fzf.Reader	typeref:typename:bool
readFile	src/terminal_test.go	/^func readFile(path string) ([]byte, error) {$/;"	f	package:fzf	typeref:typename:([]byte, error)
readFiles	src/reader.go	/^func (r *Reader) readFiles(roots []string, opts walkerOpts, ignores []string) bool {$/;"	f	struct:fzf.Reader	typeref:typename:bool
readFromCommand	src/reader.go	/^func (r *Reader) readFromCommand(command string, environ []string, signalReady func()) bool {$/;"	f	struct:fzf.Reader	typeref:typename:bool
readFromStdin	src/reader.go	/^func (r *Reader) readFromStdin() bool {$/;"	f	struct:fzf.Reader	typeref:typename:bool
readerBufferSize	src/constants.go	/^	readerBufferSize       = 64 * 1024$/;"	c	package:fzf
readerPollIntervalMax	src/constants.go	/^	readerPollIntervalMax  = 50 * time.Millisecond$/;"	c	package:fzf
readerPollIntervalMin	src/constants.go	/^	readerPollIntervalMin  = 10 * time.Millisecond$/;"	c	package:fzf
readerPollIntervalStep	src/constants.go	/^	readerPollIntervalStep = 5 * time.Millisecond$/;"	c	package:fzf
readerSlabSize	src/constants.go	/^	readerSlabSize         = 128 * 1024$/;"	c	package:fzf
reading	src/terminal.go	/^	reading            bool$/;"	m	struct:fzf.Terminal	typeref:typename:bool
regex	src/tokenizer.go	/^	regex *regexp.Regexp$/;"	m	struct:fzf.Delimiter	typeref:typename:*regexp.Regexp
release	Makefile	/^release:$/;"	t
remove	uninstall	/^remove() {$/;"	f
removeFiles	src/functions.go	/^func removeFiles(files []string) {$/;"	f	package:fzf
remove_line	uninstall	/^remove_line() {$/;"	f
renderBar	src/terminal.go	/^func (t *Terminal) renderBar(line int, barRange [2]int) {$/;"	f	struct:fzf.Terminal
renderEmptyLine	src/terminal.go	/^func (t *Terminal) renderEmptyLine(line int, barRange [2]int) {$/;"	f	struct:fzf.Terminal
renderGapLine	src/terminal.go	/^func (t *Terminal) renderGapLine(line int, barRange [2]int, drawLine bool) {$/;"	f	struct:fzf.Terminal
renderPreviewArea	src/terminal.go	/^func (t *Terminal) renderPreviewArea(unchanged bool) {$/;"	f	struct:fzf.Terminal
renderPreviewScrollbar	src/terminal.go	/^func (t *Terminal) renderPreviewScrollbar(yoff int, barLength int, barStart int) {$/;"	f	struct:fzf.Terminal
renderPreviewSpinner	src/terminal.go	/^func (t *Terminal) renderPreviewSpinner() {$/;"	f	struct:fzf.Terminal
renderPreviewText	src/terminal.go	/^func (t *Terminal) renderPreviewText(height int, lines []string, lineNo int, unchanged bool) {$/;"	f	struct:fzf.Terminal
renderer	src/tui/light.go	/^	renderer      *LightRenderer$/;"	m	struct:tui.LightWindow	typeref:typename:*LightRenderer
repeat	src/tui/light.go	/^func repeat(r rune, times int) string {$/;"	f	package:tui	typeref:typename:string
replacePlaceholder	src/terminal.go	/^func (t *Terminal) replacePlaceholder(template string, forcePlus bool, input string, list [3][]*/;"	f	struct:fzf.Terminal	typeref:typename:(string, []string)
replacePlaceholder	src/terminal.go	/^func replacePlaceholder(params replacePlaceholderParams) (string, []string) {$/;"	f	package:fzf	typeref:typename:(string, []string)
replacePlaceholderInInitialCommand	src/terminal.go	/^func (t *Terminal) replacePlaceholderInInitialCommand(template string) (string, []string) {$/;"	f	struct:fzf.Terminal	typeref:typename:(string, []string)
replacePlaceholderParams	src/terminal.go	/^type replacePlaceholderParams struct {$/;"	s	package:fzf
replacePlaceholderTest	src/terminal_test.go	/^func replacePlaceholderTest(template string, stripAnsi bool, delimiter Delimiter, printsep strin/;"	f	package:fzf	typeref:typename:string
reqActivate	src/terminal.go	/^	reqActivate$/;"	c	package:fzf
reqBecome	src/terminal.go	/^	reqBecome$/;"	c	package:fzf
reqBox	src/matcher.go	/^	reqBox         *util.EventBox$/;"	m	struct:fzf.Matcher	typeref:typename:*util.EventBox
reqBox	src/terminal.go	/^	reqBox             *util.EventBox$/;"	m	struct:fzf.Terminal	typeref:typename:*util.EventBox
reqClose	src/terminal.go	/^	reqClose$/;"	c	package:fzf
reqFatal	src/terminal.go	/^	reqFatal$/;"	c	package:fzf
reqFooter	src/terminal.go	/^	reqFooter$/;"	c	package:fzf
reqFullRedraw	src/terminal.go	/^	reqFullRedraw$/;"	c	package:fzf
reqHeader	src/terminal.go	/^	reqHeader$/;"	c	package:fzf
reqInfo	src/terminal.go	/^	reqInfo$/;"	c	package:fzf
reqJump	src/terminal.go	/^	reqJump$/;"	c	package:fzf
reqList	src/terminal.go	/^	reqList$/;"	c	package:fzf
reqPreviewDelayed	src/terminal.go	/^	reqPreviewDelayed$/;"	c	package:fzf
reqPreviewDisplay	src/terminal.go	/^	reqPreviewDisplay$/;"	c	package:fzf
reqPreviewEnqueue	src/terminal.go	/^	reqPreviewEnqueue$/;"	c	package:fzf
reqPreviewReady	src/terminal.go	/^	reqPreviewReady$/;"	c	package:fzf
reqPreviewRefresh	src/terminal.go	/^	reqPreviewRefresh$/;"	c	package:fzf
reqPrintQuery	src/terminal.go	/^	reqPrintQuery$/;"	c	package:fzf
reqPrompt	src/terminal.go	/^	reqPrompt$/;"	c	package:fzf
reqQuit	src/terminal.go	/^	reqQuit$/;"	c	package:fzf
reqRedraw	src/terminal.go	/^	reqRedraw$/;"	c	package:fzf
reqRedrawBorderLabel	src/terminal.go	/^	reqRedrawBorderLabel$/;"	c	package:fzf
reqRedrawFooterLabel	src/terminal.go	/^	reqRedrawFooterLabel$/;"	c	package:fzf
reqRedrawHeaderLabel	src/terminal.go	/^	reqRedrawHeaderLabel$/;"	c	package:fzf
reqRedrawInputLabel	src/terminal.go	/^	reqRedrawInputLabel$/;"	c	package:fzf
reqRedrawListLabel	src/terminal.go	/^	reqRedrawListLabel$/;"	c	package:fzf
reqRedrawPreviewLabel	src/terminal.go	/^	reqRedrawPreviewLabel$/;"	c	package:fzf
reqReinit	src/terminal.go	/^	reqReinit$/;"	c	package:fzf
reqReset	src/matcher.go	/^	reqReset$/;"	c	package:fzf
reqResize	src/terminal.go	/^	reqResize util.EventType = iota$/;"	c	package:fzf	typeref:typename:util.EventType
reqRetry	src/matcher.go	/^	reqRetry util.EventType = iota$/;"	c	package:fzf	typeref:typename:util.EventType
resizeIfNeeded	src/terminal.go	/^func (t *Terminal) resizeIfNeeded() bool {$/;"	f	struct:fzf.Terminal	typeref:typename:bool
resizeWindows	src/terminal.go	/^func (t *Terminal) resizeWindows(forcePreview bool, redrawBorder bool) {$/;"	f	struct:fzf.Terminal
restart	src/reader.go	/^func (r *Reader) restart(command commandSpec, environ []string, readyChan chan bool) {$/;"	f	struct:fzf.Reader
restoreTerminal	src/tui/light_unix.go	/^func (r *LightRenderer) restoreTerminal() {$/;"	f	unknown:tui.LightRenderer
restoreTerminal	src/tui/light_windows.go	/^func (r *LightRenderer) restoreTerminal() {$/;"	f	unknown:tui.LightRenderer
result	src/terminal.go	/^	result    Result$/;"	m	struct:fzf.itemLine	typeref:typename:Result
resumableState	src/terminal.go	/^type resumableState int$/;"	t	package:fzf	typeref:typename:int
retire	src/cache.go	/^func (cc *ChunkCache) retire(chunk ...*Chunk) {$/;"	f	struct:fzf.ChunkCache
revision	main.go	/^var revision = "devel"$/;"	v	package:main
revision	src/core.go	/^type revision struct {$/;"	s	package:fzf
revision	src/item.go	/^	revision revision$/;"	m	struct:fzf.transformed	typeref:typename:revision
revision	src/matcher.go	/^	revision       revision$/;"	m	struct:fzf.Matcher	typeref:typename:revision
revision	src/matcher.go	/^	revision revision$/;"	m	struct:fzf.MatchRequest	typeref:typename:revision
revision	src/merger.go	/^	revision revision$/;"	m	struct:fzf.Merger	typeref:typename:revision
revision	src/pattern.go	/^	revision      revision$/;"	m	struct:fzf.Pattern	typeref:typename:revision
revision	src/terminal.go	/^	revision           revision$/;"	m	struct:fzf.Terminal	typeref:typename:revision
revision	src/terminal.go	/^	revision revision$/;"	m	struct:fzf.searchRequest	typeref:typename:revision
right	src/tui/tui.go	/^	right       rune$/;"	m	struct:tui.BorderStyle	typeref:typename:rune
rmcup	src/tui/light.go	/^func (r *LightRenderer) rmcup() {$/;"	f	struct:tui.LightRenderer
rubout	src/terminal.go	/^func (t *Terminal) rubout(pattern string) {$/;"	f	struct:fzf.Terminal
runInitProfileTests	src/options_pprof_test.go	/^var runInitProfileTests = flag.Bool("test-init-profile", false, "run init profile tests")$/;"	v	package:fzf
runProxy	src/proxy.go	/^func runProxy(commandPrefix string, cmdBuilder func(temp string, needBash bool) (*exec.Cmd, erro/;"	f	package:fzf	typeref:typename:(int, error)
runTmux	src/tmux.go	/^func runTmux(args []string, opts *Options) (int, error) {$/;"	f	package:fzf	typeref:typename:(int, error)
runWinpty	src/winpty.go	/^func runWinpty(_ []string, _ *Options) (int, error) {$/;"	f	package:fzf	typeref:typename:(int, error)
runWinpty	src/winpty_windows.go	/^func runWinpty(args []string, opts *Options) (int, error) {$/;"	f	package:fzf	typeref:typename:(int, error)
runeWidth	src/tui/tui.go	/^func runeWidth(r rune) int {$/;"	f	package:tui	typeref:typename:int
running	src/terminal.go	/^	running            *util.AtomicBool$/;"	m	struct:fzf.Terminal	typeref:typename:*util.AtomicBool
runningCmd	src/terminal.go	/^type runningCmd struct {$/;"	s	package:fzf
runningCmds	src/terminal.go	/^	runningCmds        *util.ConcurrentSet[*runningCmd]$/;"	m	struct:fzf.Terminal	typeref:typename:*util.ConcurrentSet
s:base_dir	plugin/fzf.vim	/^  let s:base_dir = expand('<sfile>:h:h')$/;"	v
s:border_opt	plugin/fzf.vim	/^function! s:border_opt(window)$/;"	f
s:calc_size	plugin/fzf.vim	/^function! s:calc_size(max, val, dict)$/;"	f
s:callback	plugin/fzf.vim	/^function! s:callback(dict, lines) abort$/;"	f
s:checked	plugin/fzf.vim	/^let s:checked = {}$/;"	v
s:cmd	plugin/fzf.vim	/^function! s:cmd(bang, ...) abort$/;"	f
s:collect	plugin/fzf.vim	/^function! s:collect(temps) abort$/;"	f
s:common_sink	plugin/fzf.vim	/^function! s:common_sink(action, lines) abort$/;"	f
s:compare_binary_versions	plugin/fzf.vim	/^function! s:compare_binary_versions(a, b)$/;"	f
s:compare_versions	plugin/fzf.vim	/^function! s:compare_versions(a, b)$/;"	f
s:cpo_save	plugin/fzf.vim	/^let s:cpo_save = &cpo$/;"	v
s:create_popup	plugin/fzf.vim	/^  function s:create_popup(opts) abort$/;"	f
s:create_popup	plugin/fzf.vim	/^  function! s:create_popup(opts) abort$/;"	f
s:default_action	plugin/fzf.vim	/^let s:default_action = {$/;"	v
s:default_layout	plugin/fzf.vim	/^function! s:default_layout()$/;"	f
s:defaults	plugin/fzf.vim	/^function! s:defaults()$/;"	f
s:dopopd	plugin/fzf.vim	/^function! s:dopopd()$/;"	f
s:enc_to_cp	plugin/fzf.vim	/^  function! s:enc_to_cp(str)$/;"	f
s:error	plugin/fzf.vim	/^function! s:error(msg)$/;"	f
s:escape	plugin/fzf.vim	/^function! s:escape(path)$/;"	f
s:evaluate_opts	plugin/fzf.vim	/^function! s:evaluate_opts(options)$/;"	f
s:execute	plugin/fzf.vim	/^function! s:execute(dict, command, use_height, temps) abort$/;"	f
s:execute_term	plugin/fzf.vim	/^function! s:execute_term(dict, command, temps) abort$/;"	f
s:execute_tmux	plugin/fzf.vim	/^function! s:execute_tmux(dict, command, temps) abort$/;"	f
s:exit_handler	plugin/fzf.vim	/^function! s:exit_handler(dict, code, command, ...)$/;"	f
s:extract_option	plugin/fzf.vim	/^function! s:extract_option(opts, name)$/;"	f
s:fzf_call	plugin/fzf.vim	/^  function! s:fzf_call(fn, ...)$/;"	f
s:fzf_expand	plugin/fzf.vim	/^function! s:fzf_expand(fmt)$/;"	f
s:fzf_fnamemodify	plugin/fzf.vim	/^function! s:fzf_fnamemodify(fname, mods)$/;"	f
s:fzf_getcwd	plugin/fzf.vim	/^function! s:fzf_getcwd()$/;"	f
s:fzf_go	plugin/fzf.vim	/^let s:fzf_go = s:base_dir.'\/bin\/fzf'$/;"	v
s:fzf_tempname	plugin/fzf.vim	/^function! s:fzf_tempname()$/;"	f
s:fzf_tmux	plugin/fzf.vim	/^function! s:fzf_tmux(dict)$/;"	f
s:fzf_tmux	plugin/fzf.vim	/^let s:fzf_tmux = s:base_dir.'\/bin\/fzf-tmux'$/;"	v
s:get_color	plugin/fzf.vim	/^function! s:get_color(attr, ...)$/;"	f
s:get_version	plugin/fzf.vim	/^function s:get_version(bin)$/;"	f
s:getpos	plugin/fzf.vim	/^function! s:getpos()$/;"	f
s:handle_ambidouble	plugin/fzf.vim	/^function! s:handle_ambidouble(dict)$/;"	f
s:has_any	plugin/fzf.vim	/^function! s:has_any(dict, keys)$/;"	f
s:is_win	plugin/fzf.vim	/^let s:is_win = has('win32') || has('win64')$/;"	v
s:launcher	plugin/fzf.vim	/^  let s:launcher = '%s'$/;"	v
s:launcher	plugin/fzf.vim	/^  let s:launcher = function('s:xterm_launcher')$/;"	v
s:layout_keys	plugin/fzf.vim	/^let s:layout_keys = ['window', 'tmux', 'up', 'down', 'left', 'right']$/;"	v
s:min_version	plugin/fzf.vim	/^let s:min_version = '0.53.0'$/;"	v
s:need_cmd_window	plugin/fzf.vim	/^let s:need_cmd_window = has('win32unix') && $TERM_PROGRAM ==# 'mintty' && s:compare_versions($TE/;"	v
s:open	plugin/fzf.vim	/^function! s:open(cmd, target)$/;"	f
s:popup	plugin/fzf.vim	/^function! s:popup(opts) abort$/;"	f
s:popup_support	plugin/fzf.vim	/^function! s:popup_support()$/;"	f
s:present	plugin/fzf.vim	/^function! s:present(dict, ...)$/;"	f
s:pushd	plugin/fzf.vim	/^function! s:pushd(dict)$/;"	f
s:shellesc_cmd	plugin/fzf.vim	/^function! s:shellesc_cmd(arg)$/;"	f
s:shortpath	plugin/fzf.vim	/^function! s:shortpath()$/;"	f
s:split	plugin/fzf.vim	/^function! s:split(dict)$/;"	f
s:splittable	plugin/fzf.vim	/^function! s:splittable(dict)$/;"	f
s:term_marker	plugin/fzf.vim	/^  let s:term_marker = ";#FZF"$/;"	v
s:term_marker	plugin/fzf.vim	/^  let s:term_marker = '&::FZF'$/;"	v
s:tmux_enabled	plugin/fzf.vim	/^function! s:tmux_enabled()$/;"	f
s:use_sh	plugin/fzf.vim	/^function! s:use_sh()$/;"	f
s:validate_layout	plugin/fzf.vim	/^function! s:validate_layout(layout)$/;"	f
s:versions	plugin/fzf.vim	/^let s:versions = {}$/;"	v
s:warn	plugin/fzf.vim	/^function! s:warn(msg)$/;"	f
s:warned	plugin/fzf.vim	/^let s:warned = 0$/;"	v
s:wrap_cmds	plugin/fzf.vim	/^  function! s:wrap_cmds(cmds)$/;"	f
s:writefile	plugin/fzf.vim	/^function! s:writefile(...)$/;"	f
s:xterm_launcher	plugin/fzf.vim	/^function! s:xterm_launcher()$/;"	f
scan	src/matcher.go	/^func (m *Matcher) scan(request MatchRequest) (*Merger, bool) {$/;"	f	struct:fzf.Matcher	typeref:typename:(*Merger, bool)
scoreGapExtension	src/algo/algo.go	/^	scoreGapExtension = -1$/;"	c	package:algo
scoreGapStart	src/algo/algo.go	/^	scoreGapStart     = -3$/;"	c	package:algo
scoreMatch	src/algo/algo.go	/^	scoreMatch        = 16$/;"	c	package:algo
scroll	src/options.go	/^	scroll      string$/;"	m	struct:fzf.previewOpts	typeref:typename:string
scrollOff	src/terminal.go	/^	scrollOff          int$/;"	m	struct:fzf.Terminal	typeref:typename:int
scrollOffset	src/terminal.go	/^	scrollOffset int$/;"	m	struct:fzf.previewRequest	typeref:typename:int
scrollable	src/terminal.go	/^	scrollable bool$/;"	m	struct:fzf.previewer	typeref:typename:bool
scrollbar	src/terminal.go	/^	scrollbar          string$/;"	m	struct:fzf.Terminal	typeref:typename:string
searchRequest	src/terminal.go	/^type searchRequest struct {$/;"	s	package:fzf
selectItem	src/terminal.go	/^func (t *Terminal) selectItem(item *Item) bool {$/;"	f	struct:fzf.Terminal	typeref:typename:bool
selectItemChanged	src/terminal.go	/^func (t *Terminal) selectItemChanged(item *Item) bool {$/;"	f	struct:fzf.Terminal	typeref:typename:bool
select_count	test/lib/common.rb	/^          def select_count$/;"	f	method:Tmux.until
selected	src/terminal.go	/^	selected           map[int32]selectedItem$/;"	m	struct:fzf.Terminal	typeref:typename:map[int32]selectedItem
selected	src/terminal.go	/^	selected  bool$/;"	m	struct:fzf.itemLine	typeref:typename:bool
selectedItem	src/terminal.go	/^type selectedItem struct {$/;"	s	package:fzf
send_keys	test/lib/common.rb	/^  def send_keys(*args)$/;"	f	class:Tmux
separator	src/terminal.go	/^	separator          labelPrinter$/;"	m	struct:fzf.Terminal	typeref:typename:labelPrinter
separatorLen	src/terminal.go	/^	separatorLen       int$/;"	m	struct:fzf.Terminal	typeref:typename:int
serverInputChan	src/terminal.go	/^	serverInputChan    chan []*action$/;"	m	struct:fzf.Terminal	typeref:typename:chan []*action
setBg	src/tui/light.go	/^func (w *LightWindow) setBg() string {$/;"	f	struct:tui.LightWindow	typeref:typename:string
set_var	test/test_shell_integration.rb	/^  def set_var(name, val)$/;"	f	class:TestShell.CompletionTest.TestFish
set_var	test/test_shell_integration.rb	/^  def set_var(name, val)$/;"	f	module:TestShell
setup	test/lib/common.rb	/^  def setup$/;"	f	class:TestBase
setup	test/lib/common.rb	/^  def setup$/;"	f	class:TestInteractive
setup	test/test_shell_integration.rb	/^  def setup$/;"	f	module:TestShell
setupTerminal	src/tui/light_unix.go	/^func (r *LightRenderer) setupTerminal() {$/;"	f	unknown:tui.LightRenderer
setupTerminal	src/tui/light_windows.go	/^func (r *LightRenderer) setupTerminal() {$/;"	f	unknown:tui.LightRenderer
sh	src/proxy_unix.go	/^func sh(bash bool) (string, error) {$/;"	f	package:fzf	typeref:typename:(string, error)
sh	src/proxy_windows.go	/^func sh(bash bool) (string, error) {$/;"	f	package:fzf	typeref:typename:(string, error)
shPath	src/proxy_windows.go	/^var shPath atomic.Value$/;"	v	package:fzf	typeref:typename:atomic.Value
shape	src/tui/tui.go	/^	shape       BorderShape$/;"	m	struct:tui.BorderStyle	typeref:typename:BorderShape
shell	src/util/util_unix.go	/^	shell   string$/;"	m	struct:util.Executor	typeref:typename:string
shell	src/util/util_windows.go	/^	shell     string$/;"	m	struct:util.Executor	typeref:typename:string
shell	test/test_shell_integration.rb	/^  def shell$/;"	f	class:TestShell.CompletionTest.TestBash
shell	test/test_shell_integration.rb	/^  def shell$/;"	f	class:TestShell.CompletionTest.TestFish
shell	test/test_shell_integration.rb	/^  def shell$/;"	f	class:TestShell.CompletionTest.TestZsh
shellPath	src/util/util_windows.go	/^	shellPath atomic.Value$/;"	m	struct:util.Executor	typeref:typename:atomic.Value
shellType	src/util/util_windows.go	/^	shellType shellType$/;"	m	struct:util.Executor	typeref:typename:shellType
shellType	src/util/util_windows.go	/^type shellType int$/;"	t	package:util	typeref:typename:int
shellTypeCmd	src/util/util_windows.go	/^	shellTypeCmd$/;"	c	package:util
shellTypePowerShell	src/util/util_windows.go	/^	shellTypePowerShell$/;"	c	package:util
shellTypeUnknown	src/util/util_windows.go	/^	shellTypeUnknown shellType = iota$/;"	c	package:util	typeref:type:shellType
showCursor	src/tui/light.go	/^	showCursor    bool$/;"	m	struct:tui.LightRenderer	typeref:typename:bool
showCursor	src/tui/tcell.go	/^	showCursor    bool$/;"	m	struct:tui.TcellWindow	typeref:typename:bool
showCursor	src/tui/tui.go	/^	showCursor   bool$/;"	m	struct:tui.FullscreenRenderer	typeref:typename:bool
size	src/options.go	/^	size        sizeSpec$/;"	m	struct:fzf.previewOpts	typeref:typename:sizeSpec
size	src/options.go	/^	size    float64$/;"	m	struct:fzf.heightSpec	typeref:typename:float64
size	src/options.go	/^	size    float64$/;"	m	struct:fzf.sizeSpec	typeref:typename:float64
sizeSpec	src/options.go	/^type sizeSpec struct {$/;"	s	package:fzf
slab	src/matcher.go	/^	slab           []*util.Slab$/;"	m	struct:fzf.Matcher	typeref:typename:[]*util.Slab
slab	src/pattern_test.go	/^var slab *util.Slab$/;"	v	package:fzf	typeref:typename:*util.Slab
slab	src/terminal.go	/^	slab               *util.Slab$/;"	m	struct:fzf.Terminal	typeref:typename:*util.Slab
slab16Size	src/constants.go	/^	slab16Size int = 100 * 1024 \/\/ 200KB * 32 = 12.8MB$/;"	c	package:fzf	typeref:typename:int
slab32Size	src/constants.go	/^	slab32Size int = 2048       \/\/ 8KB * 32 = 256KB$/;"	c	package:fzf	typeref:typename:int
slice	src/util/chars.go	/^	slice           []byte \/\/ or []rune$/;"	m	struct:util.Chars	typeref:typename:[]byte
sliceChunks	src/matcher.go	/^func (m *Matcher) sliceChunks(chunks []*Chunk) [][]*Chunk {$/;"	f	struct:fzf.Matcher	typeref:typename:[][]*Chunk
smcup	src/tui/light.go	/^func (r *LightRenderer) smcup() {$/;"	f	struct:tui.LightRenderer
sort	src/matcher.go	/^	sort           bool$/;"	m	struct:fzf.Matcher	typeref:typename:bool
sort	src/matcher.go	/^	sort     bool$/;"	m	struct:fzf.MatchRequest	typeref:typename:bool
sort	src/terminal.go	/^	sort               bool$/;"	m	struct:fzf.Terminal	typeref:typename:bool
sort	src/terminal.go	/^	sort     bool$/;"	m	struct:fzf.searchRequest	typeref:typename:bool
sortCriteria	src/result.go	/^var sortCriteria []criterion$/;"	v	package:fzf	typeref:typename:[]criterion
sortSelected	src/terminal.go	/^func (t *Terminal) sortSelected() []selectedItem {$/;"	f	struct:fzf.Terminal	typeref:typename:[]selectedItem
sortable	src/pattern.go	/^	sortable      bool$/;"	m	struct:fzf.Pattern	typeref:typename:bool
sorted	src/merger.go	/^	sorted   bool$/;"	m	struct:fzf.Merger	typeref:typename:bool
spinner	src/terminal.go	/^	spinner            []string$/;"	m	struct:fzf.Terminal	typeref:typename:[]string
spinner	src/terminal.go	/^	spinner    string$/;"	m	struct:fzf.previewer	typeref:typename:string
spinner	src/terminal.go	/^	spinner string$/;"	m	struct:fzf.previewResult	typeref:typename:string
spinnerDuration	src/constants.go	/^	spinnerDuration   = 100 * time.Millisecond$/;"	c	package:fzf
splitNth	src/options.go	/^func splitNth(str string) ([]Range, error) {$/;"	f	package:fzf	typeref:typename:([]Range, error)
splitRegexp	src/options.go	/^	splitRegexp      *regexp.Regexp$/;"	v	package:fzf	typeref:typename:*regexp.Regexp
startChan	src/terminal.go	/^	startChan          chan fitpad$/;"	m	struct:fzf.Terminal	typeref:typename:chan fitpad
startEventPoller	src/reader.go	/^func (r *Reader) startEventPoller() {$/;"	f	struct:fzf.Reader
startHttpServer	src/server.go	/^func startHttpServer(address listenAddress, actionChannel chan []*action, getHandler func(getPar/;"	f	package:fzf	typeref:typename:(net.Listener, int, error)
state	src/util/atomicbool.go	/^	state int32 \/\/ "1" is true, "0" is false$/;"	m	struct:util.AtomicBool	typeref:typename:int32
stderr	src/tui/light.go	/^func (r *LightRenderer) stderr(str string) {$/;"	f	unknown:tui.LightRenderer
stderrInternal	src/tui/light.go	/^func (r *LightRenderer) stderrInternal(str string, allowNLCR bool, resetCode string) {$/;"	f	unknown:tui.LightRenderer
stderrInternal	src/tui/light.go	/^func (w *LightWindow) stderrInternal(str string, allowNLCR bool, resetCode string) {$/;"	f	struct:tui.LightWindow
str	src/tokenizer.go	/^	str   *string$/;"	m	struct:fzf.Delimiter	typeref:typename:*string
strLines	src/options.go	/^func strLines(str string) []string {$/;"	f	package:fzf	typeref:typename:[]string
stringBytes	src/functions.go	/^func stringBytes(data string) []byte {$/;"	f	package:fzf	typeref:typename:[]byte
stripAnsi	src/terminal.go	/^	stripAnsi  bool$/;"	m	struct:fzf.replacePlaceholderParams	typeref:typename:bool
style	src/tui/tcell.go	/^func (p ColorPair) style() tcell.Style {$/;"	f	unknown:tui.ColorPair	typeref:typename:tcell.Style
subWordNext	src/terminal.go	/^	subWordNext        string$/;"	m	struct:fzf.Terminal	typeref:typename:string
subWordRubout	src/terminal.go	/^	subWordRubout      string$/;"	m	struct:fzf.Terminal	typeref:typename:string
suppress	src/terminal.go	/^	suppress           bool$/;"	m	struct:fzf.Terminal	typeref:typename:bool
sync	src/terminal.go	/^	sync     bool$/;"	m	struct:fzf.searchRequest	typeref:typename:bool
t	src/terminal.go	/^	t actionType$/;"	m	struct:fzf.action	typeref:typename:actionType
tabstop	src/terminal.go	/^	tabstop            int$/;"	m	struct:fzf.Terminal	typeref:typename:int
tabstop	src/tui/light.go	/^	tabstop       int$/;"	m	struct:tui.LightRenderer	typeref:typename:int
tabstop	src/tui/light.go	/^	tabstop       int$/;"	m	struct:tui.LightWindow	typeref:typename:int
tac	src/matcher.go	/^	tac            bool$/;"	m	struct:fzf.Matcher	typeref:typename:bool
tac	src/merger.go	/^	tac      bool$/;"	m	struct:fzf.Merger	typeref:typename:bool
target/$(BINARY32)	Makefile	/^target\/$(BINARY32): $(SOURCES)$/;"	t
target/$(BINARY64)	Makefile	/^target\/$(BINARY64): $(SOURCES)$/;"	t
target/$(BINARYARM5)	Makefile	/^target\/$(BINARYARM5): $(SOURCES)$/;"	t
target/$(BINARYARM6)	Makefile	/^target\/$(BINARYARM6): $(SOURCES)$/;"	t
target/$(BINARYARM7)	Makefile	/^target\/$(BINARYARM7): $(SOURCES)$/;"	t
target/$(BINARYARM8)	Makefile	/^target\/$(BINARYARM8): $(SOURCES)$/;"	t
target/$(BINARYLOONG64)	Makefile	/^target\/$(BINARYLOONG64): $(SOURCES)$/;"	t
target/$(BINARYPPC64LE)	Makefile	/^target\/$(BINARYPPC64LE): $(SOURCES)$/;"	t
target/$(BINARYRISCV64)	Makefile	/^target\/$(BINARYRISCV64): $(SOURCES)$/;"	t
target/$(BINARYS390)	Makefile	/^target\/$(BINARYS390): $(SOURCES)$/;"	t
teardown	test/lib/common.rb	/^  def teardown$/;"	f	class:TestBase
teardown	test/lib/common.rb	/^  def teardown$/;"	f	class:TestInteractive
teardown	test/test_shell_integration.rb	/^  def teardown$/;"	f	module:TestShell
tempFiles	src/terminal.go	/^	tempFiles []string$/;"	m	struct:fzf.commandSpec	typeref:typename:[]string
tempFiles	src/terminal.go	/^	tempFiles []string$/;"	m	struct:fzf.runningCmd	typeref:typename:[]string
template	src/terminal.go	/^	template     string$/;"	m	struct:fzf.previewRequest	typeref:typename:string
template	src/terminal.go	/^	template   string$/;"	m	struct:fzf.replacePlaceholderParams	typeref:typename:string
template	src/terminal_test.go	/^	template string$/;"	m	struct:fzf.give	typeref:typename:string
templateToString	src/terminal_test.go	/^func templateToString(format string, data any) string {$/;"	f	package:fzf	typeref:typename:string
tempname	test/lib/common.rb	/^  def tempname$/;"	f	class:TestBase
term	src/pattern.go	/^type term struct {$/;"	s	package:fzf
termEqual	src/pattern.go	/^	termEqual$/;"	c	package:fzf
termExact	src/pattern.go	/^	termExact$/;"	c	package:fzf
termExactBoundary	src/pattern.go	/^	termExactBoundary$/;"	c	package:fzf
termFunc	src/reader.go	/^	termFunc func()$/;"	m	struct:fzf.Reader	typeref:typename:func()
termFuzzy	src/pattern.go	/^	termFuzzy termType = iota$/;"	c	package:fzf	typeref:type:termType
termPrefix	src/pattern.go	/^	termPrefix$/;"	c	package:fzf
termSet	src/pattern.go	/^type termSet []term$/;"	t	package:fzf	typeref:typename:[]term
termSets	src/pattern.go	/^	termSets      []termSet$/;"	m	struct:fzf.Pattern	typeref:typename:[]termSet
termSize	src/terminal.go	/^	termSize           tui.TermSize$/;"	m	struct:fzf.Terminal	typeref:typename:tui.TermSize
termSuffix	src/pattern.go	/^	termSuffix$/;"	c	package:fzf
termType	src/pattern.go	/^type termType int$/;"	t	package:fzf	typeref:typename:int
terminate	src/reader.go	/^func (r *Reader) terminate() {$/;"	f	struct:fzf.Reader
test	Makefile	/^test: $(SOURCES)$/;"	t
testCase	src/terminal_test.go	/^type testCase struct {$/;"	s	package:fzf
testCommands	src/terminal_test.go	/^func testCommands(t *testing.T, tests []testCase) {$/;"	f	package:fzf
testParserReference	src/ansi_test.go	/^func testParserReference(t testing.TB, str string) {$/;"	f	package:fzf
test_abort_action_chain	test/test_core.rb	/^  def test_abort_action_chain$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_accept_non_empty	test/test_core.rb	/^  def test_accept_non_empty$/;"	f	class:TestCore
test_accept_non_empty_with_empty_list	test/test_core.rb	/^  def test_accept_non_empty_with_empty_list$/;"	f	class:TestCore
test_accept_non_empty_with_multi_selection	test/test_core.rb	/^  def test_accept_non_empty_with_multi_selection$/;"	f	class:TestCore
test_accept_nth	test/test_core.rb	/^  def test_accept_nth$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_accept_nth_regex_delimiter	test/test_core.rb	/^  def test_accept_nth_regex_delimiter$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_accept_nth_regex_delimiter_strip_last	test/test_core.rb	/^  def test_accept_nth_regex_delimiter_strip_last$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_accept_nth_string_delimiter	test/test_core.rb	/^  def test_accept_nth_string_delimiter$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_accept_nth_template	test/test_core.rb	/^  def test_accept_nth_template$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_accept_or_print_query_with_match	test/test_core.rb	/^  def test_accept_or_print_query_with_match$/;"	f	class:TestCore
test_accept_or_print_query_with_multi_selection	test/test_core.rb	/^  def test_accept_or_print_query_with_multi_selection$/;"	f	class:TestCore
test_accept_or_print_query_without_match	test/test_core.rb	/^  def test_accept_or_print_query_without_match$/;"	f	class:TestCore
test_all_borders	test/test_layout.rb	/^  def test_all_borders$/;"	f	class:TestLayout
test_all_borders_header_first	test/test_layout.rb	/^  def test_all_borders_header_first$/;"	f	class:TestLayout
test_alt_c	test/test_shell_integration.rb	/^  def test_alt_c$/;"	f	module:TestShell
test_alt_c_command	test/test_shell_integration.rb	/^  def test_alt_c_command$/;"	f	module:TestShell
test_alternative_preview_window_opts	test/test_preview.rb	/^  def test_alternative_preview_window_opts$/;"	f	method:TestPreview.test_preview_clear_screen
test_async_transform	test/test_core.rb	/^  def test_async_transform$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_backward_delete_char_eof	test/test_core.rb	/^  def test_backward_delete_char_eof$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_backward_eof	test/test_core.rb	/^  def test_backward_eof$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_become	test/test_exec.rb	/^  def test_become$/;"	f	class:TestExec
test_become_tty	test/test_exec.rb	/^  def test_become_tty$/;"	f	class:TestExec
test_bg_cancel	test/test_core.rb	/^  def test_bg_cancel$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_bind	test/test_core.rb	/^  def test_bind$/;"	f	class:TestCore
test_bind_print_query	test/test_core.rb	/^  def test_bind_print_query$/;"	f	class:TestCore
test_bind_replace_query	test/test_core.rb	/^  def test_bind_replace_query$/;"	f	class:TestCore
test_boundary_match	test/test_filter.rb	/^  def test_boundary_match$/;"	f	class:TestFilter
test_cancel	test/test_core.rb	/^  def test_cancel$/;"	f	class:TestCore
test_change_and_transform_header	test/test_layout.rb	/^  def test_change_and_transform_header$/;"	f	class:TestLayout
test_change_first_last	test/test_core.rb	/^  def test_change_first_last$/;"	f	class:TestCore
test_change_header	test/test_layout.rb	/^  def test_change_header$/;"	f	class:TestLayout
test_change_header_and_label_at_once	test/test_layout.rb	/^  def test_change_header_and_label_at_once$/;"	f	class:TestLayout
test_change_header_on_header_window	test/test_core.rb	/^  def test_change_header_on_header_window$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_change_nth	test/test_core.rb	/^  def test_change_nth$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_change_nth_unset_default	test/test_core.rb	/^  def test_change_nth_unset_default$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_change_pointer	test/test_core.rb	/^  def test_change_pointer$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_change_preview_window	test/test_preview.rb	/^  def test_change_preview_window$/;"	f	method:TestPreview.test_preview_clear_screen
test_change_preview_window_rotate	test/test_preview.rb	/^  def test_change_preview_window_rotate$/;"	f	method:TestPreview.test_preview_clear_screen
test_change_preview_window_rotate_hidden	test/test_preview.rb	/^  def test_change_preview_window_rotate_hidden$/;"	f	method:TestPreview.test_preview_clear_screen
test_change_preview_window_rotate_hidden_down	test/test_preview.rb	/^  def test_change_preview_window_rotate_hidden_down$/;"	f	method:TestPreview.test_preview_clear_screen
test_change_preview_window_should_not_reset_change_preview	test/test_preview.rb	/^  def test_change_preview_window_should_not_reset_change_preview$/;"	f	method:TestPreview.test_preview_clear_screen
test_change_prompt	test/test_core.rb	/^  def test_change_prompt$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_change_query	test/test_core.rb	/^  def test_change_query$/;"	f	class:TestCore
test_clear_list_when_header_lines_changed_due_to_reload	test/test_exec.rb	/^  def test_clear_list_when_header_lines_changed_due_to_reload$/;"	f	class:TestExec
test_clear_query	test/test_core.rb	/^  def test_clear_query$/;"	f	class:TestCore
test_clear_selection	test/test_core.rb	/^  def test_clear_selection$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_close	test/test_preview.rb	/^  def test_close$/;"	f	method:TestPreview.test_preview_clear_screen
test_combinations	test/test_layout.rb	/^  def test_combinations$/;"	f	class:TestLayout
test_complete_quoted_command	test/test_shell_integration.rb	/^  def test_complete_quoted_command$/;"	f	class:TestShell.CompletionTest.TestZsh
test_completion_in_command_sequence	test/test_shell_integration.rb	/^  def test_completion_in_command_sequence$/;"	f	method:TestShell.CompletionTest.test_file_completion
test_ctrl_r	test/test_shell_integration.rb	/^  def test_ctrl_r$/;"	f	module:TestShell
test_ctrl_r_abort	test/test_shell_integration.rb	/^  def test_ctrl_r_abort$/;"	f	method:TestShell.test_ctrl_r_multiline
test_ctrl_r_multi	test/test_shell_integration.rb	/^  def test_ctrl_r_multi$/;"	f	class:TestShell.CompletionTest.TestFish
test_ctrl_r_multiline	test/test_shell_integration.rb	/^  def test_ctrl_r_multiline$/;"	f	module:TestShell
test_ctrl_t	test/test_shell_integration.rb	/^  def test_ctrl_t$/;"	f	module:TestShell
test_ctrl_t_unicode	test/test_shell_integration.rb	/^  def test_ctrl_t_unicode$/;"	f	module:TestShell
test_custom_completion	test/test_shell_integration.rb	/^  def test_custom_completion$/;"	f	method:TestShell.CompletionTest.test_file_completion
test_custom_completion_api	test/test_shell_integration.rb	/^  def test_custom_completion_api$/;"	f	method:TestShell.CompletionTest.test_file_completion
test_cycle	test/test_core.rb	/^  def test_cycle$/;"	f	class:TestCore
test_default_extended	test/test_filter.rb	/^  def test_default_extended$/;"	f	class:TestFilter
test_delete_with_modifiers	test/test_core.rb	/^  def test_delete_with_modifiers$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_dir_completion	test/test_shell_integration.rb	/^  def test_dir_completion$/;"	f	method:TestShell.CompletionTest.test_file_completion
test_disabled	test/test_core.rb	/^  def test_disabled$/;"	f	class:TestCore
test_disabled_preview_update	test/test_exec.rb	/^  def test_disabled_preview_update$/;"	f	class:TestExec
test_dynamic_completion_loader	test/test_shell_integration.rb	/^  def test_dynamic_completion_loader$/;"	f	class:TestShell.CompletionTest.TestBash
test_ellipsis	test/test_core.rb	/^  def test_ellipsis$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_env_vars	test/test_core.rb	/^  def test_env_vars$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_escaped_meta_characters	test/test_filter.rb	/^  def test_escaped_meta_characters$/;"	f	class:TestFilter
test_exact	test/test_filter.rb	/^  def test_exact$/;"	f	class:TestFilter
test_exclude	test/test_core.rb	/^  def test_exclude$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_exclude_multi	test/test_core.rb	/^  def test_exclude_multi$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_execute	test/test_exec.rb	/^  def test_execute$/;"	f	class:TestExec
test_execute_multi	test/test_exec.rb	/^  def test_execute_multi$/;"	f	class:TestExec
test_execute_plus_flag	test/test_exec.rb	/^  def test_execute_plus_flag$/;"	f	class:TestExec
test_execute_shell	test/test_exec.rb	/^  def test_execute_shell$/;"	f	class:TestExec
test_exit_0	test/test_core.rb	/^  def test_exit_0$/;"	f	class:TestCore
test_exit_0_exit_code	test/test_core.rb	/^  def test_exit_0_exit_code$/;"	f	class:TestCore
test_exitstatus_empty	test/test_core.rb	/^  def test_exitstatus_empty$/;"	f	class:TestCore
test_expect	test/test_core.rb	/^  def test_expect$/;"	f	class:TestCore
test_expect_print_query	test/test_core.rb	/^  def test_expect_print_query$/;"	f	class:TestCore
test_expect_print_query_select_1	test/test_core.rb	/^  def test_expect_print_query_select_1$/;"	f	class:TestCore
test_expect_printable_character_print_query	test/test_core.rb	/^  def test_expect_printable_character_print_query$/;"	f	class:TestCore
test_expect_with_bound_actions	test/test_core.rb	/^  def test_expect_with_bound_actions$/;"	f	class:TestCore
test_file_completion	test/test_shell_integration.rb	/^  def test_file_completion$/;"	f	module:TestShell.CompletionTest
test_file_completion_root	test/test_shell_integration.rb	/^  def test_file_completion_root$/;"	f	method:TestShell.CompletionTest.test_file_completion
test_file_completion_unicode	test/test_shell_integration.rb	/^  def test_file_completion_unicode$/;"	f	method:TestShell.CompletionTest.test_file_completion
test_file_word	test/test_core.rb	/^  def test_file_word$/;"	f	class:TestCore
test_filter_exitstatus	test/test_filter.rb	/^  def test_filter_exitstatus$/;"	f	class:TestFilter
test_focus_event	test/test_core.rb	/^  def test_focus_event$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_fzf_default_command	test/test_core.rb	/^  def test_fzf_default_command$/;"	f	class:TestCore
test_fzf_default_command_failure	test/test_core.rb	/^  def test_fzf_default_command_failure$/;"	f	class:TestCore
test_fzf_multi_line	test/test_layout.rb	/^  def test_fzf_multi_line$/;"	f	class:TestLayout
test_fzf_multi_line_no_pointer_and_marker	test/test_layout.rb	/^  def test_fzf_multi_line_no_pointer_and_marker$/;"	f	class:TestLayout
test_fzf_multi_line_reverse	test/test_layout.rb	/^  def test_fzf_multi_line_reverse$/;"	f	class:TestLayout
test_fzf_pos	test/test_core.rb	/^  def test_fzf_pos$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_gap	test/test_layout.rb	/^  def test_gap$/;"	f	class:TestLayout
test_gap_2	test/test_layout.rb	/^  def test_gap_2$/;"	f	class:TestLayout
test_ghost	test/test_core.rb	/^  def test_ghost$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_ghost_inline	test/test_core.rb	/^  def test_ghost_inline$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_gutter_custom	test/test_layout.rb	/^  def test_gutter_custom$/;"	f	class:TestLayout
test_gutter_default	test/test_layout.rb	/^  def test_gutter_default$/;"	f	class:TestLayout
test_gutter_default_no_unicode	test/test_layout.rb	/^  def test_gutter_default_no_unicode$/;"	f	class:TestLayout
test_header	test/test_core.rb	/^  def test_header$/;"	f	class:TestCore
test_header_and_header_lines	test/test_core.rb	/^  def test_header_and_header_lines$/;"	f	class:TestCore
test_header_and_header_lines_reverse	test/test_core.rb	/^  def test_header_and_header_lines_reverse$/;"	f	class:TestCore
test_header_and_header_lines_reverse_list	test/test_core.rb	/^  def test_header_and_header_lines_reverse_list$/;"	f	class:TestCore
test_header_border_and_label	test/test_layout.rb	/^  def test_header_border_and_label$/;"	f	class:TestLayout
test_header_border_and_label_header_first	test/test_layout.rb	/^  def test_header_border_and_label_header_first$/;"	f	class:TestLayout
test_header_border_and_label_with_list_border	test/test_layout.rb	/^  def test_header_border_and_label_with_list_border$/;"	f	class:TestLayout
test_header_border_and_label_with_list_border_header_first	test/test_layout.rb	/^  def test_header_border_and_label_with_list_border_header_first$/;"	f	class:TestLayout
test_header_border_no_pointer_and_marker	test/test_layout.rb	/^  def test_header_border_no_pointer_and_marker$/;"	f	class:TestLayout
test_header_border_toggle	test/test_layout.rb	/^  def test_header_border_toggle$/;"	f	class:TestLayout
test_header_border_toggle_with_header_lines	test/test_layout.rb	/^  def test_header_border_toggle_with_header_lines$/;"	f	class:TestLayout
test_header_border_toggle_with_header_lines_header_first	test/test_layout.rb	/^  def test_header_border_toggle_with_header_lines_header_first$/;"	f	class:TestLayout
test_header_border_toggle_with_header_lines_header_first_header_lines_border	test/test_layout.rb	/^  def test_header_border_toggle_with_header_lines_header_first_header_lines_border$/;"	f	class:TestLayout
test_header_border_toggle_with_header_lines_header_lines_border	test/test_layout.rb	/^  def test_header_border_toggle_with_header_lines_header_lines_border$/;"	f	class:TestLayout
test_header_first	test/test_layout.rb	/^  def test_header_first$/;"	f	class:TestLayout
test_header_first_reverse	test/test_layout.rb	/^  def test_header_first_reverse$/;"	f	class:TestLayout
test_header_lines	test/test_core.rb	/^  def test_header_lines$/;"	f	class:TestCore
test_header_lines_overflow	test/test_core.rb	/^  def test_header_lines_overflow$/;"	f	class:TestCore
test_header_lines_reverse	test/test_core.rb	/^  def test_header_lines_reverse$/;"	f	class:TestCore
test_header_lines_reverse_list	test/test_core.rb	/^  def test_header_lines_reverse_list$/;"	f	class:TestCore
test_header_lines_with_nth	test/test_core.rb	/^  def test_header_lines_with_nth$/;"	f	class:TestCore
test_header_reverse	test/test_core.rb	/^  def test_header_reverse$/;"	f	class:TestCore
test_header_reverse_list	test/test_core.rb	/^  def test_header_reverse_list$/;"	f	class:TestCore
test_height_range_fit	test/test_layout.rb	/^  def test_height_range_fit$/;"	f	class:TestLayout
test_height_range_fit_preview_above	test/test_layout.rb	/^  def test_height_range_fit_preview_above$/;"	f	class:TestLayout
test_height_range_fit_preview_above_alternative	test/test_layout.rb	/^  def test_height_range_fit_preview_above_alternative$/;"	f	class:TestLayout
test_height_range_fit_preview_left	test/test_layout.rb	/^  def test_height_range_fit_preview_left$/;"	f	class:TestLayout
test_height_range_overflow	test/test_layout.rb	/^  def test_height_range_overflow$/;"	f	class:TestLayout
test_height_range_with_exit_0	test/test_core.rb	/^  def test_height_range_with_exit_0$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_history	test/test_core.rb	/^  def test_history$/;"	f	class:TestCore
test_hscroll_off	test/test_core.rb	/^  def test_hscroll_off$/;"	f	class:TestCore
test_info_command	test/test_core.rb	/^  def test_info_command$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_info_command_and_focus	test/test_core.rb	/^  def test_info_command_and_focus$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_info_command_inline	test/test_core.rb	/^  def test_info_command_inline$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_info_command_inline_right	test/test_core.rb	/^  def test_info_command_inline_right$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_info_command_inline_right_no_ansi	test/test_core.rb	/^  def test_info_command_inline_right_no_ansi$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_info_command_right	test/test_core.rb	/^  def test_info_command_right$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_info_hidden	test/test_core.rb	/^  def test_info_hidden$/;"	f	class:TestCore
test_info_inline_right	test/test_core.rb	/^  def test_info_inline_right$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_info_inline_right_clearance	test/test_core.rb	/^  def test_info_inline_right_clearance$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_info_inline_separator	test/test_core.rb	/^  def test_info_inline_separator$/;"	f	class:TestCore
test_info_no_separator	test/test_core.rb	/^  def test_info_no_separator$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_info_right	test/test_core.rb	/^  def test_info_right$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_info_separator_ansi_colors_and_tabs	test/test_core.rb	/^  def test_info_separator_ansi_colors_and_tabs$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_info_separator_no_unicode	test/test_core.rb	/^  def test_info_separator_no_unicode$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_info_separator_repeat	test/test_core.rb	/^  def test_info_separator_repeat$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_info_separator_unicode	test/test_core.rb	/^  def test_info_separator_unicode$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_input_border_and_label	test/test_layout.rb	/^  def test_input_border_and_label$/;"	f	class:TestLayout
test_input_border_and_label_header_first	test/test_layout.rb	/^  def test_input_border_and_label_header_first$/;"	f	class:TestLayout
test_interrupt_execute	test/test_exec.rb	/^  def test_interrupt_execute$/;"	f	class:TestExec
test_invalid_cache	test/test_core.rb	/^  def test_invalid_cache$/;"	f	class:TestCore
test_invalid_cache_query_type	test/test_core.rb	/^  def test_invalid_cache_query_type$/;"	f	class:TestCore
test_invalid_option	test/test_core.rb	/^  def test_invalid_option$/;"	f	class:TestCore
test_inverse_only_search_should_not_sort_the_result	test/test_core.rb	/^  def test_inverse_only_search_should_not_sort_the_result$/;"	f	class:TestCore
test_item_index_reset_on_reload	test/test_exec.rb	/^  def test_item_index_reset_on_reload$/;"	f	class:TestExec
test_jump	test/test_core.rb	/^  def test_jump$/;"	f	class:TestCore
test_jump_accept	test/test_core.rb	/^  def test_jump_accept$/;"	f	class:TestCore
test_jump_events	test/test_core.rb	/^  def test_jump_events$/;"	f	class:TestCore
test_jump_no_pointer	test/test_core.rb	/^  def test_jump_no_pointer$/;"	f	class:TestCore
test_jump_no_pointer_no_marker	test/test_core.rb	/^  def test_jump_no_pointer_no_marker$/;"	f	class:TestCore
test_keep_right	test/test_core.rb	/^  def test_keep_right$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_key_bindings	test/test_core.rb	/^  def test_key_bindings$/;"	f	class:TestCore
test_kill_default_command_on_abort	test/test_exec.rb	/^  def test_kill_default_command_on_abort$/;"	f	class:TestExec
test_kill_default_command_on_accept	test/test_exec.rb	/^  def test_kill_default_command_on_accept$/;"	f	class:TestExec
test_kill_reload_command_on_abort	test/test_exec.rb	/^  def test_kill_reload_command_on_abort$/;"	f	class:TestExec
test_kill_reload_command_on_accept	test/test_exec.rb	/^  def test_kill_reload_command_on_accept$/;"	f	class:TestExec
test_label_truncation	test/test_layout.rb	/^  def test_label_truncation$/;"	f	class:TestLayout
test_labels_bottom	test/test_core.rb	/^  def test_labels_bottom$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_labels_center	test/test_core.rb	/^  def test_labels_center$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_labels_left	test/test_core.rb	/^  def test_labels_left$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_labels_right	test/test_core.rb	/^  def test_labels_right$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_labels_variables	test/test_core.rb	/^  def test_labels_variables$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_layout_default_with_footer	test/test_layout.rb	/^  def test_layout_default_with_footer$/;"	f	class:TestLayout
test_layout_reverse_list	test/test_layout.rb	/^  def test_layout_reverse_list$/;"	f	class:TestLayout
test_layout_reverse_list_with_footer	test/test_layout.rb	/^  def test_layout_reverse_list_with_footer$/;"	f	class:TestLayout
test_list_border_and_label	test/test_layout.rb	/^  def test_list_border_and_label$/;"	f	class:TestLayout
test_list_input_border_and_label	test/test_layout.rb	/^  def test_list_input_border_and_label$/;"	f	class:TestLayout
test_list_input_border_and_label_header_first	test/test_layout.rb	/^  def test_list_input_border_and_label_header_first$/;"	f	class:TestLayout
test_listen	test/test_server.rb	/^  def test_listen$/;"	f	class:TestServer
test_listen_with_api_key	test/test_server.rb	/^  def test_listen_with_api_key$/;"	f	class:TestServer
test_long_line	test/test_filter.rb	/^  def test_long_line$/;"	f	class:TestFilter
test_margin	test/test_core.rb	/^  def test_margin$/;"	f	class:TestCore
test_margin_reverse	test/test_core.rb	/^  def test_margin_reverse$/;"	f	class:TestCore
test_margin_reverse_list	test/test_core.rb	/^  def test_margin_reverse_list$/;"	f	class:TestCore
test_marker	test/test_core.rb	/^  def test_marker$/;"	f	class:TestCore
test_min_height_auto	test/test_layout.rb	/^  def test_min_height_auto$/;"	f	class:TestLayout
test_min_height_auto_no_input	test/test_layout.rb	/^  def test_min_height_auto_no_input$/;"	f	class:TestLayout
test_min_height_auto_no_input_reverse_list	test/test_layout.rb	/^  def test_min_height_auto_no_input_reverse_list$/;"	f	class:TestLayout
test_min_height_no_auto	test/test_layout.rb	/^  def test_min_height_no_auto$/;"	f	class:TestLayout
test_multi_action	test/test_core.rb	/^  def test_multi_action$/;"	f	class:TestCore
test_multi_event	test/test_core.rb	/^  def test_multi_event$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_multi_max	test/test_core.rb	/^  def test_multi_max$/;"	f	class:TestCore
test_multi_order	test/test_core.rb	/^  def test_multi_order$/;"	f	class:TestCore
test_no_clear	test/test_core.rb	/^  def test_no_clear$/;"	f	class:TestCore
test_no_extra_newline_issue_3209	test/test_layout.rb	/^  def test_no_extra_newline_issue_3209$/;"	f	class:TestLayout
test_no_input_change_query	test/test_core.rb	/^  def test_no_input_change_query$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_no_input_query	test/test_core.rb	/^  def test_no_input_query$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_no_scrollbar_preview_toggle	test/test_layout.rb	/^  def test_no_scrollbar_preview_toggle$/;"	f	class:TestLayout
test_normalized_match	test/test_filter.rb	/^  def test_normalized_match$/;"	f	class:TestFilter
test_nth_suffix_match	test/test_filter.rb	/^  def test_nth_suffix_match$/;"	f	class:TestFilter
test_offset_middle	test/test_core.rb	/^  def test_offset_middle$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_one_and_zero	test/test_core.rb	/^  def test_one_and_zero$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_or_operator	test/test_filter.rb	/^  def test_or_operator$/;"	f	class:TestFilter
test_partial_caching	test/test_core.rb	/^  def test_partial_caching$/;"	f	class:TestCore
test_pointer	test/test_core.rb	/^  def test_pointer$/;"	f	class:TestCore
test_pointer_with_jump	test/test_core.rb	/^  def test_pointer_with_jump$/;"	f	class:TestCore
test_pos	test/test_core.rb	/^  def test_pos$/;"	f	class:TestCore
test_preserve_selection_on_revision_bump	test/test_core.rb	/^  def test_preserve_selection_on_revision_bump$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_prev_next_selected	test/test_core.rb	/^  def test_prev_next_selected$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_preview	test/test_preview.rb	/^  def test_preview$/;"	f	class:TestPreview
test_preview_asterisk	test/test_preview.rb	/^  def test_preview_asterisk$/;"	f	class:TestPreview
test_preview_bindings_with_default_preview	test/test_preview.rb	/^  def test_preview_bindings_with_default_preview$/;"	f	class:TestPreview
test_preview_bindings_without_default_preview	test/test_preview.rb	/^  def test_preview_bindings_without_default_preview$/;"	f	class:TestPreview
test_preview_clear_screen	test/test_preview.rb	/^  def test_preview_clear_screen$/;"	f	class:TestPreview
test_preview_correct_tab_width_after_ansi_reset_code	test/test_preview.rb	/^  def test_preview_correct_tab_width_after_ansi_reset_code$/;"	f	class:TestPreview
test_preview_file	test/test_preview.rb	/^  def test_preview_file$/;"	f	class:TestPreview
test_preview_flags	test/test_preview.rb	/^  def test_preview_flags$/;"	f	class:TestPreview
test_preview_header	test/test_preview.rb	/^  def test_preview_header$/;"	f	method:TestPreview.test_preview_clear_screen
test_preview_hidden	test/test_preview.rb	/^  def test_preview_hidden$/;"	f	class:TestPreview
test_preview_q_no_match	test/test_preview.rb	/^  def test_preview_q_no_match$/;"	f	class:TestPreview
test_preview_q_no_match_with_initial_query	test/test_preview.rb	/^  def test_preview_q_no_match_with_initial_query$/;"	f	class:TestPreview
test_preview_query_should_not_be_affected_by_search	test/test_preview.rb	/^  def test_preview_query_should_not_be_affected_by_search$/;"	f	method:TestPreview.test_preview_clear_screen
test_preview_scroll_begin_and_offset	test/test_preview.rb	/^  def test_preview_scroll_begin_and_offset$/;"	f	class:TestPreview
test_preview_scroll_begin_constant	test/test_preview.rb	/^  def test_preview_scroll_begin_constant$/;"	f	class:TestPreview
test_preview_scroll_begin_expr	test/test_preview.rb	/^  def test_preview_scroll_begin_expr$/;"	f	class:TestPreview
test_preview_size_0	test/test_preview.rb	/^  def test_preview_size_0$/;"	f	class:TestPreview
test_preview_size_0_hidden	test/test_preview.rb	/^  def test_preview_size_0_hidden$/;"	f	class:TestPreview
test_preview_update_on_select	test/test_preview.rb	/^  def test_preview_update_on_select$/;"	f	class:TestPreview
test_preview_window_follow	test/test_preview.rb	/^  def test_preview_window_follow$/;"	f	method:TestPreview.test_preview_clear_screen
test_preview_window_hidden_on_focus	test/test_preview.rb	/^  def test_preview_window_hidden_on_focus$/;"	f	method:TestPreview.test_preview_clear_screen
test_preview_window_noinfo	test/test_layout.rb	/^  def test_preview_window_noinfo$/;"	f	class:TestLayout
test_preview_window_width_exception	test/test_preview.rb	/^  def test_preview_window_width_exception$/;"	f	method:TestPreview.test_preview_clear_screen
test_process_completion	test/test_shell_integration.rb	/^  def test_process_completion$/;"	f	method:TestShell.CompletionTest.test_file_completion
test_put	test/test_core.rb	/^  def test_put$/;"	f	class:TestCore
test_query_unicode	test/test_core.rb	/^  def test_query_unicode$/;"	f	class:TestCore
test_read0	test/test_filter.rb	/^  def test_read0$/;"	f	class:TestFilter
test_reload	test/test_exec.rb	/^  def test_reload$/;"	f	class:TestExec
test_reload_and_change	test/test_exec.rb	/^  def test_reload_and_change$/;"	f	class:TestExec
test_reload_and_change_cache	test/test_layout.rb	/^  def test_reload_and_change_cache$/;"	f	class:TestLayout
test_reload_and_change_preview_should_update_preview	test/test_exec.rb	/^  def test_reload_and_change_preview_should_update_preview$/;"	f	class:TestExec
test_reload_disabled_case1	test/test_exec.rb	/^  def test_reload_disabled_case1$/;"	f	class:TestExec
test_reload_disabled_case2	test/test_exec.rb	/^  def test_reload_disabled_case2$/;"	f	class:TestExec
test_reload_disabled_case3	test/test_exec.rb	/^  def test_reload_disabled_case3$/;"	f	class:TestExec
test_reload_disabled_case4	test/test_exec.rb	/^  def test_reload_disabled_case4$/;"	f	class:TestExec
test_reload_disabled_case5	test/test_exec.rb	/^  def test_reload_disabled_case5$/;"	f	class:TestExec
test_reload_disabled_case6	test/test_exec.rb	/^  def test_reload_disabled_case6$/;"	f	class:TestExec
test_reload_even_when_theres_no_match	test/test_exec.rb	/^  def test_reload_even_when_theres_no_match$/;"	f	class:TestExec
test_reload_should_terminate_standard_input_stream	test/test_exec.rb	/^  def test_reload_should_terminate_standard_input_stream$/;"	f	class:TestExec
test_reload_should_update_preview	test/test_exec.rb	/^  def test_reload_should_update_preview$/;"	f	class:TestExec
test_reload_sync	test/test_exec.rb	/^  def test_reload_sync$/;"	f	class:TestExec
test_render_order	test/test_core.rb	/^  def test_render_order$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_result_event	test/test_core.rb	/^  def test_result_event$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_scroll	test/test_core.rb	/^  def test_scroll$/;"	f	class:TestCore
test_scroll_off	test/test_core.rb	/^  def test_scroll_off$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_scroll_off_large	test/test_core.rb	/^  def test_scroll_off_large$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_search	test/test_core.rb	/^  def test_search$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_search_override_query_in_no_input_mode	test/test_core.rb	/^  def test_search_override_query_in_no_input_mode$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_select_1	test/test_core.rb	/^  def test_select_1$/;"	f	class:TestCore
test_select_1_accept_nth	test/test_core.rb	/^  def test_select_1_accept_nth$/;"	f	class:TestCore
test_select_1_exit_0_fail	test/test_core.rb	/^  def test_select_1_exit_0_fail$/;"	f	class:TestCore
test_select_all_deselect_all_toggle_all	test/test_core.rb	/^  def test_select_all_deselect_all_toggle_all$/;"	f	class:TestCore
test_select_deselect	test/test_core.rb	/^  def test_select_deselect$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_separator_no_ellipsis	test/test_layout.rb	/^  def test_separator_no_ellipsis$/;"	f	class:TestLayout
test_show_and_hide_preview	test/test_preview.rb	/^  def test_show_and_hide_preview$/;"	f	class:TestPreview
test_smart_case_for_each_term	test/test_filter.rb	/^  def test_smart_case_for_each_term$/;"	f	class:TestFilter
test_ssh_completion	test/test_shell_integration.rb	/^  def test_ssh_completion$/;"	f	method:TestShell.CompletionTest.test_file_completion
test_start_event	test/test_core.rb	/^  def test_start_event$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_start_on_reload	test/test_exec.rb	/^  def test_start_on_reload$/;"	f	class:TestExec
test_strip_xterm_osc_sequence	test/test_core.rb	/^  def test_strip_xterm_osc_sequence$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_style_full_adaptive_height	test/test_layout.rb	/^  def test_style_full_adaptive_height$/;"	f	class:TestLayout
test_style_full_adaptive_height_double	test/test_layout.rb	/^  def test_style_full_adaptive_height_double$/;"	f	class:TestLayout
test_subword_backward	test/test_core.rb	/^  def test_subword_backward$/;"	f	class:TestCore
test_subword_forward	test/test_core.rb	/^  def test_subword_forward$/;"	f	class:TestCore
test_sync	test/test_core.rb	/^  def test_sync$/;"	f	class:TestCore
test_tabstop	test/test_core.rb	/^  def test_tabstop$/;"	f	class:TestCore
test_tac	test/test_core.rb	/^  def test_tac$/;"	f	class:TestCore
test_tac_nosort	test/test_core.rb	/^  def test_tac_nosort$/;"	f	class:TestCore
test_tac_sort	test/test_core.rb	/^  def test_tac_sort$/;"	f	class:TestCore
test_tiebreak	test/test_filter.rb	/^  def test_tiebreak$/;"	f	class:TestFilter
test_tiebreak_begin_algo_v2	test/test_filter.rb	/^  def test_tiebreak_begin_algo_v2$/;"	f	class:TestFilter
test_tiebreak_chunk	test/test_filter.rb	/^  def test_tiebreak_chunk$/;"	f	class:TestFilter
test_tiebreak_end	test/test_filter.rb	/^  def test_tiebreak_end$/;"	f	class:TestFilter
test_tiebreak_index_begin	test/test_filter.rb	/^  def test_tiebreak_index_begin$/;"	f	class:TestFilter
test_tiebreak_length_with_nth	test/test_filter.rb	/^  def test_tiebreak_length_with_nth$/;"	f	class:TestFilter
test_toggle_alternative_preview_window	test/test_preview.rb	/^  def test_toggle_alternative_preview_window$/;"	f	method:TestPreview.test_preview_clear_screen
test_toggle_header	test/test_layout.rb	/^  def test_toggle_header$/;"	f	class:TestLayout
test_toggle_preview_without_default_preview_command	test/test_preview.rb	/^  def test_toggle_preview_without_default_preview_command$/;"	f	class:TestPreview
test_toggle_preview_wrap	test/test_preview.rb	/^  def test_toggle_preview_wrap$/;"	f	method:TestPreview.test_preview_clear_screen
test_toggle_sort	test/test_core.rb	/^  def test_toggle_sort$/;"	f	class:TestCore
test_track	test/test_core.rb	/^  def test_track$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_track_action	test/test_core.rb	/^  def test_track_action$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_trailing_new_line	test/test_core.rb	/^  def test_trailing_new_line$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_transform	test/test_core.rb	/^  def test_transform$/;"	f	method:TestCore.test_transform_query.test_transform_prompt
test_transform_pointer	test/test_core.rb	/^  def test_transform_pointer$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_transform_prompt	test/test_core.rb	/^  def test_transform_prompt$/;"	f	method:TestCore.test_transform_query
test_transform_query	test/test_core.rb	/^  def test_transform_query$/;"	f	class:TestCore
test_transform_search	test/test_core.rb	/^  def test_transform_search$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_trigger	test/test_core.rb	/^  def test_trigger$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_unbind_rebind_toggle_bind	test/test_core.rb	/^  def test_unbind_rebind_toggle_bind$/;"	f	method:TestCore.test_transform_query.test_transform_prompt.test_transform
test_unicode_case	test/test_filter.rb	/^  def test_unicode_case$/;"	f	class:TestFilter
test_unset_completion	test/test_shell_integration.rb	/^  def test_unset_completion$/;"	f	method:TestShell.CompletionTest.test_file_completion
test_vanilla	test/test_layout.rb	/^  def test_vanilla$/;"	f	class:TestLayout
test_with_nth	test/test_core.rb	/^  def test_with_nth$/;"	f	class:TestCore
test_with_nth_ansi	test/test_filter.rb	/^  def test_with_nth_ansi$/;"	f	class:TestFilter
test_with_nth_basic	test/test_filter.rb	/^  def test_with_nth_basic$/;"	f	class:TestFilter
test_with_nth_no_ansi	test/test_filter.rb	/^  def test_with_nth_no_ansi$/;"	f	class:TestFilter
test_with_nth_template	test/test_filter.rb	/^  def test_with_nth_template$/;"	f	class:TestFilter
text	src/item.go	/^	text        util.Chars    \/\/ 32 = 24 + 1 + 1 + 2 + 4$/;"	m	struct:fzf.Item	typeref:typename:util.Chars
text	src/pattern.go	/^	text          []rune$/;"	m	struct:fzf.Pattern	typeref:typename:[]rune
text	src/pattern.go	/^	text          []rune$/;"	m	struct:fzf.term	typeref:typename:[]rune
text	src/tokenizer.go	/^	text         *util.Chars$/;"	m	struct:fzf.Token	typeref:typename:*util.Chars
text	src/tui/light.go	/^	text         string$/;"	m	struct:tui.wrappedLine	typeref:typename:string
theme	src/terminal.go	/^	theme              *tui.ColorTheme$/;"	m	struct:fzf.Terminal	typeref:typename:*tui.ColorTheme
theme	src/tui/light.go	/^	theme         *ColorTheme$/;"	m	struct:tui.LightRenderer	typeref:typename:*ColorTheme
theme	src/tui/tui.go	/^	theme        *ColorTheme$/;"	m	struct:tui.FullscreenRenderer	typeref:typename:*ColorTheme
threshold	src/options.go	/^	threshold   int$/;"	m	struct:fzf.previewOpts	typeref:typename:int
timeoutInterval	src/tui/light_windows.go	/^	timeoutInterval = 10$/;"	c	package:tui
tmux	test/lib/common.rb	/^  attr_reader :tmux$/;"	A	class:TestInteractive
tmux	test/test_shell_integration.rb	/^  attr_reader :tmux$/;"	A	module:TestShell
tmuxOptions	src/options.go	/^type tmuxOptions struct {$/;"	s	package:fzf
to avoid parse errors and add more actions to the same key	CHANGELOG.md	/^  # to avoid parse errors and add more actions to the same key$/;"	c
toActions	src/terminal.go	/^func toActions(types ...actionType) []*action {$/;"	f	package:fzf	typeref:typename:[]*action
toAnsiString	src/ansi.go	/^func toAnsiString(color tui.Color, offset int) string {$/;"	f	package:fzf	typeref:typename:string
toggleItem	src/terminal.go	/^func (t *Terminal) toggleItem(item *Item) bool {$/;"	f	struct:fzf.Terminal	typeref:typename:bool
toggleSort	src/terminal.go	/^	toggleSort         bool$/;"	m	struct:fzf.Terminal	typeref:typename:bool
tokens	src/item.go	/^	tokens   []Token$/;"	m	struct:fzf.transformed	typeref:typename:[]Token
tomasr/molokai	ADVANCED.md	/^# tomasr\/molokai$/;"	c
top	src/tui/light.go	/^	top           int$/;"	m	struct:tui.LightWindow	typeref:typename:int
top	src/tui/tcell.go	/^	top           int$/;"	m	struct:tui.TcellWindow	typeref:typename:int
top	src/tui/tui.go	/^	top         rune$/;"	m	struct:tui.BorderStyle	typeref:typename:rune
topLeft	src/tui/tui.go	/^	topLeft     rune$/;"	m	struct:tui.BorderStyle	typeref:typename:rune
topRight	src/tui/tui.go	/^	topRight    rune$/;"	m	struct:tui.BorderStyle	typeref:typename:rune
track	src/terminal.go	/^	track              trackOption$/;"	m	struct:fzf.Terminal	typeref:typename:trackOption
trackCurrent	src/options.go	/^	trackCurrent$/;"	c	package:fzf
trackDisabled	src/options.go	/^	trackDisabled trackOption = iota$/;"	c	package:fzf	typeref:type:trackOption
trackEnabled	src/options.go	/^	trackEnabled$/;"	c	package:fzf
trackOption	src/options.go	/^type trackOption int$/;"	t	package:fzf	typeref:typename:int
trans	src/chunklist.go	/^	trans  ItemBuilder$/;"	m	struct:fzf.ChunkList	typeref:typename:ItemBuilder
transformInput	src/pattern.go	/^func (p *Pattern) transformInput(item *Item) []Token {$/;"	f	struct:fzf.Pattern	typeref:typename:[]Token
transformed	src/item.go	/^	transformed *transformed  \/\/ 8$/;"	m	struct:fzf.Item	typeref:typename:*transformed
transformed	src/item.go	/^type transformed struct {$/;"	s	package:fzf
triggerLoad	src/terminal.go	/^	triggerLoad        bool$/;"	m	struct:fzf.Terminal	typeref:typename:bool
trimLeft	src/terminal.go	/^func (t *Terminal) trimLeft(runes []rune, width int, ellipsisWidth int) ([]rune, int32) {$/;"	f	struct:fzf.Terminal	typeref:typename:([]rune, int32)
trimLength	src/util/chars.go	/^	trimLength      uint16$/;"	m	struct:util.Chars	typeref:typename:uint16
trimLengthKnown	src/util/chars.go	/^	trimLengthKnown bool$/;"	m	struct:util.Chars	typeref:typename:bool
trimMessage	src/terminal.go	/^func (t *Terminal) trimMessage(message string, maxWidth int) string {$/;"	f	struct:fzf.Terminal	typeref:typename:string
trimPath	src/reader.go	/^func trimPath(path string) string {$/;"	f	package:fzf	typeref:typename:string
trimQuery	src/terminal.go	/^func trimQuery(query string) []rune {$/;"	f	package:fzf	typeref:typename:[]rune
trimRight	src/terminal.go	/^func (t *Terminal) trimRight(runes []rune, width int) ([]rune, bool) {$/;"	f	struct:fzf.Terminal	typeref:typename:([]rune, bool)
truncateQuery	src/terminal.go	/^func (t *Terminal) truncateQuery() {$/;"	f	struct:fzf.Terminal
tryLock	src/terminal.go	/^func (t *Terminal) tryLock(timeout time.Duration) bool {$/;"	f	struct:fzf.Terminal	typeref:typename:bool
trySkip	src/algo/algo.go	/^func trySkip(input *util.Chars, caseSensitive bool, b byte, from int) int {$/;"	f	package:algo	typeref:typename:int
try_curl	install	/^try_curl() {$/;"	f
try_wget	install	/^try_wget() {$/;"	f
tty	src/tui/ttyname_unix.go	/^var tty atomic.Value$/;"	v	package:tui	typeref:typename:atomic.Value
ttyDefault	src/terminal.go	/^	ttyDefault         string$/;"	m	struct:fzf.Terminal	typeref:typename:string
ttyin	src/terminal.go	/^	ttyin              *os.File$/;"	m	struct:fzf.Terminal	typeref:typename:*os.File
ttyin	src/terminal.go	/^var ttyin *os.File$/;"	v	package:fzf	typeref:typename:*os.File
ttyin	src/tui/light.go	/^	ttyin         *os.File$/;"	m	struct:tui.LightRenderer	typeref:typename:*os.File
ttyinChannel	src/tui/light.go	/^	ttyinChannel    chan byte$/;"	m	struct:tui.LightRenderer	typeref:typename:chan byte
ttyname	src/tui/ttyname_unix.go	/^func ttyname() string {$/;"	f	package:tui	typeref:typename:string
ttyname	src/tui/ttyname_windows.go	/^func ttyname() string {$/;"	f	package:tui	typeref:typename:string
ttyout	src/tui/light.go	/^	ttyout        *os.File$/;"	m	struct:tui.LightRenderer	typeref:typename:*os.File
tui	src/terminal.go	/^	tui                tui.Renderer$/;"	m	struct:fzf.Terminal	typeref:typename:tui.Renderer
tui	src/tui/dummy.go	/^package tui$/;"	p
tui	src/tui/eventtype_string.go	/^package tui$/;"	p
tui	src/tui/light.go	/^package tui$/;"	p
tui	src/tui/light_test.go	/^package tui$/;"	p
tui	src/tui/light_unix.go	/^package tui$/;"	p
tui	src/tui/light_windows.go	/^package tui$/;"	p
tui	src/tui/tcell.go	/^package tui$/;"	p
tui	src/tui/tcell_test.go	/^package tui$/;"	p
tui	src/tui/ttyname_unix.go	/^package tui$/;"	p
tui	src/tui/ttyname_windows.go	/^package tui$/;"	p
tui	src/tui/tui.go	/^package tui$/;"	p
tui	src/tui/tui_test.go	/^package tui$/;"	p
typ	src/pattern.go	/^	typ           termType$/;"	m	struct:fzf.term	typeref:typename:termType
uiMutex	src/terminal.go	/^	uiMutex            sync.Mutex$/;"	m	struct:fzf.Terminal	typeref:typename:sync.Mutex
unicode	src/terminal.go	/^	unicode            bool$/;"	m	struct:fzf.Terminal	typeref:typename:bool
unset_var	test/test_shell_integration.rb	/^  def unset_var(name)$/;"	f	module:TestShell
until	test/lib/common.rb	/^  def until(refresh = false, timeout: DEFAULT_TIMEOUT)$/;"	f	class:Tmux
upOneLine	src/tui/light.go	/^	upOneLine     bool$/;"	m	struct:tui.LightRenderer	typeref:typename:bool
update	Makefile	/^update:$/;"	t
update	shell/update.sh	/^update() {$/;"	f
updatePromptOffset	src/terminal.go	/^func (t *Terminal) updatePromptOffset() ([]rune, []rune) {$/;"	f	struct:fzf.Terminal	typeref:typename:([]rune, []rune)
updateTerminalSize	src/tui/light_unix.go	/^func (r *LightRenderer) updateTerminalSize() {$/;"	f	unknown:tui.LightRenderer
updateTerminalSize	src/tui/light_windows.go	/^func (r *LightRenderer) updateTerminalSize() {$/;"	f	unknown:tui.LightRenderer
uri	src/ansi.go	/^	uri    string$/;"	m	struct:fzf.url	typeref:typename:string
uri	src/tui/tcell.go	/^	uri           *string$/;"	m	struct:tui.TcellWindow	typeref:typename:*string
url	src/ansi.go	/^	url  *url$/;"	m	struct:fzf.ansiState	typeref:typename:*url
url	src/ansi.go	/^type url struct {$/;"	s	package:fzf
url	src/result.go	/^	url    *url$/;"	m	struct:fzf.colorOffset	typeref:typename:*url
usage: _fzf_setup_completion path|dir COMMANDS...	CHANGELOG.md	/^  # usage: _fzf_setup_completion path|dir COMMANDS...$/;"	c
useTmux	src/options.go	/^func (opts *Options) useTmux() bool {$/;"	f	struct:fzf.Options	typeref:typename:bool
util	src/util/atexit.go	/^package util$/;"	p
util	src/util/atexit_test.go	/^package util$/;"	p
util	src/util/atomicbool.go	/^package util$/;"	p
util	src/util/atomicbool_test.go	/^package util$/;"	p
util	src/util/chars.go	/^package util$/;"	p
util	src/util/chars_test.go	/^package util$/;"	p
util	src/util/concurrent_set.go	/^package util$/;"	p
util	src/util/eventbox.go	/^package util$/;"	p
util	src/util/eventbox_test.go	/^package util$/;"	p
util	src/util/slab.go	/^package util$/;"	p
util	src/util/util.go	/^package util$/;"	p
util	src/util/util_test.go	/^package util$/;"	p
util	src/util/util_unix.go	/^package util$/;"	p
util	src/util/util_windows.go	/^package util$/;"	p
valid	src/terminal.go	/^	valid     bool$/;"	m	struct:fzf.itemLine	typeref:typename:bool
validateOptions	src/options.go	/^func validateOptions(opts *Options) error {$/;"	f	package:fzf	typeref:typename:error
validateSign	src/options.go	/^func validateSign(sign string, signOptName string, maxWidth int) error {$/;"	f	package:fzf	typeref:typename:error
version	install.ps1	/^$version="0.65.2"$/;"	v
version	main.go	/^var version = "0.65"$/;"	v	package:main
version	src/terminal.go	/^	version            int64$/;"	m	struct:fzf.Terminal	typeref:typename:int64
version	src/terminal.go	/^	version    int64$/;"	m	struct:fzf.previewer	typeref:typename:int64
version	src/terminal.go	/^	version   int64$/;"	m	struct:fzf.previewed	typeref:typename:int64
version	src/terminal.go	/^	version  int64$/;"	m	struct:fzf.versionedCallback	typeref:typename:int64
version	src/terminal.go	/^	version int64$/;"	m	struct:fzf.previewResult	typeref:typename:int64
versionedCallback	src/terminal.go	/^type versionedCallback struct {$/;"	s	package:fzf
visibleHeaderLines	src/terminal.go	/^func (t *Terminal) visibleHeaderLines() int {$/;"	f	struct:fzf.Terminal	typeref:typename:int
visibleHeaderLinesInList	src/terminal.go	/^func (t *Terminal) visibleHeaderLinesInList() int {$/;"	f	struct:fzf.Terminal	typeref:typename:int
visibleInputLinesInList	src/terminal.go	/^func (t *Terminal) visibleInputLinesInList() int {$/;"	f	struct:fzf.Terminal	typeref:typename:int
vmove	src/terminal.go	/^func (t *Terminal) vmove(o int, allowCycle bool) {$/;"	f	struct:fzf.Terminal
vset	src/terminal.go	/^func (t *Terminal) vset(o int) bool {$/;"	f	struct:fzf.Terminal	typeref:typename:bool
wait	src/reader.go	/^	wait     bool$/;"	m	struct:fzf.Reader	typeref:typename:bool
wait	test/lib/common.rb	/^def wait(timeout = DEFAULT_TIMEOUT)$/;"	f
walkerOpts	src/options.go	/^type walkerOpts struct {$/;"	s	package:fzf
want	src/terminal_test.go	/^	want$/;"	M	struct:fzf.testCase	typeref:typename:want
want	src/terminal_test.go	/^type want struct {$/;"	s	package:fzf
wborder	src/terminal.go	/^	wborder            tui.Window$/;"	m	struct:fzf.Terminal	typeref:typename:tui.Window
whiteChars	src/algo/algo.go	/^const whiteChars = " \\t\\n\\v\\f\\r\\x85\\xA0"$/;"	c	package:algo
whiteSuffix	src/terminal.go	/^var whiteSuffix *regexp.Regexp$/;"	v	package:fzf	typeref:typename:*regexp.Regexp
width	src/options.go	/^	width    sizeSpec$/;"	m	struct:fzf.tmuxOptions	typeref:typename:sizeSpec
width	src/terminal.go	/^	width     int$/;"	m	struct:fzf.itemLine	typeref:typename:int
width	src/tui/light.go	/^	width         int$/;"	m	struct:tui.LightRenderer	typeref:typename:int
width	src/tui/light.go	/^	width         int$/;"	m	struct:tui.LightWindow	typeref:typename:int
width	src/tui/tcell.go	/^	width         int$/;"	m	struct:tui.TcellWindow	typeref:typename:int
win	test/lib/common.rb	/^  attr_reader :win$/;"	A	class:Tmux
window	src/terminal.go	/^	window             tui.Window$/;"	m	struct:fzf.Terminal	typeref:typename:tui.Window
windowPosition	src/options.go	/^type windowPosition int$/;"	t	package:fzf	typeref:typename:int
windowType	src/tui/light.go	/^	windowType    WindowType$/;"	m	struct:tui.LightWindow	typeref:typename:WindowType
windowType	src/tui/tcell.go	/^	windowType    WindowType$/;"	m	struct:tui.TcellWindow	typeref:typename:WindowType
wipe	src/terminal.go	/^	wipe      bool$/;"	m	struct:fzf.previewed	typeref:typename:bool
wireframe	src/terminal.go	/^	wireframe bool$/;"	m	struct:fzf.previewed	typeref:typename:bool
withIndex	src/result_test.go	/^func withIndex(i *Item, index int) *Item {$/;"	f	package:fzf	typeref:typename:*Item
withInputPipe	src/proxy_unix.go	/^func withInputPipe(input string, task func(io.WriteCloser)) error {$/;"	f	package:fzf	typeref:typename:error
withInputPipe	src/proxy_windows.go	/^func withInputPipe(input string, task func(io.WriteCloser)) error {$/;"	f	package:fzf	typeref:typename:error
withOutputPipe	src/proxy_unix.go	/^func withOutputPipe(output string, task func(io.ReadCloser)) error {$/;"	f	package:fzf	typeref:typename:error
withOutputPipe	src/proxy_windows.go	/^func withOutputPipe(output string, task func(io.ReadCloser)) error {$/;"	f	package:fzf	typeref:typename:error
withPos	src/pattern.go	/^	withPos       bool$/;"	m	struct:fzf.Pattern	typeref:typename:bool
withPrefixLengths	src/tokenizer.go	/^func withPrefixLengths(tokens []string, begin int) []Token {$/;"	f	package:fzf	typeref:typename:[]Token
withUrl	src/tui/tcell.go	/^func (w *TcellWindow) withUrl(style tcell.Style) tcell.Style {$/;"	f	struct:tui.TcellWindow	typeref:typename:tcell.Style
withWindow	src/terminal.go	/^func (t *Terminal) withWindow(w tui.Window, f func()) {$/;"	f	struct:fzf.Terminal
wordNext	src/terminal.go	/^	wordNext           string$/;"	m	struct:fzf.Terminal	typeref:typename:string
wordRubout	src/terminal.go	/^	wordRubout         string$/;"	m	struct:fzf.Terminal	typeref:typename:string
wrap	src/options.go	/^	wrap        bool$/;"	m	struct:fzf.previewOpts	typeref:typename:bool
wrap	src/terminal.go	/^	wrap               bool$/;"	m	struct:fzf.Terminal	typeref:typename:bool
wrapCols	src/terminal.go	/^func (t *Terminal) wrapCols() int {$/;"	f	struct:fzf.Terminal	typeref:typename:int
wrapLine	src/tui/light.go	/^func wrapLine(input string, prefixLength int, initialMax int, tabstop int, wrapSignWidth int) []/;"	f	package:tui	typeref:typename:[]wrappedLine
wrapSign	src/terminal.go	/^	wrapSign           string$/;"	m	struct:fzf.Terminal	typeref:typename:string
wrapSign	src/tui/light.go	/^	wrapSign      string$/;"	m	struct:tui.LightWindow	typeref:typename:string
wrapSign	src/tui/tcell.go	/^	wrapSign      string$/;"	m	struct:tui.TcellWindow	typeref:typename:string
wrapSignWidth	src/terminal.go	/^	wrapSignWidth      int$/;"	m	struct:fzf.Terminal	typeref:typename:int
wrapSignWidth	src/tui/light.go	/^	wrapSignWidth int$/;"	m	struct:tui.LightWindow	typeref:typename:int
wrapSignWidth	src/tui/tcell.go	/^	wrapSignWidth int$/;"	m	struct:tui.TcellWindow	typeref:typename:int
wrappedLine	src/tui/light.go	/^type wrappedLine struct {$/;"	s	package:tui
writelines	test/lib/common.rb	/^  def writelines(lines)$/;"	f	class:TestBase
x	src/tui/light.go	/^	x             int$/;"	m	struct:tui.LightRenderer	typeref:typename:int
xoffset	src/terminal.go	/^	xoffset            int$/;"	m	struct:fzf.Terminal	typeref:typename:int
xw	src/terminal.go	/^	xw         [2]int$/;"	m	struct:fzf.previewer	typeref:typename:[2]int
y	src/tui/light.go	/^	y             int$/;"	m	struct:tui.LightRenderer	typeref:typename:int
yanked	src/terminal.go	/^	yanked             []rune$/;"	m	struct:fzf.Terminal	typeref:typename:[]rune
yoffset	src/tui/light.go	/^	yoffset       int$/;"	m	struct:tui.LightRenderer	typeref:typename:int
zsh	test/lib/common.rb	/^    def zsh$/;"	S	class:Shell
zshCompletion	main.go	/^var zshCompletion []byte$/;"	v	package:main	typeref:typename:[]byte
zshKeyBindings	main.go	/^var zshKeyBindings []byte$/;"	v	package:main	typeref:typename:[]byte
